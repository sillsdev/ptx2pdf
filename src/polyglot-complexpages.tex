%:strip
% polyglot-complexpages.tex: multi-page polyglot processing for xetex paratext2.tex
% Copyright (c) 2025 by SIL International 
% written by David Gardner
% 
% This optional plugin (see ptx-plugins) extends the basic diglot engine to
% provide complex, multipage polyglot options. There is no synchronisation across pages.
%
% Permission is hereby granted, free of charge, to any person obtaining
% a copy of this software and associated documentation files (the  
% "Software"), to deal in the Software without restriction, including  
% without limitation the rights to use, copy, modify, merge, publish,  
% distribute, sublicense, and/or sell copies of the Software, and to  
% permit persons to whom the Software is furnished to do so, subject to  
% the following conditions:
%
% The above copyright notice and this permission notice shall be  
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  
% NONINFRINGEMENT. IN NO EVENT SHALL SIL INTERNATIONAL BE LIABLE FOR  
% ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  
% WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
%
% Except as contained in this notice, the name of SIL International  
% shall not be used in advertising or otherwise to promote the sale,  
% use or other dealings in this Software without prior written  
% authorization from SIL International.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\plugin@startif{polyglot-complexpages}
\plugins@needed{polyglot-simplepages} % 
\newcount\f@llow@n % Global register of 'invented' columns

\def\new@followon#1{%
  \ifnum\f@llow@n=0
    \global\f@llow@n=`Z
    \global\advance\f@llow@n -63 % We know it'll be reduced by 1 later on...
  \fi
  \count255=\f@llow@n
  \edef\s@ffix{#1}%
  \loop% Get to the last f@llow@n of the parent
    \tempfalse\ifcsname f@llow@n\s@ffix\endcsname
      \x@\let\x@\tmp\csname f@llow@n\s@ffix\endcsname\ifx\tmp\undefined\else\ifx\tmp\empty\else
        \let\s@ffix\tmp
        %\trace{dmc}{tmp is \tmp}%
        \count255=\x@`\s@ffix
        \advance\count255 -64
        \temptrue
      \fi\fi
    \fi
  \iftemp\repeat
  \trace{dmc}{Last in #1 chain is \s@ffix, \the\count255}%
  \advance\count255 -1
  \edef\x@fch@r{\@Alph{\count255}}%
  \@new@followon{#1}{\s@ffix}% Sanity-check the suggestion. x@fch@r is passed implicitly 
} 
 
\def\@new@followon#1#2{% source, following-on. x@fch@r provides the character. Sanity check the suggestion.
  \trace{dmc}{@new@followon #1 #2 \x@fch@r}%
  %\tracingmacros=1 \tracingcommands=1 \tracingassigns=1
  \temptrue
  \ifcsname \x@fch@r isDiglotColumn\endcsname\tempfalse\fi
  \ifcsname f@llowing\x@fch@r\endcsname
    \def\tmp{#1}%
    \x@\let\x@\tmpb\csname f@llowing\x@fch@r\endcsname
    \ifx\tmp\tmpb %Chains don't go backwards, so this must be from an uncleared old chain. Reuse it
    \else
      \trace{dmc}{\x@fch@r\space is following \tmpb}% 
      \tempfalse
    \fi
  \fi
  \iftemp
    \trace{dmc}{Assigning \x@fch@r\space as the follow-on column to #2 (in the #1 chain)}%
    \ifcsname \x@fch@r box\endcsname\else
      \@newpolyglotboxes{\x@fch@r}%
    \fi
    \x@\xdef\csname f@llowing\x@fch@r\endcsname{#1}\x@\global\x@\let\csname \x@fch@r isFolowOn\endcsname\tr@e
    \x@\xdef\csname f@llow@n#2\endcsname{\x@fch@r}%
    \x@\xdef\csname f@llow@n\x@fch@r\endcsname{}%
    \global\f@llow@n=\count255
    \let\n@xt\sw@llowtwo
  \else
    \advance\count255 -1
    \edef\x@fch@r{\@Alph{\count255}}%
    \let\n@xt\@new@followon
  \fi
  \xdef\all@list{\all@list\x@fch@r}%
  \n@xt{#1}{#2}%
}
\def\cle@rf@llow@ns#1{
  \trace{dmc}{cle@rf@llow@ns #1}%
  %\tracingassigns=1
  \x@\let\x@\tmp\csname f@llow@n#1\endcsname
  \x@\let\csname f@llow@n#1\endcsname\empty
  \x@\global\x@\let\csname layout@#1\endcsname\empty
  \x@\global\x@\def\csname @max@cols@#1\endcsname{0}% Max columns #1 this is part of 
  \x@\global\x@\def\csname @firstpage@#1\endcsname{0}% First page #1 is on
  \x@\global\x@\def\csname @lastpage@#1\endcsname{0}% Last page #1 is on
  \x@\global\x@\let\csname f@llowing#1\endcsname\undefined
  \cle@rtmpnum{#1}%
  \ifx\relax\tmp\else \ifx\empty\tmp\else
    \x@\cle@rf@llow@ns\x@{\tmp}%
  \fi\fi
  \global\let\all@list\empty
  %\tracingassigns=0
}

\def\cle@rtmpnum#1{%
  \x@\global\x@\def\csname @tmpnum@#1\endcsname{0}%
  \x@\global\x@\def\csname pre@meas@#1@result\endcsname{0}%
}

\def\t@gpageinsertnames#1\E{%
  \x@\let\csname #1is@p@geins\endcsname\tr@e
  \mktmpinsdim@n{#1}%
}

\def\@mktmpinsdim@n#1\E{% Versiion for cstackdown, etc.
  \mktmpinsdim@n{#1}}
\def\mktmpinsdim@n#1{%Normal version
  \ifcsname #1ht\endcsname\else\relax
    \x@\newdim@n\csname #1ht\endcsname
  \fi
}

\def\@t@gcolinsertnames#1{%top and bottom column inserts...
  \@@t@gcolinsertnames{t#1}{#1}%
  \@@t@gcolinsertnames{b#1}{#1}%
}
  
\def\@@t@gcolinsertnames#1#2{%
  \edef\ins@name{\colinsert@name{#1}}%
  \trace{dmc}{defining \ins@name-col as #2}%
  \x@\xdef\csname \ins@name-col\endcsname{#2}%Map from column name to column, so we don't need to try to parse the name
}

\def\@@clsfynotes#1{%
  \@@g@tb@seline{\tmpn@te}{#1}\x@\edef\csname @n-\tmpn@te#1@bls\endcsname{\the\dimen0}%
}

\def\@@l@stcolonly#1{%
  \x@\ifx\csname lastcol\tmpa-\the\p@lyp@geno\endcsname\tmpb  % Is this the right column for #1 notes?
    \trace{dmc}{#1 applied for \tmpb/\csname lastcol\tmpa-\the\p@lyp@geno\endcsname}%
    \let\tgtc@l\tmpb
    \let\tmp@r\tr@e
  \else
    \trace{dmc}{#1 skipped \tmpb/\csname lastcol\tmpa-\the\p@lyp@geno\endcsname}%
  \fi
}

\def\@clsfynotes#1\E{%Classify footnote types: notes might be: in this box (or the final follow-on) 'n'ormal; shifted to an xrefs column, but overflowing to here 'x'ref, 
  %or affecting the whole page 'p'. There's also a category 'i'gnore, used for notes that don't get counted.
  \edef\tmpn@te{#1}%
  \ifdiglotSepNotes
    \def\tmp@n@tetyp{n}% Normal note- end of last column on page
  \else
    \def\tmp@n@tetyp{p}% Bottom of page
  \fi
  \ifx\tmp\XrefNotes\edef\tmp@n@tetyp{x}\fi%
  \ifcsname endn@te-#1\endcsname 
    \trace{dmc}{#1 is an endnote. Why is it appearing as an insert??}%Endnotes are fully expanded at the end of the book, so appear as normal text.
    \def\tmp@n@tetyp{i}%ignore
  \fi
  \x@\edef\csname @n-\tmpn@te @typ\endcsname{\tmp@n@tetyp}%
  \trace{dmc}{Recording @n-\tmpn@te @typ as \tmp@n@tetyp}%
  \let\col@do\@@clsfynotes \x@\each@col\all@list\E
}
\def\t@rgetcols{}
\def\polyglot@eachtime@setup@complexpages{%
  \trace{dmc}{polyglot@eachtime@setup@complexpages}%
  \ifx\t@rgetcols\empty\else
    \let\d@\und@fit
    \x@\cstackdown\t@rgetcols,\E
  \fi
  \ifx\diglot@list\empty\else
    \global\f@llow@n=0
    \let\col@do\cle@rf@llow@ns\x@\each@col\diglot@list\E% Stop all chains.
    %\let\col@do\local@split@defs\x@\each@col\diglot@list\E % Ensure that all columms have a block of dimensions.
    \let\d@\t@gpageinsertnames \x@\cstackdown\pageins@rts\E
    \let\d@\@mktmpinsdim@n \x@\cstackdown\columnins@rts\E
    \let\d@\@clsfynotes \x@\cstackdown\alln@tes,\E
  \fi
}

\def\reset@colindexes{%
  \ifx\diglot@list\empty\else
    \let\col@do\cle@rtmpnum\x@\each@col\all@list\E% reset column counts
  \fi
}

\newcount\p@lyr@wno
\def\inactive@col@code#1{\x@\let\csname in@ctive@col@#1\endcsname\tr@e}% Various 'column codes' are not connected to any input. Use ifcsname to check for them
\inactive@col@code{-} % A blank column or page
\inactive@col@code{=} % Lines
\inactive@col@code{+} % Footnote slot(s)
%\inactive@col@code{@} % Image / sidebar slot?? 

\def\col@active@count#1{\ifcsname in@ctive@col@#1\endcsname\else\advance\count255 by 1 \fi}% 
\def\@@complexr@vpolyp@ges#1{%
  %\trace{dmc}{  @@complexr@vpolyp@ges #1}%
  \count255=\csname @tmpnum@#1\endcsname
  \advance\count255 by 1
  \edef\@tmpnam{decode@#1\the\count255}%
  \x@\let\x@\x@fch@r\csname \@tmpnam\endcsname
  \trace{dmc}{... #1\the\count255 \space is \x@fch@r}%
  \xdef@cseq{@tmpnum@#1}{\the\count255}%
  \ifBookOpenLeft
    \xdef@cseq{p@lyp@gecols\p@lyp@gestring}{\x@fch@r\csname p@lyp@gecols\p@lyp@gestring\endcsname}%
  \else
    \xdef@cseq{revp@lyp@gecols\p@lyp@gestring}{\csname revp@lyp@gecols\p@lyp@gestring\endcsname\x@fch@r}%
  \fi
}
\def\@complexr@vpolyp@ges#1\E{%Row-of-columns processing
  \trace{dmc}{@complexr@vpolyp@ges #1, row=\the\p@lyr@wno}%
  \trace{dmc}{blank \ifBookOpenLeft rev\fi p@lyp@gecols\p@lyp@gestring}%
  \xdef@cseq{\ifBookOpenLeft \else rev\fi p@lyp@gecols\p@lyp@gestring}{}%
  \def\rev@tmp@list{}\def\list@type{tmp}%
  \let\col@do=\mkrev@list
  \edef\tmporder{#1}%
  \x@\each@col\tmporder\E
  \let\tmporder\rev@tmp@list
  \let\col@do\@@complexr@vpolyp@ges
  \trace{dmc}{@@complexr@vpolyp@ges \p@lyp@gestring {\tmporder}}%
  \x@\each@col\tmporder\E
  \ifBookOpenLeft
    \trace{dmc}{p@lyp@gecols\p@lyp@gestring\space is \csname p@lyp@gecols\p@lyp@gestring\endcsname}%
  \else
    \trace{dmc}{revp@lyp@gecols\p@lyp@gestring\space is \csname revp@lyp@gecols\p@lyp@gestring\endcsname}%
  \fi
  \advance\p@lyr@wno by 1 
}
\def\mkn@wht#1\E{\newdim@n#1}
\def\@complexs@tpolyp@ges#1\E{%Row-of-columns processing (#1 describes a user's view of a row)
  \trace{dmc}{@complexs@tpolyp@ges #1}%
  \edef\this@p@lyp@gestring{\p@lyp@gestring}% Expand once and cache
  \count255=0
  \let\col@do\col@count
  \x@\each@col#1\E
  \edef\@cspptotcols{\the\count255}%
  \count255=0
  \let\col@do\col@active@count
  \x@\each@col#1\E
  \edef\@csppactcols{\the\count255}%
  \trace{dmc}{blank \ifBookOpenLeft rev\fi p@lyp@gecols\this@p@lyp@gestring}%
  \xdef@cseq{\ifBookOpenLeft rev\fi p@lyp@gecols\this@p@lyp@gestring}{}%
  \x@\xdef\csname cols@\this@p@lyp@gestring\endcsname{\the\count255}% active cols in row p@lyp@gestring
  \ifcsname \this@p@lyp@gestring @ht\endcsname\else
    \edef\tmp{\this@p@lyp@gestring @ht}%
    \x@\mkn@wht\csname \tmp\endcsname\E % Height for this bit of page.
  \fi 
  \x@\x@\x@\def\x@\x@\x@\pg@hts\x@\x@\x@{\x@\pg@hts\x@+\x@\csname \this@p@lyp@gestring @ht\endcsname}%
  \edef\tmporder{#1}%
  \ifBookOpenLeft % In a book-open-left scenario, we need to process the page contents right-to-left. Easiest way to do that is reorder it from the start.
    \def\rev@tmp@list{}\def\list@type{tmp}%
    \let\col@do=\mkrev@list
    \x@\each@col\tmporder\E
    \let\tmporder\rev@tmp@list
  \fi
  \let\col@do\@@complexs@tpolyp@ges
  \x@\each@col\tmporder\E
  \ifBookOpenLeft
    \trace{dmc}{revp@lyp@gecols\this@p@lyp@gestring\space is \csname revp@lyp@gecols\this@p@lyp@gestring\endcsname}%
  \else
    \trace{dmc}{p@lyp@gecols\this@p@lyp@gestring\space is \csname p@lyp@gecols\this@p@lyp@gestring\endcsname}%
  \fi
  \x@\def\csname cts@\this@p@lyp@gestring\endcsname{#1}% What columns are in this row?
  \x@\xdef\x@\p@gestring\x@{\ifx\p@gestring\empty\else \p@gestring,\fi\this@p@lyp@gestring}% % What is the complete list of sections on this page?
  \global\advance\p@lyr@wno by 1
  \let\@cspptotcols\undefined
  \let\@csppactcols\undefined
}

\newdimen\t@stone
\newdimen\t@sttwo
\newdimen\t@sttri
\newdimen\t@stfou
\newdimen\t@stfiv
\def\m@xtwo#1#2#3{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \ifdim \t@stone> \t@sttwo \t@stone=\t@sttwo \fi#1=\t@stone}
\def\m@xthree#1#2#3#4{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi #1=\t@stone}
\def\m@xfour#1#2#3#4#5{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax \t@stfou=\dimexpr #5\relax 
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi\ifdim \t@stone< \t@stfou \t@stone=\t@stfou \fi#1=\t@stone}
\def\m@xfive#1#2#3#4#5#6{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax \t@stfou=\dimexpr #5\relax \t@stfiv=\dimexpr #6\relax
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi\ifdim \t@stone< \t@stfou \t@stone=\t@stfou \fi\ifdim \t@stone< \t@stfiv \t@stone=\t@stfiv \fi#1=\t@stone}

  
\def\@complexcheck@polyp@ges#1\E{%Check for Row-of-columns processing
  \edef\tmp{#1}%
  \edef\tmpnam{\checkmode p@lyp@gecols\p@lyp@gestring}%
  \edef\tmpval{\csname \tmpnam\endcsname}
  \trace{dmc}{\tmpval=\tmp ?}
  \ifx\tmpval\tmp
  \else
    \edef\checkreport{\checkreport\tmpnam\space does not agree (\tmpval!=#1) }%
  \fi
  \global\advance\p@lyr@wno by 1
}
\def\p@lyp@gestring{\the\p@lyp@geno-\the\p@lyr@wno}
\def\p@lyp@gesuffx{@poly@\p@lyp@gestring}
\def\p@rsep@gestring#1-#2\E{\trace{dmc}{p@pstr:#1-#2}\p@lyp@geno=#1 \p@lyr@wno=#2\relax}

\def\@@complexs@tpolyp@ges#1{%column processing
  \traceifset{@@cspp}%
  \trace{dmc}{@@cspp #1}%
  \ifcsname #1isDiglotColumn\endcsname
    \edef\x@fch@r{#1}% The expanded field char.
    \x@\let\x@\@@cspptmp\csname @max@cols@#1\endcsname
    %\trace{dmc}{#1 @@cspptmp \meaning\@@cspptmp}%
    %\ifx\@@cspptmp\z@ro \message{@@cspptmp is not zero}\fi
    \ifnum \@@cspptmp =0 % This must be the first occurance
      \ifnum\@csppactcols>1 \x@\let\csname layout@#1\endcsname\gr@dnormal % Normal 
      \x@\edef\csname @firstpage@#1\endcsname{\the\p@lyp@geno}%
      \x@\edef\csname @lastpage@#1\endcsname{\the\p@lyp@geno}%
      \else\x@\let\csname layout@#1\endcsname\gr@dnone \fi % No sync
      \xdef\all@list{\all@list#1}%Extend the list of all real & virtual columns.
    \else
      \new@followon{#1}%
      \x@\let\csname layout@#1\endcsname\gr@dnone % No sync
      \x@\edef\csname @lastpage@#1\endcsname{\the\p@lyp@geno}%
    \fi
    \ifnum\@@cspptmp <\@cspptotcols
      \x@\xdef\csname @max@cols@#1\endcsname{\@cspptotcols}%Used in determining the column width: Actual column widths get reduced by inter-column gaps, and so chunk that co-occurs in a tripple pane will be smaller than if it occured only in a double-pane. This is a pain.
    \fi
    %Needless? \x@\let\x@\@@cspptmp\csname @max@cols@#1\endcsname
    \ifBookOpenLeft
      \xdef@cseq{revp@lyp@gecols\p@lyp@gestring}{\x@fch@r\csname revp@lyp@gecols\p@lyp@gestring\endcsname}%
    \else
      \xdef@cseq{p@lyp@gecols\p@lyp@gestring}{\csname p@lyp@gecols\p@lyp@gestring\endcsname\x@fch@r}%
    \fi
    \count255=\csname @tmpnum@#1\endcsname
    \x@\xdef\csname lastcell#1-\the\p@lyp@geno\endcsname{\p@lyp@gestring} % Where do notes for L/R go on this page?
    \x@\xdef\csname lastcol#1-\the\p@lyp@geno\endcsname{\x@fch@r} % Where do notes for L/R go on this page?
    %\trace{dmc}{lastcol#1-\the\p@lyp@geno\space is \x@fch@r}%
    \x@\xdef\csname thep@geno\x@fch@r\endcsname{\the\p@lyp@geno}%
    \advance\count255 by 1
    \edef\@tmpnam{decode@#1\the\count255}%
    \trace{dmc}{... #1\the\count255\space -> \x@fch@r}%
    \x@\xdef\csname \@tmpnam\endcsname{\x@fch@r}% L0->Z (etc) mapping, needed for reverse-order version
    \xdef@cseq{@tmpnum@#1}{\the\count255}%
  \else 
    \ifcsname inactive@col@code#1\endcsname\else
      \errmessage{!!! #1 is neither an inactive column code nor a diglot(polyglot) column. Define it first.}%
      \error%Force stop
    \fi
  \fi
  \traceifcheck{@@cspp}%
}
\def\checkpolypages{%
  \edef\sl@shcode{\the\catcode47}%
  \catcode47=\tw@lve\relax
  \@checkpolypages
}
\def\@checkpolypages#1#2{% Testing code - check the calculated result agrees with the known result
  \p@lyp@geno=0
  \def\checkreport{}%
  \let\d@\complexcheck@polyp@ges
  \edef\checkmode{}%
  \edef\checknormal{#1}%
  \edef\checkrev{#2}%
  \x@\cstackdown\checknormal,\E
  \p@lyp@geno=0
  \edef\checkmode{rev}
  \x@\cstackdown\checkrev,\E
  \ifx\checkreport\empty\else
    \errmessage{\checkreport}%
  \fi
  \catcode47=\sl@shcode\relax
}


\def\polyglotpages@complexpages#1{%comma separated list of concatenated columns to put on different pages and rows (e.g. AR/A,B/C) specifies 2 pages, pg1 shows L, R and A, pg2 B and C.
  \trace{dmc}{polyglotpages #1}%
  %\tracingcommands=1 \tracingmacros=1 \tracingassigns=1
  \polyglot@onetime@setup
  \polyglot@eachtime@setup@complexpages
  \p@lyp@geno=0 
  \edef\tmp{#1}%
  \ifx\tmp\empty\errmessage{polyglotpages called with empty argument. That's an error}\fi
  \E\E
  \def\p@gestrings{}%
  \let\d@=\complexs@tpolyp@ges
  \cstackdown#1,\E
  \reset@colindexes
  \p@lyp@geno=0
  \let\d@=\complexr@vpolyp@ges
  \cstackup#1,\E
  \trace{dmc}{Page string list is:\p@gestrings}%
  \def\tmp{0-0}%Just one column? that's simplecols
  \ifx\p@gestrings\tmp
    \edef\diglotlayout{simplecols}
  \else %Anything else is considered a complex page. complexpages doesn't sync page-to-page, while simplepages does.
    \edef\diglotlayout{complexpages}
  \fi
  % Restore catcodes
  \catcode47=\sl@shcode\relax 
  \catcode`\-=\d@shcode\relax
  \let\col@do\@t@gcolinsertnames \x@\each@col\all@list\E
}

\def\polyglotpages{% Just in case, switch some catcodes.
  \edef\sl@shcode{\the\catcode47}%
  \edef\d@shcode{\the\catcode`\-}%
  \catcode47=\tw@lve % /
  \catcode`\-=\tw@lve \relax % -
  \polyglotpages@complexpages
}

\def\set@col@widths@complexpages{%
  \trace{d}{set@col@widths@complexpages}%
  \def\col@do##1{%
    \ifcsname inactive@col@code##1\endcsname\else
      \dimen0=\textwidth
      \count255=\csname @max@cols@##1\endcsname
      \advance\dimen0 by -\numexpr \count255 - 1\relax\gutter \relax\advance\dimen0 by -\count255\columnshift\relax
      \csname column##1width\endcsname=\csname Diglot##1Fraction\endcsname\dimen0
      \trace{dmc}{Set column width for ##1 to be \the\csname column##1width\endcsname}%
    \fi
  }%
  \x@\each@col\diglot@list\E
}

\def\MaxComplexLines{1000} % Should be enough for any set of pages, surely?

\newcount\@@m@one \@@m@one=-1
\newcount\@@zero \@@zero=0
%\def\seta#1#2{\def\tmp##1#1=(##2)##3\E{\edef\STOREa{##1#1=(#2)##3}}\x@\tmp\STOREa\E}
\def\local@split@defs#1#2{% #1=L/R/A, etc. #2=lines. This allocates and clears
  % blocks of dims/counts ready for use. It also sets the shortcuts to the specified
  % column, saving a few cycles. The  number parameter specifies how many rows actually 
  % need clearing, providing a speed-up.
  \def\STOREa{)}%
  \def\STOREb{)}%
  \def\STOREc{)}%
  \ifcsname split@defs@#1\endcsname
    \count255=\csname split@defs@#1\endcsname
    \ifnum\count255<#2 \count255=#2 \advance\count255 by 1 \fi
  \else
    \count255=#2
    \advance\count255 by 1 
  \fi
  \ifnum \count255 >\MaxComplexLines 
    \def\MaxComplexLines{\the\count255}
    \message{#1 has \the\numexpr #2\relax lines. That's more than the code expected. Ideally, alter \MaxComplexLines.}%
    % FIXME if this is the only place they're used, we should deallocate/move the old blocks. Otherwise ensure they're only local definitions.
    % Current bodge is to just reallocate.
    \x@\let\csname split@heights#1\endcsname\undefined
  \fi  
  \x@\edef\csname split@defs@#1\endcsname{\the\count255}%
  \ifcsname split@heights#1\endcsname\else
    \x@\locdimenblk\csname @@@split@heights#1\endcsname{\MaxComplexLines}
    \x@\locdimenblk\csname @@@split@insheights#1\endcsname{\MaxComplexLines}
    \x@\loccountblk\csname @@@split@vrs#1\endcsname{\MaxComplexLines}
    \x@\def\csname split@heights#1\endcsname##1{\x@\dimen\x@\numexpr \csname @@@split@heights#1\endcsname+##1\relax}
    \x@\def\csname split@insheights#1\endcsname##1{\x@\dimen\numexpr \csname @@@split@insheights#1\endcsname+##1\relax}
    \x@\def\csname split@vrs#1\endcsname##1{\x@\count\numexpr \csname @@@split@vrs#1\endcsname+##1\relax}
  \fi
  \x@\let\x@\split@vrs\csname split@vrs#1\endcsname
  \x@\let\x@\split@heights\csname split@heights#1\endcsname
  \x@\let\x@\split@insheights\csname split@insheights#1\endcsname
  \dimen1=-1sp
  \tracetimset{local@split@defs}%
  \advance \count255 by \@@m@one
  \loop
    \split@insheights{\count255}=\dimen1
    \split@heights{\count255}=\dimen1
    \split@vrs{\count255}=\@@m@one
    \advance\count255 by \@@m@one \ifnum\count255>\@@zero \repeat
  \tracetimcheck{local@split@defs}{#1 \csname split@defs@#1\endcsname}%
}

\def\@@cplx@measure#1\E{%Measure the current row height of the row #1 
  \let\col@do\max@boxsz\def\v@lpfx{}\def\v@lsfx{box}\dimen1=0pt
  \x@\let\x@\tmp\csname cts@#1\endcsname
  \x@\each@col\tmp\E
  \csname #1@ht\endcsname=\dimen1
  \advance\dimen0 by \dimen1
}
\def\@cplx@measure{%Measure the current page sizes of the assigned chunks
  \dimen0=0pt
  \let\d@\@@cplx@measure
  \x@\cstackdown\p@gestrings,\E
}



\def\complex@ssplit#1{% Slow, but reliable.
  \bgroup % Keep redefinitions local
    \ins@meas@trialfullfalse
    \ins@meas@trialnofulltrue
    \vfuzz=\maxdimen
      \setbox0\copy\csname #1box\endcsname%
    \dimen1=\ht0
    \dimen2=0pt
    \dimen3=0pt
    \nsplit=\dimexpr \dimen1 / \baselineskip\relax
    %\message{#1 has \the\nsplit\space lines}
    \local@split@defs{#1}{\nsplit}%
    \count255=1
    \loop
      \setbox0\copy\csname #1box\endcsname%
      \setbox1\vsplit 0 to \count255\baselineskip  
      %\ifnum\count255=1 \showbox1\fi
      \me@sureins@trial{#1}{1}%
      %\advance\dimen3 by \ht1
      %\advance\dimen2 by \ins@meas@trial@result
      \x@\global\csname split@insheights#1\endcsname{\count255}=\ins@meas@trial@result
      \x@\global\csname split@heights#1\endcsname{\count255}=\ht1
      %\xdef\ssr@sult{\ssr@sult \space \the\count255 (\the\csname split@heights#1\endcsname{\count255}): \the\csname split@insheights#1\endcsname{\count255}}%
      \xdef\ssr@sult{\ssr@sult \space \the\count255: \the\csname split@insheights#1\endcsname{\count255}}%
      \advance \count255 by 1
    \unless\ifnum\count255>\nsplit \repeat
    %\tracetimset{xp}%
    %\x@\def\x@\ssr@sult\x@{%
      %\loop\advance\count255 -1
        %.\space \the\count255 (\x@\the\csname height#1\endcsname{\count255}): \the\csname split@insheights#1\endcsname{\count255} %
      %\ifnum\count255>0 \repeat}
    %%\tracetimcheck{xp}{Reporting}%
  \egroup
}
  
\def\complex@rsplit#1{%Recursive version (faster if notes/inserts are sparse)
  \vfuzz=\maxdimen
  \setbox0\copy\csname #1box\endcsname%
  \dimen1=\ht0
  \nsplit=\dimexpr \dimen1 / \baselineskip\relax
  \local@split@defs{#1}{\nsplit}% Generate (if needed) and flag as unused values. Also sets \split@insheights etc.  
  \bgroup
    \ins@meas@trialfullfalse
    \ins@meas@trialnofulltrue
    \@complex@rsplit{#1}{\the\nsplit}{0}{0}{-1sp}%
  \egroup
  \loop
    \advance\count255 by 1
    %\message{insheights#1{\the\count255}=\the\csname split@insheights#1\endcsname{\count255}}%
  \ifnum\count255<\nsplit \repeat
}
\newbox\tmpb@x
\def\@complex@rsplit#1#2#3#4#5{%
  \edef\ncv@lb{#5}%
  \setbox\tmpb@x\copy#4
  \count255=#2\relax
  \advance\count255 by -#3%
  \divide\count255 by 2
  \ifnum \count255>0
    \edef\@sp{\the\count255}%
    %\tracingassigns=1
    \edef\@npb{\the\numexpr #2 \relax}%
    \edef\@np{\the\numexpr #3+\count255 \relax}%
    \trace{dmc}{rsplit #1 #2 #3 #4 #5(\@np, \@npb) (\the\ht#4)}%
    %\tracingassigns=0 \relax
    \setbox 0\box\tmpb@x
    %\ifx\@sp\@ne \showbox 0 \fi
    \setbox1=\vsplit 0 to \@sp\baselineskip
    \setbox1\vbox{\unvbox1}%
    %\trace{dmc}{split into \@sp results in \number\dimexpr\ht1/\baselineskip\relax / \number\dimexpr \ht0/\baselineskip\relax}%
    \edef\tmpa{\x@\the\split@insheights{\@np}}%
    \ifdim\tmpa =-1sp
      \me@sureins@trial{#1}{1}%
      \let\tmpa\ins@meas@trial@result
      \ifnum #3=0 
        %\trace{dmc}{\@np -> \tmpa}%
        \global\split@insheights{\@np}=\tmpa
      \else
        \edef\lval{\the\split@insheights{#3}}%
        \ifdim\lval=-1sp\else
          %\trace{dmc}{** \@np -> \tmpa+\lval}%
          \x@\global\split@insheights{\@np}=\dimexpr\tmpa+\lval\relax
        \fi
      \fi
      %\trace{dmc}{rsplit - \tmpa\space between #3 and \@np}%
    \else
      %\trace{dmc}{- No measuring needed for \@np ??}%
    \fi
    \ifnum\@npb <\nsplit 
      %\edef\ncv@l{\the\csname split@insheights#1\endcsname{\@npb+1}}% set the no change value
    \else
      \edef\@npb{\the\nsplit}%
      \edef\ncv@lb{\the\split@insheights{\nsplit}} %set the no change value
    \fi
    \dimen0=\split@insheights{\@npb}%
    \ifdim \dimen0=-1sp
      \me@sureins@trial{#1}{0}%
      \let\tmpb\ins@meas@trial@result
      %\trace{dmc}{rsplit + \tmpb\space between \@np and \@npb}%
      \ifdim\ncv@lb=-1sp
        \edef\ncv@lb{\the\dimexpr \tmpa+\tmpb\relax}%
        %\message{\@npb -> \tmpb+\tmpa =\ncv@lb}%
        \x@\global\split@insheights{\@npb}=\ncv@lb
      \fi
    \else
      \edef\tmpb{\the\dimexpr#5-\dimen0 \relax}%
      %\trace{dmc}{+ No measuring needed for \@np-\@npb: calculated \tmpb}%
    \fi
    \let\ncv@l\ncv@lb
    % process the tail first.
    \ifdim\tmpb=0pt
     % \ifdim #5=-1sp \def\ncv@lb{0pt}\fi% Only occurs at the 1st call, so if there's nothing, then there's nothing in the upper half.
      \count255=\@npb
      %\trace{dmc}{rsplit + no change between \@np and \@npb: \ncv@lb}%
      \loop 
        %\message{\the\count255 -> \ncv@lb}%
        \x@\global\split@insheights{\count255}=\ncv@lb
        \advance\count255 -1
        \ifnum\count255>\@np 
      \repeat
    \else
      %\trace{dmc}{rsplit + \tmpb\space between \@np and \@npb}%
      \edef\ncv@l{\the\dimexpr \ncv@lb-\tmpb\relax}%
    \fi
    \ifdim \tmpa=0pt
      %\trace{dmc}{rsplit - no change between #3 and \@np: \ncv@l }%
      \count255=\@np
      \loop 
        \ifdim \split@insheights{\count255}=-1sp
          \x@\global\split@insheights{\count255}=\ncv@l
          %\message{\the\count255 -> \ncv@l}%
        \fi
        \advance\count255 -1
      \ifnum \count255>#3 \repeat
    \else\bgroup
      \edef\@rgs{{#1}{\@np}{#3}{1}{\ncv@l}}%
      \x@\@complex@rsplit\@rgs
    \egroup\fi
    \ifdim\tmpb=0pt\else\bgroup
      \edef\@rgs{{#1}{\@npb}{\@np}{0}{\ncv@lb}}%
      \x@\@complex@rsplit\@rgs
    \egroup\fi
  \fi  
}
\def\complex@split#1{%
  \ifdim\ht\csname #1box\endcsname > 10\baselineskip % Arbitray value needs firming up
    \complex@rsplit{#1}%
  \else
    \complex@ssplit{#1}%
  \fi
}

\def\@prepare@layout@complexpages{%
  \trace{d}{@prepare@layout@complexpages \l@gdims{\partial} \ifdiglotb@dy body\else intro\fi}%
  \@prepare@layout@simplecols 
}

\def\cplx@pre@me@sureins@trial#1{%
  \me@sureins@trial{#1}{\csname excess#1\endcsname}%
  \x@\let\csname pre@meas@#1@result\endcsname\ins@meas@trial@result
  \x@\let\csname pre@meas@#1@dims\endcsname\ins@meas@trial@dims
  \ifx\ins@meas@trial@dims\empty\else\let\inserts@npage\tr@e\fi %Notice that there are inserts.
}
\newdimen\tmpdim
\def\g@ncolhtfunctions#1{
  \edef\tmp{\tmpdim=\dimexpr \ht\csname #1box\endcsname+\dp\csname #1box\endcsname \relax }%
  \x@\fntoks\x@{\tmp}%
  \add@tr@iling{#1}%
  \x@\def\csname tmp#1htfn\x@\x@\x@\endcsname\x@\x@\x@{\x@\the\x@\fntoks\x@\edef\csname tmp#1ht\endcsname{\the\tmpdim}}%
  \trace{dmc}{tmp#1htfn defined as \x@\meaning\csname tmp#1htfn\endcsname}%
}
\def\us@tmphtfn#1{\x@\let\x@\tmp\csname tmp#1htfn\endcsname\x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
}
\def\add@tr@iling#1{%add tr@ling#1 to definintion of \tmp
  \trace{dmc}{Adding trailing#1 to fntoks}%
  \x@\ifx\csname tr@iling#1\endcsname\relax\else
    \x@\ifx\csname tr@iling#1\endcsname\empty\else
      \x@\let\x@\tmpb\csname tr@iling#1\endcsname
      \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmpb}%
    \fi
  \fi
  \trace{dmc}{currently: \the\fntoks}%
}

\def\g@nchunkhtfunctions#1#2\E{%generate an optimised chunk height macro (max(#1,...) for all cols in a row
  \let\gchd@\d@
  \relax\trace{dmc}{g@nchunkhtfunction #1#2}%
  \x@\let\x@\p@gehtcalcs\csname p@gehtcalcs-\the\p@lyp@geno\endcsname% Updating is easier without the csname mess
  \ifx\p@gehtcalcs\relax \let\p@gehtcalcs\empty\fi
  \trace{dmc}{resetting fntoks}%
  \fntoks{}%
  \let\col@do\us@tmphtfn \x@\each@col#1#2\E
  \x@\let\csname tmp#1ht\endcsname\relax
  \def\tmpb{#2}%
  \ifx\tmpb\empty
    \edef\tmp{\csname \p@lyp@gestring @ht\endcsname=\tmpdim}%
    \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
  \else %Extend the function
    \edef\tmp{\csname \p@lyp@gestring @ht\endcsname=\csname tmp#1ht\endcsname\relax}%
    \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
    \trace{dmc}{fntoks(\p@lyp@gestring):\the\fntoks}%{
    \let\col@do\@genhtfunction
    \x@\each@col#2\E
  \fi
  \trace{dmc}{htfunction-\p@lyp@gestring:\the\fntoks}%
  \x@\def\csname htfunction-\p@lyp@gestring\x@\endcsname\x@{\the\fntoks}%
  \x@\def\csname p@gehtcalcs\x@\x@\x@\endcsname\x@\x@\x@{\x@\p@gehtcalcs\csname htfunction-\p@lyp@gestring\endcsname}
  \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\p@gehtcalcs\relax % Save the possibly-updated version
  \relax
  \let\d@\gchd@
}

\def\@genhtfunction#1{%
  \trace{dmc}{@genhtfunction #1}%
  \x@\let\csname tmp#1ht\endcsname\relax
  \edef\tmp{\dimen0=\csname tmp#1ht\endcsname\relax}%
  \x@\expandfntoksgt\x@{\csname \p@lyp@gestring @ht\endcsname}%
  %\trace{dmc}{@ghf->\the\fntoks}%
}
\def\expandfntoksgt#1{%
  \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp \ifdim\dimen0>#1 #1=\dimen0 \fi}%
}
\newdimen\thisp@gehtloss

\def\mk@chunktr@iling#1:#2\E{%Generate *optimised* height based on each insert actually used. Note that #1 might be a figure insert or some class of footnote. 
  \x@\let\x@\typ@\csname @n-#1@typ\endcsname
  \edef\active@inserts{#1,\active@inserts}%
  \ifx\m@ltip@ge\tr@e
    \x@\let\x@\tmp\csname perpg@inserts\the\p@lyp@geno\endcsname
    \ifx\tmp\relax\let\tmp\empty\fi
    \x@\edef\csname perpg@inserts\the\p@lyp@geno\endcsname{#1,\tmp}%These inserts are shared between multiple pages, and will need resetting between pages.
  \fi
  \let\tmp@r\false % Do we record this chunk?
  \ifx\typ@\relax \def\typ@{I}%Insert 
    \ifcsname #1is@p@geins\endcsname  \def\typ{p}\fi%
    \let\tmp@r\tr@e
  \fi
  \trace{dmc}{mk@chunktr@iling #1:#2 (\typ@)}%
  \if p\typ@\relax 
      \x@\def\x@\p@gehtcalcs\x@{\p@gehtcalcs\dimen0=\csname #1ht\endcsname \ifdim \dimen0>0pt \advance\thisp@gehtloss \dimexpr \dimen0+\dimen\csname #1\endcsname\relax\fi }% FIXME:(?) Do we get duplicates?? If so, then the calc should probably be built separately, and elsewhere, or use t@rgetcols-type testing.
  \else
    \if n\typ@\relax
      \@@l@stcolonly{#1}%
    \else
      \if x\typ@\relax
        \@@l@stcolonly{#1}%
      \fi %Other 
    \fi
    \if \tmp@r\tr@e\relax
      \if I\typ@
        \x@\let\x@\tgtc@l\csname #1-col\endcsname %Find what the target column is, or if it's for here-top/bottom
        \ifx\tgtc@l\relax\let\tgtc@l\col@tmp\message{Could not identify column for insert #1 (#1-col), defaulting to \col@tmp}\fi%
      \fi
      \ifcsname \tgtc@l-col-#1\endcsname
        \trace{dmc}{insert #1 (total #2) already accounted for in column \tgtc@l}%
      \else
        \trace{dmc}{insert #1 (total #2) will show in column \tgtc@l}%
        \xdef\t@rgetcols{\t@rgetcols\tgtc@l-col-#1,}% Keep a list
        \x@\let\csname \tgtc@l-col-#1\endcsname\relax
        \x@\let\x@\tmpf\csname tr@iling\tgtc@l\endcsname
        \ifx\tmpf\relax\let\tmpf\empty\fi
        \edef\btmp{\dimen1=\csname #1ht\endcsname}%What's the insert height?
        \x@\extendchunkc@lc\x@{\x@\dimen\csname #1\endcsname}% Save some cycles overall by expanding the extra csname once-for-many, here (extends tmpf)
        \x@\let\csname tr@iling\tgtc@l\endcsname\tmpf
      \fi
    \fi
  \fi
}

\def\extendchunkc@lc#1{%
  \x@\x@\x@\def\x@\x@\x@\tmpf\x@\x@\x@{\x@\tmpf \btmp \ifdim\dimen1>0pt \advance\tmpdim\dimexpr \dimen1+#1\relax\fi}%
}

\def\g@ncolhtadditions#1{%define any (potential) extra column height for column #1 
  \def\col@tmp{#1}\def\tmpa{#1}\edef\tmpb{#1}%
  \trace{dmc}{g@ncolhtadditions #1}%
  \let\m@ltip@ge\false
  \x@\ifx\csname #1isFolowOn\endcsname\tr@e \x@\let\x@\tmpa\csname f@llowing#1\endcsname\fi
  \p@lyp@geno=\csname thep@geno#1\endcsname
  \x@\let\x@\p@gehtcalcs\csname p@gehtcalcs-\the\p@lyp@geno\endcsname% Updating is easier without the csname mess
  \x@\ifx\csname pre@meas@\tmpa @dims\endcsname\empty
    \trace{dmc}{#1 empty}%
  \else
    \x@\ifx\csname @firstpage@\tmpa\x@\endcsname\csname @lastpage@\tmpa\endcsname\else
      \let\m@ltip@ge\tr@e
    \fi
    \trace{dmc}{#1 (\tmpa) -> \csname pre@meas@\tmpa @dims\endcsname}%
    \let\d@\mk@chunktr@iling % May alter: tr@ling[any], p@gehtcalcs, perpg@inserts
    \x@\x@\x@\cstackdown\csname pre@meas@\tmpa @dims\endcsname,\E
    \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\x@\p@gehtcalcs
  \fi
}
\x@\newdimen\csname p@geloss-0\endcsname
\x@\newdimen\csname p@geloss-1\endcsname

\def\diglot@run@trials@complexpages{% This receives control after all columns are gathered.
  %As columns are gathered via the output routine, by definition the currentpage must be empty
  %Material to typeset is in excessX and wholeX (intially equal in content)
  \trace{dmc}{Running trials for active content:\digl@tc@ntentlist}% 
  \let\inserts@npage\false
  \let\active@inserts\empty
  \let\col@do\cplx@pre@me@sureins@trial
  \ins@meas@trialnofullfalse \ins@meas@trialfullfalse
  \x@\each@col\digl@tc@ntentlist\E
  \trace{dmc}{Done. Resetting calcs (\inserts@npage)}% 
  % 2.using the page structure, define code to measure the (potentially) active bits of the layout (i.e, if there's no figures or column notes, then don't bother with column-note calcs), one-per-defined page. 
  \ifx\inserts@npage\tr@e
    \p@lyp@geno=0 \loop
      \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\empty
      \csname p@gehtloss-\the\p@lyp@geno\endcsname=0pt
      \x@\let\csname perpg@inserts-\the\p@lyp@geno\endcsname\empty
      \advance\p@lyp@geno by 1 \ifnum\p@lyp@geno<\p@lyp@ges \repeat
    % As some users will probably be confused if they can't put figures into wherever column, triggered in whatever column they feel like
    % so there needs to to be a 3 step process: (a) allocate figure heights, etc, to whatever column.
    % (b) define tmpLht, etc as the sum of the column and inserts for a given chunk, also building a list of page-dependant inserts.
    % (c) build the column functions (calculating and referencing tstLht and friends)
    \let\col@do\g@ncolhtadditions 
    \x@\each@col\all@list\E % step (a)
    \let\col@do\g@ncolhtfunctions 
    \x@\each@col\all@list\E % step (b)
    \let\d@\polyp@gestack 
    \let\pd@\g@nchunkhtfunctions
    \x@\cstackdown\p@gestrings,\E %step(c)
  \fi
  \trace{dmc}{Page height calcs(last page):\meaning\p@gehtcalcs}%
}
\newtoks\fntoks

%%%%%%%%%%%%%% Generic 'do everything to everyrow function

\def\polyp@gestackec#1\E{%Gets an element of the page-strings list (page-row) and run each@col on it.
  \x@\p@rsep@gestring #1\E
  \x@\x@\x@\each@col\csname p@lyp@gecols#1\endcsname\E
}%

\def\polyp@gestack#1\E{%Gets an element of the page-strings list (page-row) and run each@col on it.
  \x@\p@rsep@gestring #1\E
  \x@\x@\x@\pd@\csname p@lyp@gecols#1\endcsname\E
}%

%%%%%%%%%%%%%%%%%%%%%%%%% code that needs slash to not be active.  
\catcode47=\tw@lve
  % Slash-separated stack, works roughly like comma-separated stack, but with slashes instead of commas, and the slash-stack uses \d@@
  \def\sstackup#1/#2\E{\edef\sstack@tmp{#2}\ifx\sstack@tmp\empty\let\n@x=\sstackrelax\else\let\n@x=\sstackup\fi\n@x #2\E\edef\sstack@tmp{#1}\ifx\sstack@tmp\empty\else\d@@ #1\E\fi}                  %(1)
  \def\sstackdown#1/#2\E{\edef\sstack@tmp{#1}\ifx\sstack@tmp\empty\else\d@@ #1\E\fi\edef\sstack@tmp{#2}\ifx\sstack@tmp\empty\let\n@x=\sstackrelax\else\let\n@x=\sstackdown\fi\n@x #2\E}
  \def\sstackrelax#1\E{}
    
  \def\complexs@tpolyp@ges#1\E{%page processing (#1 is a page
    \p@lyr@wno=0
    \def\p@gestring{}%
    \x@\let\csname ins@rts-\the\p@lyp@geno\endcsname\relax
    \edef\pg@hts{\csname ins@rts-\the\p@lyp@geno\endcsname}%
    \let\d@@\@complexs@tpolyp@ges
    \x@\sstackdown#1/\E
    \x@\xdef\csname p@lyr@wcount-\the\p@lyp@geno\endcsname{\the\p@lyr@wno}% Rows on this page
    \x@\xdef\csname p@lypgcts-\the\p@lyp@geno\endcsname{\p@gestring}% Contents of this page (in terms of page-row)
    \x@\gdef\csname p@lypght-\the\p@lyp@geno\x@\endcsname{\x@\dimexpr\pg@hts\relax}%
    \x@\xdef\x@\p@gestrings\x@{\ifx\p@gestrings\empty\else \p@gestrings,\fi\p@gestring}% % What is the complete list of sections (in terms of page-row)?
  \trace{dmc}{page \the\p@lyp@geno \space height is \csname p@lypght-\the\p@lyp@geno\endcsname}%
    \global\advance\p@lyp@geno by 1\relax
    \xdef\p@lyp@ges{\p@lyp@geno}%
  }
  \def\complexr@vpolyp@ges#1\E{%reverse processing. There may be repeated columns, and 'reversed column order' doesn't affect reading order. Thus it does not equate to an inversion (LLR becomes LZR forward and  RLZ when reversed.)
    \p@lyr@wno=0
    \let\d@@=\@complexr@vpolyp@ges % Do the mirrored-version
    \x@\sstackdown#1/\E
    \global\advance\p@lyp@geno by 1
  }
  \def\complexcheck@polyp@ges#1\E{
    \p@lyr@wno=0
    \let\d@@\@complexcheck@polyp@ges
    \x@\sstackdown#1/\E
    \global\advance\p@lyp@geno by 1
  }
    
\catcode47=\active
%%%%%%%%%%%%%%%%%%%%%%%%%

 
\plugin@endif
