%:strip
% polyglot-complexpages.tex: multi-page polyglot processing for xetex paratext2.tex
% Copyright (c) 2025 by SIL International 
% written by David Gardner
% 
% This optional plugin (see ptx-plugins) extends the basic diglot engine to
% provide complex, multipage polyglot options. There is no synchronisation across pages.
%
% Permission is hereby granted, free of charge, to any person obtaining
% a copy of this software and associated documentation files (the  
% "Software"), to deal in the Software without restriction, including  
% without limitation the rights to use, copy, modify, merge, publish,  
% distribute, sublicense, and/or sell copies of the Software, and to  
% permit persons to whom the Software is furnished to do so, subject to  
% the following conditions:
%
% The above copyright notice and this permission notice shall be  
% included in all copies or substantial portions of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  
% EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  
% MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  
% NONINFRINGEMENT. IN NO EVENT SHALL SIL INTERNATIONAL BE LIABLE FOR  
% ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF  
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  
% WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
%
% Except as contained in this notice, the name of SIL International  
% shall not be used in advertising or otherwise to promote the sale,  
% use or other dealings in this Software without prior written  
% authorization from SIL International.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\plugin@startif{polyglot-complexpages}
\plugins@needed{polyglot-simplepages} % 
\newcount\f@llow@n % Global register of 'invented' columns

\def\new@followon#1{%
  \ifnum\f@llow@n=0
    \global\f@llow@n=`Z
    \global\advance\f@llow@n -63 % We know it'll be reduced by 1 later on...
  \fi
  \count255=\f@llow@n
  \edef\s@ffix{#1}%
  \loop% Get to the last f@llow@n of the parent
    \tempfalse\ifcsname f@llow@n\s@ffix\endcsname
      \x@\let\x@\tmp\csname f@llow@n\s@ffix\endcsname\ifx\tmp\undefined\else\ifx\tmp\empty\else
        \let\s@ffix\tmp
        %\trace{dmc}{tmp is \tmp}%
        \count255=\x@`\s@ffix
        \advance\count255 -64
        \temptrue
      \fi\fi
    \fi
  \iftemp\repeat
  \trace{dmc}{Last in #1 chain is \s@ffix, \the\count255}%
  \advance\count255 -1
  \edef\x@fch@r{\@Alph{\count255}}%
  \@new@followon{#1}{\s@ffix}% Sanity-check the suggestion. x@fch@r is passed implicitly 
} 
 
\def\@new@followon#1#2{% source, following-on. x@fch@r provides the character. Sanity check the suggestion.
  \trace{dmc}{@new@followon #1 #2 \x@fch@r}%
  \temptrue
  \ifcsname \x@fch@r isDiglotColumn\endcsname\tempfalse\fi
  \ifcsname f@llowing\x@fch@r\endcsname
    \def\tmp{#1}%
    \x@\let\x@\tmpb\csname f@llowing\x@fch@r\endcsname
    \ifx\tmp\tmpb %Chains don't go backwards, so this must be from an uncleared old chain. Reuse it
    \else
      \trace{dmc}{\x@fch@r\space is following \tmpb}% 
      \tempfalse
    \fi
  \fi
  \iftemp
    \trace{dmc}{Assigning \x@fch@r\space as the follow-on column to #2 (in the #1 chain)}%
    \ifcsname \x@fch@r box\endcsname\else
      \@newpolyglotboxes{\x@fch@r}%
      \x@\newc@unt\csname f@llowOfs\x@fch@r\endcsname % where does the split start?
    \fi
    \x@\xdef\csname f@llowing\x@fch@r\endcsname{#1}\x@\global\x@\let\csname \x@fch@r isFolowOn\endcsname\tr@e
    \x@\xdef\csname f@llow@n#2\endcsname{\x@fch@r}%
    \x@\xdef\csname f@llow@n\x@fch@r\endcsname{}%
    \global\f@llow@n=\count255
    \let\n@xt\sw@llowtwo
  \else
    \advance\count255 -1
    \edef\x@fch@r{\@Alph{\count255}}%
    \let\n@xt\@new@followon
  \fi
  \ifcsname \x@fch@r test\endcsname\else
    \x@\mkn@wht\csname \x@fch@r test\endcsname\E
  \fi
  \xdef\all@list{\all@list\x@fch@r}%
  \n@xt{#1}{#2}%
}
\def\cle@rf@llow@ns#1{%
  \trace{dmc}{cle@rf@llow@ns #1}%
  \x@\let\x@\tmp\csname f@llow@n#1\endcsname
  \x@\let\csname f@llow@n#1\endcsname\empty
  \x@\global\x@\let\csname layout@#1\endcsname\empty
  \x@\global\x@\def\csname @max@cols@#1\endcsname{0}% Max columns #1 this is part of 
  \x@\global\x@\def\csname @firstpage@#1\endcsname{0}% First page #1 is on
  \x@\global\x@\def\csname @lastpage@#1\endcsname{0}% Last page #1 is on
  \x@\global\x@\let\csname f@llowing#1\endcsname\undefined
  \cle@rtmpnum{#1}%
  \ifx\relax\tmp\else \ifx\empty\tmp\else
    \x@\cle@rf@llow@ns\x@{\tmp}%
  \fi\fi
  \global\let\all@list\empty
}

\def\cle@rtmpnum#1{%
  \x@\global\x@\def\csname @tmpnum@#1\endcsname{0}%
  \x@\global\x@\def\csname pre@meas@#1@result\endcsname{0}%
}

\def\t@gpageinsertnames#1\E{%
  \x@\let\csname #1is@p@geins\endcsname\tr@e
  \mktmpinsdim@n{#1}%
}

\def\@mktmpinsdim@n#1\E{% Versiion for cstackdown, etc.
  \mktmpinsdim@n{#1}}
\def\mktmpinsdim@n#1{%Normal version
  \ifcsname #1ht\endcsname\else\relax
    \x@\newdim@n\csname #1ht\endcsname
  \fi
}

\def\@t@gcolinsertnames#1{%top and bottom column inserts...
  \@@t@gcolinsertnames{t#1}{#1}%
  \@@t@gcolinsertnames{b#1}{#1}%
}
  
\def\@@t@gcolinsertnames#1#2{%
  \edef\ins@name{\colinsert@name{#1}}%
  \trace{dmc}{defining \ins@name-col as #2}%
  \x@\xdef\csname \ins@name-col\endcsname{#2}%Map from column name to column, so we don't need to try to parse the name
}

\def\@@clsfynotes#1{%
  \@@g@tb@seline{\tmpn@te}{#1}\x@\edef\csname @n-\tmpn@te#1@bls\endcsname{\the\dimen0}%
}

\def\@@l@stcolonly#1{%
  \x@\ifx\csname lastcol\tmpa-\the\p@lyp@geno\endcsname\tmpb  % Is this the right column for #1 notes?
    \trace{dmc}{#1 applied for \tmpb/\csname lastcol\tmpa-\the\p@lyp@geno\endcsname}%
    \let\tgtc@l\tmpb
    \let\tmp@r\tr@e
  \else
    \trace{dmc}{#1 skipped \tmpb/\csname lastcol\tmpa-\the\p@lyp@geno\endcsname}%
  \fi
}

\def\@clsfynotes#1\E{%Classify footnote types: notes might be: in this box (or the final follow-on) 'n'ormal; shifted to an xrefs column, but overflowing to here 'x'ref, 
  %or affecting the whole page 'p'. There's also a category 'i'gnore, used for notes that don't get counted.
  \edef\tmpn@te{#1}%
  \ifdiglotSepNotes
    \def\tmp@n@tetyp{n}% Normal note- end of last column on page
  \else
    \def\tmp@n@tetyp{p}% Bottom of page
  \fi
  \ifx\tmp\XrefNotes\edef\tmp@n@tetyp{x}\fi%
  \ifcsname endn@te-#1\endcsname 
    \trace{dmc}{#1 is an endnote. Why is it appearing as an insert??}%Endnotes are fully expanded at the end of the book, so appear as normal text.
    \def\tmp@n@tetyp{i}%ignore
  \fi
  \x@\edef\csname @n-\tmpn@te @typ\endcsname{\tmp@n@tetyp}%
  \trace{dmc}{Recording @n-\tmpn@te @typ as \tmp@n@tetyp}%
  \let\col@do\@@clsfynotes \x@\each@col\all@list\E
}
\def\t@rgetcols{}
\def\polyglot@eachtime@setup@complexpages{%
  \trace{dmc}{polyglot@eachtime@setup@complexpages}%
  \ifx\t@rgetcols\empty\else
    \let\d@\und@fit
    \x@\cstackdown\t@rgetcols,\E
  \fi
  \ifx\diglot@list\empty\else
    \global\f@llow@n=0
    \let\col@do\cle@rf@llow@ns\x@\each@col\diglot@list\E% Stop all chains.
    %\let\col@do\local@split@defs\x@\each@col\diglot@list\E % Ensure that all columms have a block of dimensions.
    \let\d@\t@gpageinsertnames \x@\cstackdown\pageins@rts\E
    \let\d@\@mktmpinsdim@n \x@\cstackdown\columnins@rts\E
    \let\d@\@clsfynotes \x@\cstackdown\alln@tes,\E
  \fi
}

\def\reset@colindexes{%
  \ifx\diglot@list\empty\else
    \let\col@do\cle@rtmpnum\x@\each@col\all@list\E% reset column counts
  \fi
}

\newcount\p@lyr@wno
\def\inactive@col@code#1{\x@\let\csname in@ctive@col@#1\endcsname\tr@e}% Various 'column codes' are not connected to any input. Use ifcsname to check for them
\inactive@col@code{-} % A blank column or page
\inactive@col@code{=} % Lines
\inactive@col@code{+} % Footnote slot(s)
%\inactive@col@code{@} % Image / sidebar slot?? 

\def\col@active@count#1{\ifcsname in@ctive@col@#1\endcsname\else\advance\count255 by 1 \fi}% 
\def\@@complexr@vpolyp@ges#1{%
  %\trace{dmc}{  @@complexr@vpolyp@ges #1}%
  \count255=\csname @tmpnum@#1\endcsname
  \advance\count255 by 1
  \edef\@tmpnam{decode@#1\the\count255}%
  \x@\let\x@\x@fch@r\csname \@tmpnam\endcsname
  \trace{dmc}{... #1\the\count255 \space is \x@fch@r}%
  \xdef@cseq{@tmpnum@#1}{\the\count255}%
  \ifBookOpenLeft
    \xdef@cseq{p@lyp@gecols\p@lyr@wstring}{\x@fch@r\csname p@lyp@gecols\p@lyr@wstring\endcsname}%
  \else
    \xdef@cseq{revp@lyp@gecols\p@lyr@wstring}{\csname revp@lyp@gecols\p@lyr@wstring\endcsname\x@fch@r}%
  \fi
}
\def\@complexr@vpolyp@ges#1\E{%Row-of-columns processing
  \trace{dmc}{@complexr@vpolyp@ges #1, row=\the\p@lyr@wno}%
  \trace{dmc}{blank \ifBookOpenLeft rev\fi p@lyp@gecols\p@lyr@wstring}%
  \xdef@cseq{\ifBookOpenLeft \else rev\fi p@lyp@gecols\p@lyr@wstring}{}%
  \def\rev@tmp@list{}\def\list@type{tmp}%
  \let\col@do=\mkrev@list
  \edef\tmporder{#1}%
  \x@\each@col\tmporder\E
  \let\tmporder\rev@tmp@list
  \let\col@do\@@complexr@vpolyp@ges
  \trace{dmc}{@@complexr@vpolyp@ges \p@lyr@wstring {\tmporder}}%
  \x@\each@col\tmporder\E
  \ifBookOpenLeft
    \trace{dmc}{p@lyp@gecols\p@lyr@wstring\space is \csname p@lyp@gecols\p@lyr@wstring\endcsname}%
  \else
    \trace{dmc}{revp@lyp@gecols\p@lyr@wstring\space is \csname revp@lyp@gecols\p@lyr@wstring\endcsname}%
  \fi
  \advance\p@lyr@wno by 1 
}
\def\mkn@wht#1\E{\newdim@n#1}

\newif\if@sc@rerow % Does the given row have multiple columns in it?
\def\@complexs@tpolyp@ges#1\E{%Row-of-columns processing (#1 describes a user's view of a row)
  \trace{dmc}{@complexs@tpolyp@ges #1}%
  \edef\this@p@lyr@wstring{\p@lyr@wstring}% Expand once and cache
  \count255=0
  \let\col@do\col@count
  \x@\each@col#1\E
  \edef\@cspptotcols{\the\count255}%
  \count255=0
  \let\col@do\col@active@count
  \x@\each@col#1\E
  \edef\@csppactcols{\the\count255}%
  \trace{dmc}{blank \ifBookOpenLeft rev\fi p@lyp@gecols\this@p@lyr@wstring}%
  \xdef@cseq{\ifBookOpenLeft rev\fi p@lyp@gecols\this@p@lyr@wstring}{}%
  \x@\xdef\csname cols@\this@p@lyr@wstring\endcsname{\the\count255}% active cols in row p@lyr@wstring
  \ifnum\count255>1 \@sc@rerowtrue 
    \edef\tmp{+\the\count255\dimexpr}\x@\def\x@\tmpb{\csname\this@p@lyr@wstring @ht\endcsname\relax}% Build the scoring function : sum(N=1..X) { rowheight - col height} = N rowheight-sum(1..X){col ht}
    \x@\x@\x@\def\x@\x@\x@\tmp\x@\x@\x@{\x@\tmp\tmpb}%
    \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
  \else
    \@sc@rerowfalse
  \fi
  \edef\tmp{\this@p@lyr@wstring @ht}%
  \ifcsname \tmp\endcsname\else
    \x@\mkn@wht\csname \tmp\endcsname\E % Height for this bit of page.
  \fi 
  \x@\x@\x@\def\x@\x@\x@\pg@hts\x@\x@\x@{\x@\pg@hts\x@+\x@\csname \this@p@lyr@wstring @ht\endcsname}%
  \edef\tmporder{#1}%
  \ifBookOpenLeft % In a book-open-left scenario, we need to process the page contents right-to-left. Easiest way to do that is reorder it from the start.
    \def\rev@tmp@list{}\def\list@type{tmp}%
    \let\col@do=\mkrev@list
    \x@\each@col\tmporder\E
    \let\tmporder\rev@tmp@list
  \fi
  \let\col@do\@@complexs@tpolyp@ges
  \x@\each@col\tmporder\E
  \ifBookOpenLeft
    \trace{dmc}{revp@lyp@gecols\this@p@lyr@wstring\space is \csname revp@lyp@gecols\this@p@lyr@wstring\endcsname}%
  \else
    \trace{dmc}{p@lyp@gecols\this@p@lyr@wstring\space is \csname p@lyp@gecols\this@p@lyr@wstring\endcsname}%
  \fi
  \x@\def\csname cts@\this@p@lyr@wstring\endcsname{#1}% What columns are in this row?
  \x@\xdef\x@\r@wstring\x@{\ifx\r@wstring\empty\else \r@wstring,\fi\this@p@lyr@wstring}% % What is the complete list of sections on this page?A
  \x@\gdef\csname c@stPage-\this@p@lyr@wstring\x@\endcsname\x@{\x@\c@stUnBal\x@\dimexpr\the\fntoks\relax}%
  \global\advance\p@lyr@wno by 1
  \let\@cspptotcols\undefined
  \let\@csppactcols\undefined
}

\newdimen\t@stone
\newdimen\t@sttwo
\newdimen\t@sttri
\newdimen\t@stfou
\newdimen\t@stfiv
\def\m@xtwo#1#2#3{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \ifdim \t@stone> \t@sttwo \t@stone=\t@sttwo \fi#1=\t@stone}
\def\m@xthree#1#2#3#4{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi #1=\t@stone}
\def\m@xfour#1#2#3#4#5{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax \t@stfou=\dimexpr #5\relax 
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi\ifdim \t@stone< \t@stfou \t@stone=\t@stfou \fi#1=\t@stone}
\def\m@xfive#1#2#3#4#5#6{\t@stone=\dimexpr #2\relax \t@sttwo=\dimexpr #3\relax \t@sttri=\dimexpr #4\relax \t@stfou=\dimexpr #5\relax \t@stfiv=\dimexpr #6\relax
  \ifdim \t@stone< \t@sttwo \t@stone=\t@sttwo\fi \ifdim \t@stone< \t@sttri \t@stone=\t@sttri\fi\ifdim \t@stone< \t@stfou \t@stone=\t@stfou \fi\ifdim \t@stone< \t@stfiv \t@stone=\t@stfiv \fi#1=\t@stone}

  
\def\@complexcheck@polyp@ges#1\E{%Check for Row-of-columns processing
  \edef\tmp{#1}%
  \edef\tmpnam{\checkmode p@lyp@gecols\p@lyr@wstring}%
  \edef\tmpval{\csname \tmpnam\endcsname}
  \trace{dmc}{\tmpval=\tmp ?}
  \ifx\tmpval\tmp
  \else
    \edef\checkreport{\checkreport\tmpnam\space does not agree (\tmpval!=#1) }%
  \fi
  \global\advance\p@lyr@wno by 1
}
\def\p@lyr@wstring{\the\p@lyp@geno-\the\p@lyr@wno}
\def\p@lyp@gestring{\the\p@lyp@geno}
\def\p@lyp@gesuffx{@poly@\p@lyp@gestring}
\def\p@lyr@wsuffx{@poly@\p@lyr@wstring}
\def\p@rser@wstring#1-#2\E{\trace{dmc}{p@rstr:#1-#2}\p@lyp@geno=#1 \p@lyr@wno=#2\relax}

\def\@@complexs@tpolyp@ges#1{%column processing
  \traceifset{@@cspp}%
  \trace{dmc}{@@cspp #1}%
  \ifcsname #1isDiglotColumn\endcsname
    \edef\x@fch@r{#1}% The expanded field char.
    \x@\let\x@\@@cspptmp\csname @max@cols@#1\endcsname
    %\trace{dmc}{#1 @@cspptmp \meaning\@@cspptmp}%
    %\ifx\@@cspptmp\z@ro \message{@@cspptmp is not zero}\fi
    \ifnum \@@cspptmp =0 % This must be the first occurance
      \ifnum\@csppactcols>1 \x@\let\csname layout@#1\endcsname\gr@dnormal % Normal 
      \else\x@\let\csname layout@#1\endcsname\gr@dnone \fi % No sync
      \x@\edef\csname @firstpage@#1\endcsname{\the\p@lyp@geno}%
      \x@\edef\csname @lastpage@#1\endcsname{\the\p@lyp@geno}%
      \x@\edef\csname @columns@#1\endcsname{1}%
      \ifcsname #1test\endcsname\else
        \x@\mkn@wht\csname #1test\endcsname\E
      \fi
      \xdef\all@list{\all@list#1}%Extend the list of all real & virtual columns.
    \else
      \new@followon{#1}%
      \x@\let\csname layout@#1\endcsname\gr@dnone % No sync
      \x@\edef\csname @lastpage@#1\endcsname{\the\p@lyp@geno}%
      \x@\edef\csname @columns@#1\endcsname{\the\numexpr \csname @columns@#1\endcsname+1\relax}% How many sub-columns is this split into?
    \fi
    \ifnum\@@cspptmp <\@cspptotcols
      \x@\xdef\csname @max@cols@#1\endcsname{\@cspptotcols}%Used in determining the column width: Actual column widths get reduced by inter-column gaps, and so chunk that co-occurs in a tripple pane will be smaller than if it occured only in a double-pane. This is a pain.
    \fi
    %Needless? \x@\let\x@\@@cspptmp\csname @max@cols@#1\endcsname
    \ifBookOpenLeft
      \xdef@cseq{revp@lyp@gecols\p@lyr@wstring}{\x@fch@r\csname revp@lyp@gecols\p@lyr@wstring\endcsname}%
    \else
      \xdef@cseq{p@lyp@gecols\p@lyr@wstring}{\csname p@lyp@gecols\p@lyr@wstring\endcsname\x@fch@r}%
    \fi
    \if@sc@rerow
      \edef\tmp{-\csname tmp\x@fch@r @ht\endcsname}% modify the row-scoring function
      \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
    \fi
    \count255=\csname @tmpnum@#1\endcsname
    \x@\xdef\csname lastcell#1-\the\p@lyp@geno\endcsname{\p@lyr@wstring} % Where do notes for L/R go on this page?
    \x@\xdef\csname lastcol#1-\the\p@lyp@geno\endcsname{\x@fch@r} % Where do notes for L/R go on this page?
    %\trace{dmc}{lastcol#1-\the\p@lyp@geno\space is \x@fch@r}%
    \x@\xdef\csname thep@geno\x@fch@r\endcsname{\the\p@lyp@geno}%
    \advance\count255 by 1
    \edef\@tmpnam{decode@#1\the\count255}%
    \trace{dmc}{... #1\the\count255\space -> \x@fch@r}%
    \x@\xdef\csname \@tmpnam\endcsname{\x@fch@r}% L0->Z (etc) mapping, needed for reverse-order version
    \xdef@cseq{@tmpnum@#1}{\the\count255}%
  \else 
    \ifcsname inactive@col@code#1\endcsname\else
      \errmessage{!!! #1 is neither an inactive column code nor a diglot(polyglot) column. Define it first.}%
      \error%Force stop
    \fi
  \fi
  \traceifcheck{@@cspp}%
}
\def\checkpolypages{%
  \edef\sl@shcode{\the\catcode47}%
  \catcode47=\tw@lve\relax
  \@checkpolypages
}
\def\@checkpolypages#1#2{% Testing code - check the calculated result agrees with the known result
  \p@lyp@geno=0
  \def\checkreport{}%
  \let\d@\complexcheck@polyp@ges
  \edef\checkmode{}%
  \edef\checknormal{#1}%
  \edef\checkrev{#2}%
  \x@\cstackdown\checknormal,\E
  \p@lyp@geno=0
  \edef\checkmode{rev}
  \x@\cstackdown\checkrev,\E
  \ifx\checkreport\empty\else
    \errmessage{\checkreport}%
  \fi
  \catcode47=\sl@shcode\relax
}


\def\polyglotpages@complexpages#1{%comma separated list of concatenated columns to put on different pages and rows (e.g. AR/A,B/C) specifies 2 pages, pg1 shows L, R and A, pg2 B and C.
  \trace{dmc}{polyglotpages #1}%
  \polyglot@onetime@setup
  \polyglot@eachtime@setup@complexpages
  \p@lyp@geno=0 
  \edef\tmp{#1}%
  \ifx\tmp\empty\errmessage{polyglotpages called with empty argument. That's an error}\fi
  \E\E
  \def\r@wstrings{}%
  \let\d@=\complexs@tpolyp@ges
  \cstackdown#1,\E
  \reset@colindexes
  \p@lyp@geno=0
  \let\d@=\complexr@vpolyp@ges
  \cstackup#1,\E
  \trace{dmc}{Row string list is:\r@wstrings}%
  \def\tmp{0-0}%Just one column? that's a job for simplecols
  \ifx\r@wstrings\tmp
    \edef\diglotlayout{simplecols}
  \else %Anything else is considered a complex page. complexpages doesn't sync page-to-page, while simplepages does.
    \edef\diglotlayout{complexpages}
  \fi
  % Restore catcodes
  \catcode47=\sl@shcode\relax 
  \catcode`\-=\d@shcode\relax
  \let\col@do\@t@gcolinsertnames \x@\each@col\all@list\E
}

\def\polyglotpages{% Just in case, switch some catcodes.
  \edef\sl@shcode{\the\catcode47}%
  \edef\d@shcode{\the\catcode`\-}%
  \catcode47=\tw@lve % /
  \catcode`\-=\tw@lve \relax % -
  \polyglotpages@complexpages
}

\def\set@col@widths@complexpages{%
  \trace{d}{set@col@widths@complexpages}%
  \def\col@do##1{%
    \ifcsname inactive@col@code##1\endcsname\else
      \dimen0=\textwidth
      \count255=\csname @max@cols@##1\endcsname
      \advance\dimen0 by -\numexpr \count255 - 1\relax\gutter \relax\advance\dimen0 by -\count255\columnshift\relax
      \csname column##1width\endcsname=\csname Diglot##1Fraction\endcsname\dimen0
      \trace{dmc}{Set column width for ##1 to be \the\csname column##1width\endcsname}%
    \fi
  }%
  \x@\each@col\diglot@list\E
}

\def\MaxComplexLines{1000} % Should be enough for any set of pages, surely?

\newcount\@@m@one \@@m@one=-1
\newcount\@@zero \@@zero=0
%\def\seta#1#2{\def\tmp##1#1=(##2)##3\E{\edef\STOREa{##1#1=(#2)##3}}\x@\tmp\STOREa\E}
\def\local@split@defs#1#2{% #1=L/R/A, etc. #2=lines. This allocates and clears
  % blocks of dims/counts ready for use. It also sets the shortcuts to the specified
  % column, saving a few CPU cycles. The  number parameter specifies how many rows actually 
  % need clearing, providing a speed-up.
  \ifcsname split@defs@#1\endcsname
    \count255=\csname split@defs@#1\endcsname
    \ifnum\count255<#2 \count255=#2 \advance\count255 by 1 \fi
  \else
    \count255=#2
    \advance\count255 by 1 
  \fi
  \ifnum \count255 >\MaxComplexLines 
    \def\MaxComplexLines{\the\count255}
    \message{#1 has \the\numexpr #2\relax lines. That's more than the code expected. Ideally, alter \MaxComplexLines.}%
    % FIXME if this is the only place they're used, we should deallocate/move the old blocks. Otherwise ensure they're only local definitions.
    % Current bodge is to just force reallocation, which will probably work, with code only getting called from within an output group.
    % A re-write to not allocate the same number of lines per chunk would be one option. *Also*, never allocating for more lines than can fit on the page(s).
    \x@\let\csname split@heights#1\endcsname\undefined
  \fi  
  \x@\edef\csname split@defs@#1\endcsname{\the\count255}%
  \ifcsname split@heights#1\endcsname\else
    \x@\locdimenblk\csname @@@split@heights#1\endcsname{\MaxComplexLines}%
    \x@\locdimenblk\csname @@@split@insheights#1\endcsname{\MaxComplexLines}%
    \x@\loccountblk\csname @@@split@vrs#1\endcsname{\MaxComplexLines}%
    \x@\def\csname split@heights#1\endcsname##1{\x@\dimen\x@\numexpr \csname @@@split@heights#1\endcsname+##1\relax}%
    \x@\def\csname split@insheights#1\endcsname##1{\x@\dimen\numexpr \csname @@@split@insheights#1\endcsname+##1\relax}%
    \x@\def\csname split@vrs#1\endcsname##1{\x@\count\numexpr \csname @@@split@vrs#1\endcsname+##1\relax}%
    \x@\ifx\csname f@llow@n#1\endcsname\empty \else % There are follow-on (calculated) versions
      \x@\x@\x@\sub@splitdefs\csname f@llow@n#1\endcsname#1\relax
    \fi
  \fi
  \x@\let\x@\split@vrs\csname split@vrs#1\endcsname
  \x@\let\x@\split@heights\csname split@heights#1\endcsname
  \x@\let\x@\split@insheights\csname split@insheights#1\endcsname
  \dimen1=-1sp
  \tracetimset{local@split@defs}%
  \advance \count255 by \@@m@one
  \loop
    \split@insheights{\count255}=\dimen1
    \split@heights{\count255}=\dimen1
    \split@vrs{\count255}=\@@m@one % minus one
    \ifcsname split@insdims#1-\the\count255\endcsname
      \x@\let\csname split@insdims#1-\the\count255\endcsname\undefined
    \fi
    \advance\count255 by \@@m@one \ifnum\count255>\@@zero \repeat
  \tracetimcheck{local@split@defs}{#1 \csname split@defs@#1\endcsname}%
}
\def\sub@splitdefs#1#2\relax{%If Z follows on from L, then split@vrsZ(N) should point to split@vrsL(N+offset)
  \edef\tmp{\csname @@@split@heights#2\endcsname+\csname f@llowOfs#1\endcsname}%
  \x@\def\csname split@heights#1\endcsname##1{\x@\dimen\x@\numexpr \tmp+##1\relax}%
  \edef\tmp{\csname @@@split@insheights#2\endcsname+\csname f@llowOfs#1\endcsname}%
  \x@\def\csname split@insheights#1\endcsname##1{\x@\dimen\numexpr \tmp+##1\relax}%
  \edef\tmp{\csname @@@split@vrs#2\endcsname+\csname f@llowOfs#1\endcsname}%
  \x@\def\csname split@vrs#1\endcsname##1{\x@\count\numexpr \tmp+##1\relax}%
  \x@\ifx\csname f@llow@n#1\endcsname\empty \else % There are more follow-on (calculated) versions
    \x@\x@\x@\sub@splitdefs\csname f@llow@n#1\endcsname#2\relax
  \fi
}


\def\@@cplx@measure#1\E{%Measure the current row height of the row #1 
  \let\col@do\max@boxsz\def\v@lpfx{}\def\v@lsfx{box}\dimen1=0pt
  \x@\let\x@\tmp\csname cts@#1\endcsname
  \x@\each@col\tmp\E
  \csname #1@ht\endcsname=\dimen1
  \advance\dimen0 by \dimen1
}
\def\@cplx@measure{%Measure the current page sizes of the assigned chunks
  \dimen0=0pt
  \let\d@\@@cplx@measure
  \x@\cstackdown\r@wstrings,\E
}



\def\complex@ssplit#1{% Slow, but reliable.
  \bgroup % Keep redefinitions local
    \ins@meas@trialfullfalse
    %\ins@meas@trialnofulltrue
    \vfuzz=\maxdimen
      \setbox0\copy\csname excess#1\endcsname%
    \dimen1=\ht0 % FIXME: This *could* be adjusted to limit it to the max number of lines that fit at maximum on the laid-out page(s).
    \dimen2=0pt
    \dimen3=0pt
    \nsplit=\dimexpr \dimen1 / \baselineskip\relax
    \x@\edef\csname nsplit#1\endcsname{\the\nsplit}%
    %\message{#1 has \the\nsplit\space lines}
    \local@split@defs{#1}{\nsplit}%
    \count255=1
    \loop
      \setbox0\copy\csname excess#1\endcsname%
      \setbox1\vsplit 0 to \count255\baselineskip
      \setbox1\vbox{\unvbox1}%
      \@complex@wrt@splitvrs{#1}{\count255}%
      \x@\global\csname split@heights#1\endcsname{\count255}=\ht1
      %\ifnum\count255=1 \showbox1\fi
      \me@sureins@trial{#1}{1}%
      %\advance\dimen3 by \ht1
      %\advance\dimen2 by \ins@meas@trial@result
      \x@\global\csname split@insheights#1\endcsname{\count255}=\ins@meas@trial@result
      \ifins@meas@trialnofull
        \ifx\res@parse\empty
          \global\x@\let\csname split@insdims#1-\the\count255\endcsname=\empty
        \else
          \res@parse
        \fi
      \else
        \global\x@\let\csname split@insdims#1-\the\count255\endcsname=\ins@meas@trial@dims
      \fi
      \trace{dmcr}{#1:\the\count255: \the\csname split@insheights#1\endcsname{\count255}/\the\csname split@heights#1\endcsname{\count255}/\the\csname split@vrs#1\endcsname{\count255}(\ins@meas@trial@dims)}%
      %\xdef\ssr@sult{\ssr@sult \space \the\count255: \the\csname split@insheights#1\endcsname{\count255}/\the\csname split@heights#1\endcsname{\count255}/\the\csname split@vrs#1\endcsname{\count255}(\ins@meas@trial@dims)}%
      \advance \count255 by 1
    \unless\ifnum\count255>\nsplit \repeat
    %\tracetimset{xp}%
    %\x@\def\x@\ssr@sult\x@{%
      %\loop\advance\count255 -1
        %.\space \the\count255 (\x@\the\csname height#1\endcsname{\count255}): \the\csname split@insheights#1\endcsname{\count255} %
      %\ifnum\count255>0 \repeat}
    %%\tracetimcheck{xp}{Reporting}%
  \egroup
}

\def\complex@rsplit#1{%Recursive version (faster if notes/inserts are sparse -
  % it works on the principle that if there's no change in the inserts when
  % measured at A and B, then there are no inserts in that portion, and the only question is what the split points/verse numbers are.)
  % 
  \vfuzz=\maxdimen
  \x@\let\x@\eb@x\csname excess#1\endcsname
  \setbox0\copy\eb@x
  \dimen1=\ht0 % FIXME?: This *could* be adjusted to limit it to the max number of lines that fit (at maximum) on the laid-out page(s). That would require some kind of accountancy steps, and things need measuring *eventually*.
  \nsplit=\dimexpr \dimen1 / \baselineskip\relax
  \x@\edef\csname nsplit#1\endcsname{\the\nsplit}%
  \trace{dmc}{complex@rsplit: #1 \the\ht0+\the\dp0: \the\nsplit}%
  \local@split@defs{#1}{\nsplit}% Generate (if needed) and flag as unused values. Also sets \split@insheights etc.  
  \bgroup
    \ins@meas@trialfullfalse
    %\ins@meas@trialnofulltrue% No full measuring
    \@complex@rsplit{#1}{\the\nsplit}{0}{0}{0pt}{-1sp}%
  \egroup
  \count255=0
  % Assign the verse numbers and split-heights by a straight loop 
  \loop
    \advance\count255 by 1
    \setbox0\copy\eb@x
    \setbox1\vsplit 0 to \count255\baselineskip
    \setbox1\vbox{\unvbox1}%
    \@complex@wrt@splitvrs{#1}{\count255}%
    \ifx\res@parse\empty\else
      \ins@meas@trial@result=\csname split@insheights#1\endcsname{\count255}\relax
      \res@parse
    \fi
    \x@\global\csname split@heights#1\endcsname{\count255}=\ht1
    \trace{dmcr}{#1{\the\count255,\the\dimexpr \count255\baselineskip\relax}=\the\csname split@insheights#1\endcsname{\count255}/\the\csname split@heights#1\endcsname{\count255}/\the\csname split@vrs#1\endcsname{\count255}/\csname split@insdims#1-\the\count255\endcsname}%%
  \ifnum\count255<\nsplit \repeat
}

\globdimenblk\m@rgedim{50}%This had *better* be overkilll
\newcount\m@rgedno
\def\res@tm@reged{%
  \let\d@\undefm@dim
  \x@\cstackdown\ml@g,\E
  \def\ml@g{}%
  \m@rgedno=0
}
\def\ml@g{}\m@rgedno=0

\def\undefm@dim#1\E{\x@\let\csname @@@#1\endcsname\undefined}
\def\m@rgedims#1#2#3{%Combine #1 and #3 using operator #2
  \edef\@atmp{#1}\edef\@btmp{#3}\tempfalse
  \ifx\@atmp\empty\temptrue\else\ifx\@btmp\empty\temptrue\fi\fi
  \iftemp\edef\@mtmp{#1#3}\else
    \def\@op{=}%
    \x@\@m@rgedim#1,\E%
    \def\@op{#2}%
    \x@\@m@rgedim#3,\E%
  \fi
  \let\@mtmp\empty
  \let\d@\r@pval
  \x@\cstackup\ml@g,\E
  \res@tm@reged
}
\def\r@pval#1\E{%
  \edef\@mtmp{\ifx\@mtmp\empty\else \@mtmp,\fi#1:\the\dimen\numexpr \m@rgedim+\csname @@@#1\endcsname\relax}}

\def\@m@rgedim#1,#2\E{%
  \edef\tmp{#1}\ifx\tmp\empty\else
    \@@m@rgedim #1::\E
  \fi
  \edef\tmp{#2}\ifx\tmp\empty
    \let\n@x\cstackrelax
  \else
    \let\n@x\@m@rgedim
  \fi
  \n@x#2\E
}

\def\@@m@rgedim#1:#2:#3\E{%
  \def\tmp{#2}\ifx\tmp\empty\trace{dmc}{! @@m@rgedim Error parsing #1. Ignored}\else
    \edef\mn@m{@@@#1}\ifcsname \mn@m\endcsname
      \edef\v@r{\dimen\numexpr \m@rgedim+\csname \mn@m\endcsname\relax}%
      \if=\@op
        \v@r=#2\relax
      \else
        \v@r=\dimexpr \v@r \@op #2\relax
      \fi
    \else
      \x@\edef\csname \mn@m\endcsname{\the\m@rgedno}%
      \edef\ml@g{#1,\ml@g}%
      \advance\m@rgedno by 1
      \edef\v@r{\dimen\numexpr \m@rgedim+\csname \mn@m\endcsname\relax}%
      \v@r \@op#2
    \fi
  \fi
}
\newbox\tmpb@x
\def\@complex@wrt@splitvrs#1#2{%
  \edef\t@st{\splitbotmark}%
  \ifx\t@st\empty\else \ifx\t@st\t@tle\else \ifx\t@st\intr@\else 
    \x@\extr@ctfirst\t@st\relax\relax
    \setbox2\hbox{\x@\global\csname split@vrs#1\endcsname{#2}=\v@rsefrom }%Record the verse, but discard any trailing a,b,c
  \fi\fi\fi
} 
\def\@complex@rsplit#1#2#3#4#5#6{% 1:col,2:endpoint,3:startoffset,4:boxID,5:startinserts,6:endinserts
  % Controlled by \ifins@meas@trialnofull  (whether details of the full trial are calculated and written)
  %
  \edef\ncv@lb{#6}%
  \setbox\tmpb@x\copy#4
  \count255=#2\relax
  \advance\count255 by -#3%Remove offset to get delta, and half it (i.e. find midpoint of box, in absolute terms)
  \divide\count255 by 2
  \ifnum \count255>0 % I.e. there's something to do.
    \edef\@sp{\the\count255}% @sp=split point- half way through box
    \edef\@npb{\the\numexpr #2 \relax}% abs position of test-range end-point  (might be a calc)
    \edef\@np{\the\numexpr #3+\count255 \relax}%absolute number for @sp
    \trace{dmc}{rsplit #1 #2 #3 #4 #5 #6 (\@np, \@npb) (box:\the\ht#4)}%
    \ifnum\@npb >\nsplit %sanity check
      \errmessage{Insane value #2 > \the\nsplit}%
    \fi
    \setbox 0\box\tmpb@x
    %\ifx\@sp\@ne \showbox 0 \fi
    \setbox1=\vsplit 0 to \@sp\baselineskip %Box 1 now holds START, box0 END of range.
    \setbox1\vbox{\unvbox1}% Ensure it is at its natural height.
    \trace{dmcr}{split at #3+\@sp(\@np) results in \number\dimexpr\ht1/\baselineskip\relax /\number\dimexpr \ht0/\baselineskip\relax\space bls split}%
    \dimen1=\split@insheights{\@np}
    \edef\tmpa{\the\dimen1}% inserts in first chunk (box1)
    \ifdim\tmpa =-1sp % Unknown value at np - what we expect!
      \me@sureins@trial{#1}{1}% Measure the first half of the box
      \ifins@meas@trialnofull\else
        \ifnum #3=0
          \global\x@\let\csname split@insdims#1-\@np\endcsname=\ins@meas@trial@dims
          \trace{dmcr}{Details @\@np\space are #5+\ins@meas@trial@result // \ins@meas@trial@dims}%
        \else
          \ifdim\ins@meas@trial@result>0pt
            \x@\x@\x@\m@rgedims\x@\x@\x@{\csname split@insdims#1-#3\x@\endcsname\x@}\x@+{\ins@meas@trial@dims}% Returns value in @mtmp
            \trace{dmcr}{Details @\@np\space are #5(\the\split@insheights{#3})+\ins@meas@trial@result // \csname split@insdims#1-#3\endcsname + \ins@meas@trial@dims  -> \@mtmp}%
            \global\x@\let\csname split@insdims#1-\@np\endcsname=\@mtmp
          \else
            \global\x@\let\csname split@insdims#1-\@np\x@\endcsname\x@=\csname split@insdims#1-#3\endcsname
            \trace{dmcr}{Details @\@np\space are #5(\the\split@insheights{#3})+\ins@meas@trial@result //\csname split@insdims#1-#3\endcsname}%
          \fi
        \fi
      \fi
      \let\tmpa\ins@meas@trial@result
      \dimen1=\dimexpr #5 + \tmpa \relax
      \global\split@insheights{\@np}=\dimen1
      \trace{dmcr}{rsplit - \tmpa\space between #3 and \@np (\the\dimen1)}%
    \else
      \trace{dmc}{rsplit ! No measuring needed (result already) for \@np ??, how did we get here?}%
    \fi
    %\trace{dmc}{Looking up \@npb}%
    \dimen0=\split@insheights{\@npb}\relax% Urm, why is this not #6??
    \ifdim \dimen0=-1sp % unknown value at top end of split- shouldn't happen much!
      \me@sureins@trial{#1}{0}% Measure the second hald
      \let\tmpb\ins@meas@trial@result
      \trace{dmcr}{rsplit + \tmpb\space between \@np and \@npb}%
      \ifins@meas@trialnofull\else
        \ifdim\ins@meas@trial@result>0pt
          \x@\m@rgedims\x@{\csname split@insdims#1-\@np\endcsname}+{\ins@meas@trial@dims}% Returns value in @mtmp
          \trace{dmcr}{Details @\@npb\space is \ins@meas@trial@dims -> \@mtmp}%
          \global\x@\let\csname split@insdims#1-\@npb\endcsname=\@mtmp
        \else
          \global\x@\let\csname split@insdims#1-\@npb\x@\endcsname\x@=\csname split@insdims#1-\@np\endcsname
        \fi
      \fi
      \ifdim\ncv@lb=-1sp
        \dimen0=\the\dimexpr \tmpa+\tmpb\relax
        \edef\ncv@lb{\the\dimen0}% end-point value is sum of the 2 parts.
        %\message{\@npb -> \tmpb+\tmpa =\ncv@lb}%
        \x@\global\split@insheights{\@npb}=\ncv@lb
      \fi
    \else
      \edef\tmpb{\the\dimexpr#6-\split@insheights{\@np} \relax}%
      \trace{dmcr}{rsplit * No measuring needed for \@np-\@npb(#2) (#6-\the\dimen0 ): calculated \tmpb}%
    \fi
    \let\ncv@l\ncv@lb
    % process the tail first.
    \ifdim\tmpb=0pt
     % \ifdim #6=-1sp \def\ncv@lb{0pt}\fi% Only occurs at the 1st call, so if there's nothing, then there's nothing in the upper half.
      \count255=\@npb
      \x@\let\x@\tmp\csname split@insdims#1-\@np\endcsname
      \trace{dmcr}{rsplit + no change between \@np and \@npb: \ncv@lb (\tmp)}%
      \loop 
        %\message{\the\count255 -> \ncv@lb}%
        \x@\global\split@insheights{\count255}=\ncv@lb
        \ifins@meas@trialnofull\else
          \global\x@\let\csname split@insdims#1-\the\count255\endcsname=\tmp
        \fi
        \advance\count255 -1
        \ifnum\count255>\@np 
      \repeat
    \else
      %\trace{dmc}{rsplit + \tmpb\space between \@np and \@npb}%
      \ifins@meas@trialnofull\else
        \x@\xdef\csname split@insdims#1-\@np\endcsname{\csname split@insdims#1-\@npb\endcsname,\ins@meas@trial@dims}
      \fi
      \edef\ncv@l{\the\dimexpr \ncv@lb-\tmpb\relax}%
    \fi
    \ifdim \tmpa=0pt
      \trace{dmcr}{rsplit - no changes between #3 and \@np: \ncv@l (\csname split@insdims#1-\@np\endcsname)}%
      \count255=\@np
      \loop 
        \ifdim \split@insheights{\count255}=-1sp
          \x@\global\split@insheights{\count255}=\ncv@l
          %\message{\the\count255 -> \ncv@l}%
        \fi
        \ifins@meas@trialnofull\else
          \global\x@\let\csname split@insdims#1-\the\count255\x@\endcsname\csname split@insdims#1-\@np\endcsname
        \fi
        \advance\count255 -1
      \ifnum \count255>#3 \repeat
    \else\bgroup
      \edef\@rgs{{#1}{\@np}{#3}{1}{#5}{\the\dimen1}}% col,lines,offset,box,insert start,stop
      \x@\@complex@rsplit\@rgs
    \egroup\fi
    \ifdim\tmpb=0pt\else\bgroup
      \edef\@rgs{{#1}{\@npb}{\@np}{0}{\ncv@l}{\ncv@lb}}%% col,lines,offset,box,insert start,stop
      \x@\@complex@rsplit\@rgs
    \egroup\fi
  \fi  
}
\def\complex@split#1{%
  \ifdim\ht\csname excess#1\endcsname > 10\baselineskip % Arbitrary value needs firming up (there's a set-up cost for recursive splitting)
    \complex@rsplit{#1}%
  \else
    \complex@ssplit{#1}%
  \fi
  \trace{dmc}{nsplit#1: \csname nsplit#1\endcsname}%
}

\def\@prepare@layout@complexpages{%
  \trace{d}{@prepare@layout@complexpages \l@gdims{\partial} \ifdiglotb@dy body\else intro\fi}%
  \@prepare@layout@simplecols 
}

\def\cplx@pre@me@sureins@trial#1{%
  \me@sureins@trial{#1}{\csname excess#1\endcsname}%
  \x@\ifx\csname f@llow@n#1\endcsname\empty% There is only a single occurance of
    %this, so there's never a need for any reflow (at least for this 
    % If there's enough space we may not
    %need to do detailed (line-by-line) measuring.
    %Measure the cell /here/ or not? Not
    %\p@lyp@geno=\csname thep@geno#1\endcsname
    %\x@\let\x@\tmp\csname lastcell#1-\the\p@lyp@geno\endcsname
      %\ifdim\ht\csname excess#1\endcsname+\dp\csname excess#1\endcsname < 
  \else 
    \me@suretrue % the layout cannot be laid up without splits, which means there must be measuring
    \ifnum\csname @columns@#1\endcsname>1 
      \ifdim \ht\csname partial#1\endcsname>0pt
        \refl@wcolstrue % The page cannot be reprocessed without the previous content being merged.       
      \fi
    \else
    \fi
  \fi
  \x@\let\csname pre@meas@#1@result\endcsname\ins@meas@trial@result
  \x@\let\csname pre@meas@#1@dims\endcsname\ins@meas@trial@dims
  \ifx\ins@meas@trial@dims\empty
    \x@\edef\csname pre@meas@#1@inscount\endcsname{0}%
  \else
    \let\inserts@npage\tr@e %Notice that there are inserts.
    \count255=0
    \cstackcount\ins@meas@trial@dims,\E
    \x@\edef\csname pre@meas@#1@inscount\endcsname{\the\count255}%
  \fi 
}
\newdimen\tmpdim
\def\g@ncolhtfunctions#1{%Generate page and layout-test height functions for the given column
  \fntoks{}%
  \add@tr@iling{#1}%
  \trace{dmc}{trailing for #1 done}%
  \edef\tmp{\tmpdim=\dimexpr \ht\csname excess#1\endcsname+\dp\csname excess#1\endcsname \relax }%
  \x@\def\csname pg#1htfn\x@\x@\x@\x@\x@\x@\x@\endcsname\x@\x@\x@\x@\x@\x@{\x@\x@\x@\tmp\x@\the\x@\fntoks\x@\edef\csname tmp#1ht\endcsname{\the\tmpdim}}% This one for the page
  \trace{dmc}{pg#1htfn defined as \x@\meaning\csname tmp#1htfn\endcsname}%
  \x@\def\x@\tmp\x@{\x@\tmpdim\x@=\csname #1test\endcsname}%
  \x@\def\csname tst#1htfn\x@\x@\x@\x@\x@\x@\x@\endcsname\x@\x@\x@\x@\x@\x@\x@{\x@\x@\x@\tmp\x@\the\x@\fntoks\x@\edef\csname tmp#1ht\endcsname{\the\tmpdim}}% This one for layout testing.
  \trace{dmc}{tst#1htfn defined as \x@\meaning\csname tst#1htfn\endcsname}%
}
\def\us@tmphtfn#1{\relax\x@\let\x@\tmp\csname \htfntyp #1htfn\endcsname\x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
}

\def\add@tr@iling#1{%add tr@iling#1 to contents of fntoks
  \trace{dmc}{Adding trailing#1 to fntoks}%
  \x@\ifx\csname tr@iling#1\endcsname\relax\else
    \x@\ifx\csname tr@iling#1\endcsname\empty\else
      \x@\let\x@\tmpb\csname tr@iling#1\endcsname % do this in 2 steps,or we end up needing too many expandafters for sanity.
      \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmpb}%
    \fi
  \fi
  \trace{dmc}{currently: \the\fntoks}%
}
\def\reset@tr@iling#1{%Empty insert measurements
  \x@\let\csname tr@iling#1\endcsname\empty
}

% Determine the tallest box in a row
\def\rowm@x#1{\x@\x@\x@\@rowm@x\x@{\csname \p@lyr@wstring @ht\x@\endcsname\x@}\x@{\csname tmp#1ht\endcsname}}% For col@do
\def\@rowm@x#1#2{%
  %\trace{dmc}{@rowm@x #1 #2}%
  \x@\fntoks\x@{\the\fntoks \ifdim #2 > #1 #1=#2\relax\fi}%
}

\def\g@nchunkhtfunctions#1#2\E{%generate an optimised chunk height macro (max(#1,...) for all cols in a row
  \let\gchd@\d@
  \relax\trace{dmc}{g@nchunkhtfunction #1#2}%
  \x@\let\x@\p@gehtcalcs\csname p@gehtcalcs-\the\p@lyp@geno\endcsname% Updating is easier without the csname mess
  \ifx\p@gehtcalcs\relax \let\p@gehtcalcs\empty\fi
  \trace{dmc}{resetting fntoks}%
  \fntoks{}%
  \def\htfntyp{tst}% Mainly we need the test height functions, not the page-height functions
  \let\col@do\us@tmphtfn \x@\each@col#1#2\E
  \x@\let\csname tmp#1ht\endcsname\relax
  \def\tmpb{#2}%
  \ifx\tmpb\empty
    \edef\tmp{\csname \p@lyr@wstring @ht\endcsname=\tmpdim}%
    \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
  \else %Extend the function
    \edef\tmp{\csname \p@lyr@wstring @ht\endcsname=\csname tmp#1ht\endcsname\relax}%
    \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp}%
    \trace{dmc}{fntoks(\p@lyr@wstring):\the\fntoks}%
    \let\col@do\rowm@x 
    \x@\each@col#2\E
  \fi
  \trace{dmc}{htfunction-\p@lyr@wstring:\the\fntoks}%
  \x@\def\csname htfunction-\p@lyr@wstring\x@\endcsname\x@{\the\fntoks}%
  \edef\tmp{\x@\advance\csname p@gehtloss-\the\p@lyp@geno\endcsname by \csname \p@lyr@wstring @ht\endcsname}%
  \x@\def\csname p@gehtcalcs\x@\x@\x@\endcsname\x@\x@\x@{\x@\p@gehtcalcs\csname htfunction-\p@lyr@wstring\x@\endcsname \tmp}%
  \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\p@gehtcalcs\relax % Save the possibly-updated version
  %\fntoks{\textheight - \dimexpr }%
  \relax
  \let\d@\gchd@
}

\def\@genhtfunction#1{%
  \trace{dmc}{@genhtfunction #1}%
  \x@\let\csname tmp#1ht\endcsname\relax
  \edef\tmp{\dimen0=\csname tmp#1ht\endcsname\relax}%
  \x@\expandfntoksgt\x@{\csname \p@lyr@wstring @ht\endcsname}%
  %\trace{dmc}{@ghf->\the\fntoks}%
}
\def\expandfntoksgt#1{%
  \x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp \ifdim\dimen0>#1 #1=\dimen0 \fi}%
}
\newdimen\thisp@gehtloss

\def\mk@chunktr@iling#1:#2\E{%Generate *optimised* height based on each insert actually used. Note that #1 might be a figure insert or some class of footnote. 
  \x@\let\x@\typ@\csname @n-#1@typ\endcsname
  \edef\active@inserts{#1,\active@inserts}%
  \ifx\m@ltip@ge\tr@e
    \x@\let\x@\tmp\csname perpg@inserts\the\p@lyp@geno\endcsname
    \ifx\tmp\relax\let\tmp\empty\fi
    \x@\edef\csname perpg@inserts\the\p@lyp@geno\endcsname{#1,\tmp}%These inserts are shared between multiple pages, and will need resetting between pages.
  \fi
  \let\tmp@r\false % Do we record this chunk?
  \ifx\typ@\relax \def\typ@{I}%Insert 
    \ifcsname #1is@p@geins\endcsname  \def\typ{p}\fi%
    \let\tmp@r\tr@e
  \fi
  \trace{dmc}{mk@chunktr@iling #1:#2 (\typ@)}%
  \if p\typ@\relax 
      \ifdim\dimen\csname #1\endcsname=\maxdimen
        \x@\def\x@\p@gehtcalcs\x@{\p@gehtcalcs\dimen0=\csname #1ht\endcsname \ifdim \dimen0>0pt \advance\thisp@gehtloss \dimen0\fi }% 
     \else
        \x@\def\x@\p@gehtcalcs\x@{\p@gehtcalcs\dimen0=\csname #1ht\endcsname \ifdim \dimen0>0pt \advance\thisp@gehtloss \dimexpr \dimen0+\dimen\csname #1\endcsname\relax\fi }% FIXME:(?) Do we get duplicates?? If so, then the calc should probably be built separately, and elsewhere, or use t@rgetcols-type testing.
      \fi
  \else
    \if n\typ@\relax
      \@@l@stcolonly{#1}%
    \else
      \if x\typ@\relax
        \@@l@stcolonly{#1}%
        %FIXME: Currently the note box-height estimates an effective height for
        %each note as it's added, based on the note width as a function of line
        %length.  With actual multi-row content now available, we should be
        %able to calculate a correcting factor. Current assumption is this is
        %NOT urgent, so the correcting factor is 1.
        \x@\edef\csname #1XrefColOfs\x@\endcsname\x@{\csname \p@lyr@wstring @ht\endcsname}%
      \fi %Other 
    \fi
    \if \tmp@r\tr@e\relax
      \if I\typ@
        \x@\let\x@\tgtc@l\csname #1-col\endcsname %Find what the target column is, or if it's for here-top/bottom
        \ifx\tgtc@l\relax\let\tgtc@l\col@tmp\message{Could not identify column for insert #1 (#1-col), defaulting to \col@tmp}\fi%
      \fi
      \ifcsname \tgtc@l-col-#1\endcsname
        \trace{dmc}{insert #1 (total #2) already accounted for in column \tgtc@l}%
      \else
        \trace{dmc}{insert #1 (total #2) will show in column \tgtc@l}%
        \xdef\t@rgetcols{\t@rgetcols\tgtc@l-col-#1,}% Keep a list
        \x@\let\csname \tgtc@l-col-#1\endcsname\relax
        \x@\let\x@\tmpf\csname tr@iling\tgtc@l\endcsname
        \ifx\tmpf\relax\let\tmpf\empty\fi
        \if x\typ@\relax
          \x@\def\x@\btmp\x@{\x@\dimen\x@1\x@=\csname #1ht\x@\endcsname\x@\advance\x@\dimen\x@1 \x@-\csname #1XrefColOfs\relax}%What's the estimated insert height after accounting for the contents that vanishes into the XrefColumn?
        \else
          \x@\def\x@\btmp\x@{\x@\dimen\x@1\x@=\csname #1ht\endcsname\relax}%What's the insert height?
        \fi
        \x@\extendchunkc@lc\x@{\x@\dimen\csname #1\endcsname}% Save some cycles overall by expanding the extra csname once-for-many, here (extends tmpf)
        \x@\let\csname tr@iling\tgtc@l\endcsname\tmpf
      \fi
    \fi
  \fi
}

\def\extendchunkc@lc#1{%
  \x@\x@\x@\def\x@\x@\x@\tmpf\x@\x@\x@{\x@\tmpf \btmp \ifdim\dimen1>0pt \advance\tmpdim\dimexpr \dimen1+#1\relax\fi}%
}

\def\g@ncolhtadditions#1{%define any (potential) extra column height for column #1 
  \def\col@tmp{#1}\def\tmpa{#1}\edef\tmpb{#1}%
  \trace{dmc}{g@ncolhtadditions #1}%
  \let\m@ltip@ge\false
  \x@\ifx\csname #1isFolowOn\endcsname\tr@e \x@\let\x@\tmpa\csname f@llowing#1\endcsname\fi
  \p@lyp@geno=\csname thep@geno#1\endcsname
  \x@\let\x@\p@gehtcalcs\csname p@gehtcalcs-\the\p@lyp@geno\endcsname% Updating is easier without the csname mess
  \x@\ifx\csname pre@meas@\tmpa @dims\endcsname\empty
    \trace{dmc}{#1 empty}%
  \else
    \x@\ifx\csname @firstpage@\tmpa\x@\endcsname\csname @lastpage@\tmpa\endcsname\else
      \let\m@ltip@ge\tr@e
    \fi
    \trace{dmc}{#1 (\tmpa) -> \csname pre@meas@\tmpa @dims\endcsname}%
    \let\d@\mk@chunktr@iling % May alter: tr@iling[any], p@gehtcalcs, perpg@inserts
    \x@\x@\x@\cstackdown\csname pre@meas@\tmpa @dims\endcsname,\E
    \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\x@\p@gehtcalcs
  \fi
}
%\x@\newdimen\csname p@geloss-0\endcsname
%\x@\newdimen\csname p@geloss-1\endcsname

\newif\ifrefl@wcols % Does the previous content need reflowing?
\newif\ifme@sure % Does the new content need full measuring?
\def\diglot@run@trials@complexpages{% This receives control after all columns are gathered.
  %As columns are gathered via the output routine, by definition the currentpage must be empty
  %Material to typeset is in excessX and wholeX (intially equal in content)
  \trace{dmc}{Running trials for active content:\digl@tc@ntentlist}% 
  \let\inserts@npage\false
  \let\active@inserts\empty
  \refl@wcolsfalse\me@surefalse % can we skip any bits?
  \let\col@do\cplx@pre@me@sureins@trial
  \ins@meas@trialnofullfalse \ins@meas@trialfullfalse % set flags to do a quick test and (if inserts found) drop through to a full one.
  \x@\each@col\digl@tc@ntentlist\E
  \trace{dmc}{Done. Resetting calcs (\inserts@npage)}% 
  % 1 Reset per-column parameters
  \let\col@do\reset@tr@iling
  \x@\each@col\digl@tc@ntentlist\E
  % 2.using the page structure, define code to measure the (potentially) active
  % bits of the layout (i.e, if there's no figures or column notes, then don't
  % bother with column-note calcs), one-per-defined page. 
  \p@lyp@geno=0 \loop
    \x@\let\csname p@gehtcalcs-\the\p@lyp@geno\endcsname\empty
    \csname p@gehtloss-\the\p@lyp@geno\endcsname=0pt
    \x@\let\csname perpg@inserts-\the\p@lyp@geno\endcsname\empty
    \advance\p@lyp@geno by 1 \ifnum\p@lyp@geno<\p@lyp@ges \repeat
  \ifx\inserts@npage\tr@e
    % As some users will probably be confused if they can't put figures into wherever column, triggered in whatever column they feel like
    % so there needs to to be a 3 step process: (a) allocate figure heights, etc, to whatever column.
    % (b) define tmpLht, etc as the sum of the column and inserts for a given chunk, also building a list of page-dependant inserts.
    % (c) build the column functions (calculating and referencing tstLht and friends), generate page-deductions code. 
    % If a given column only has one insert type, then there's no need to do the full scoring on it.
    \let\col@do\g@ncolhtadditions 
    \x@\each@col\all@list\E % step (a)
  \fi
  \let\col@do\g@ncolhtfunctions 
  \x@\each@col\all@list\E % step (b)
  \let\d@\polyr@wstack 
  \let\pd@\g@nchunkhtfunctions
  \x@\cstackdown\r@wstrings,\E %step(c)
  \trace{dmc}{Page height calcs [me@sure\ifme@sure true\else false\fi] (last page):\meaning\p@gehtcalcs}%
  \ifme@sure \else
    %No automatic need to measure (like follow-on columns)... does it fit on the page?
    \pagefullfalse
    \p@lyp@geno=0 \relax
    \@me@surepages
    \ifpagefull
      \me@suretrue
    \fi
  \fi
  \ifme@sure
    % Determine split-points available.
    \tracetimset{options}%
    \let\col@do\g@noptions
    \x@\each@col\digl@tc@ntentlist\E
    \tracetimcheck{options}%
  \fi
}
\newtoks\fntoks
\def\@me@surepages{%
  \me@surepage
  \relax
  \advance\p@lyp@geno by 1\relax
  \ifnum \p@lyp@geno<\p@lyp@ges
    \let\nxt\@me@surepages
  \else
    \let\nxt\relax
  \fi
  \nxt
}

\def\me@surepage{%
  \trace{dmc}{me@surepage \the\p@lyp@geno / \p@lyp@ges}%
  \csname p@gehtloss-\the\p@lyp@geno\endcsname=\ht\csname partial@poly@\the\p@lyp@geno\endcsname % Start with current page chunk...
  \csname p@gehtcalcs-\the\p@lyp@geno\endcsname
  \trace{dmc}{Measuring \the\p@lyp@geno gives \the\csname p@gehtloss-\the\p@lyp@geno\endcsname}%
  \ifdim\csname p@gehtloss-\the\p@lyp@geno\endcsname> \textheight
    \pagefulltrue
  \fi
}

\def\g@noptions#1{%Generate the options-list for each table
  \ifnum \csname pre@meas@#1@inscount\endcsname<2
    \ins@meas@trialnofulltrue% No need for a full measure 
    \x@\ifx\csname pre@meas@#1@dims\endcsname\empty
      \let\res@parse\empty
    \else
      % There is obvously just one result. We can turn that into a dimension using some maths, rather than doing the full check of all inserts required for a total measure.
      \x@\x@\x@\s@tres@parsesimple\csname pre@meas@#1dims\endcsname|#1\E%
    \fi
  \else
    \let\res@parse\empty
    \ins@meas@trialnofullfalse % Allow full measure
  \fi
  \ins@meas@trialfullfalse
  \traceifset{g@noptions}%
  \complex@split{#1}%
  \traceifcheck{g@noptions}%
}

\let\res@parse\empty
\def\s@tres@parsesimple#1:#2|#3\E{%
  \def\v@rnam{split@insdims#2-}%
  \ifnum\count\csname #1\endcsname=1000
    \x@\def\x@\res@parse\x@{\x@\csname \v@rnam-\the\count255\x@\endcsname\x@=\csname ins@meas@trial@result\endcsname}%
  \else
    % Need to correct for count \insname
    \dimen1=\dimexpr \count\csname #1\endcsname/1000\relax
    \edef\tmp{\strip@pt{\dimen1}}%
    \x@\def\x@\res@parse\x@{\x@\csname \v@rnam-\the\count255 \x@\x@\x@\endcsname\x@\x@\x@=\x@\tmp\csname ins@meas@trial@result\endcsname}%
  \fi
  \trace{dmc}{s@tres@parsesimple: \meaning\res@parse}
}

%%%%%%%%%%%%%%%%%%%%
%
%Generic 'do everything to everyrow function

\def\polyp@gestackec#1\E{%Gets an element of the page-strings list (page-row) and run each@col on it.
  \x@\p@rser@wstring #1\E
  \x@\x@\x@\each@col\csname p@lyp@gecols#1\endcsname\E
}%

\def\polyr@wstack#1\E{%Gets an element of the page-strings list (page-row) and run each@col on it.
  \x@\p@rser@wstring #1\E
  \x@\x@\x@\pd@\csname p@lyp@gecols#1\endcsname\E
}%

%%%%%%%%%%%%%%%%%%%%
%
%code that needs slash to not be active.  (process LR/A type page layouts)
%

\catcode47=\tw@lve
  % Slash-separated stack, works roughly like comma-separated stack, but with slashes instead of commas, and the slash-stack uses \d@@
  \def\sstackup#1/#2\E{\edef\sstack@tmp{#2}\ifx\sstack@tmp\empty\let\n@x=\sstackrelax\else\let\n@x=\sstackup\fi\n@x #2\E\edef\sstack@tmp{#1}\ifx\sstack@tmp\empty\else\d@@ #1\E\fi}                  %(1)
  \def\sstackdown#1/#2\E{\edef\sstack@tmp{#1}\ifx\sstack@tmp\empty\else\d@@ #1\E\fi\edef\sstack@tmp{#2}\ifx\sstack@tmp\empty\let\n@x=\sstackrelax\else\let\n@x=\sstackdown\fi\n@x #2\E}
  \def\sstackrelax#1\E{}
    
  \def\complexs@tpolyp@ges#1\E{%page processing (#1 is a page
    \p@lyr@wno=0
    \def\r@wstring{}%
    \x@\let\csname ins@rts-\the\p@lyp@geno\endcsname\relax
    \edef\pg@hts{\csname ins@rts-\the\p@lyp@geno\endcsname}%
    \fntoks{}%
    \let\d@@\@complexs@tpolyp@ges
    \x@\sstackdown#1/\E
    \x@\xdef\csname p@lyr@wcount-\the\p@lyp@geno\endcsname{\the\p@lyr@wno}% Rows on this page
    \x@\xdef\csname p@lypgcts-\the\p@lyp@geno\endcsname{\r@wstring}% Contents of this page (in terms of page-row)
    \x@\gdef\csname p@lypght-\the\p@lyp@geno\x@\endcsname\x@{\x@\dimexpr\pg@hts\relax}%
    \ifcsname p@gehtloss-\the\p@lyp@geno\endcsname\else
      \x@\mkn@wht\csname p@gehtloss-\the\p@lyp@geno\endcsname\E % Height for this bit of page.
    \fi
    %\def\tmp
    %\x@\x@\x@\fntoks\x@\x@\x@{\x@\the\x@\fntoks\tmp
    \x@\gdef\csname sc@re-\the\p@lyp@geno\x@\endcsname\x@{\x@\dimexpr \the\fntoks\relax}%
    \x@\xdef\x@\r@wstrings\x@{\ifx\r@wstrings\empty\else \r@wstrings,\fi\r@wstring}% % What is the complete list of sections (in terms of page-row)?
    \trace{dmc}{page \the\p@lyp@geno \space height is \x@\meaning\csname p@lypght-\the\p@lyp@geno\endcsname. Score is \csname sc@re-\the\p@lyp@geno\endcsname}%
    \ifnum \p@lyp@geno>0  % new@poly@page doesn't get run for page0, as those take over the standard boxes
      \edef\tmpname{partial\p@lyr@wsuffx }
      \ifcsname \tmpname\endcsname\else
        \new@poly@page % side effect: trashes \d@
      \fi
    \fi
    \global\advance\p@lyp@geno by 1\relax
    \xdef\p@lyp@ges{\the\p@lyp@geno}%
  }
  \def\complexr@vpolyp@ges#1\E{%reverse processing. There may be repeated columns, and 'reversed column order' doesn't affect reading order. Thus it does not equate to an inversion (LLR becomes LZR forward and  RLZ when reversed.)
    \p@lyr@wno=0
    \let\d@@=\@complexr@vpolyp@ges % Do the mirrored-version
    \x@\sstackdown#1/\E
    \global\advance\p@lyp@geno by 1
  }
  \def\complexcheck@polyp@ges#1\E{%
    \p@lyr@wno=0
    \let\d@@\@complexcheck@polyp@ges
    \x@\sstackdown#1/\E
    \global\advance\p@lyp@geno by 1
  }
    
\catcode47=\active
%%%%%%%%%%%%%%%%%%%%%%%%%

 
\plugin@endif

