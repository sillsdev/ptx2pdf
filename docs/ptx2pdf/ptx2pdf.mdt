---
title: Paratext Macros
documentclass: book
mainfont: Lato
monofont: Noto Sans Mono CJK HK
fontsize: 12pt
papersize: A4
geometry:
  - left=0.5in
  - bindingoffset=0.7in
  - right=0.8in
  - top=0.8in
  - bottom=0.8in
listings:
---

<!-- # Introduction -->

# Setup

## Initialising

The first file to be loaded is `paratext2.tex` and it has some initial
definitions and set up that it does. The macros make extensive use of
bidirectional controls and for this we need ETeX and its extensions. This is a
prerequisite and therefore all other ETeX extensions are also available to us.
We also follow the LaTeX convention of using the `@` in internal tokens since
outside of the macros we turn off `@` as a letter, making such tokens
inaccessible. `\expandafter` is a long name for this token and can often occur
very frequently in a short space. It is easier to have a short name for the same
thing. Having a local temporary `if` is useful.

`MSG` is for writing messages to the user. `TRACE` was used in the earliest
debugging, but has been largely replaced by `trace` and `tracing`. But some uses
still persist.

The following two `if`s need to be declared early because they are used during
the declaration of other macros.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="35"}
% Here we declare generic useful stuff. Including log output routines.
\TeXXeTstate=1 % enable the eTeX bidi extensions, in case we need RTL support
\catcode`\@=11
\let\x@=\expandafter
\newif\iftemp \tempfalse

\def\MSG{\immediate\write16 } % shorthand to write a message to the terminal
\def\TRACE#1{}%\let\TRACE=\MSG % default - consume messages

% This lot has to be early
\newif\ifinn@te\inn@tefalse
\newif\ifm@rksonpage % Try to keep track of marks, so we can kill them in end-sections. 
\m@rksonpagefalse
```

Files are timestamped in the cropmarks, if enabled.

The timestamp is not recalculated each call. It is calculated once at the start
of the run.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="71"}
% initialize a \timestamp macro for the cropmarks etc to use
\edef\timestamp{\number\year.% print the date and time of the run
  \ifnum\month<10 0\fi \number\month.%
  \ifnum\day<10 0\fi \number\day\space :: }%
\count255=\time \divide\count255 by 60
\edef\hrsmins{\ifnum\count255<10 0\fi \number\count255:}%
\multiply\count255 by 60 \advance\count255 by -\time
\count255=-\count255
\edef\hrsmins{\hrsmins
  \ifnum\count255<10 0\fi \number\count255}%
\edef\timestamp{\timestamp \hrsmins}
```

All the other files in the PTX macros system are pulled in early into
`paratext2.tex` before the rest of macros are defined. This allows them to
include their own initialisation early. In some cases, the order in which files
are included is important.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="85"}
\input ptx-diglot.tex
\input ptx-tracing.tex
\input ptx-para-style.tex
\input ptx-char-style.tex
\input ptx-note-style.tex
\input ptx-stylesheet.tex % must come after the ptx-*-style.tex macros
\input ptx-references.tex
\input ptx-cropmarks.tex
\input ptx-toc.tex
\input ptx-tables.tex
\input ptx-adj-list.tex % must come after ptx-stylesheet.tex
\input ptx-pic-list.tex % must come after ptx-stylesheet.tex
\input ptx-cutouts.tex
\input ptx-callers.tex % must come after ptx-note-style.tex
\input ptx-figure.tex % figure-handling
% Additional modules that are not part of the normal ptx2pdf module
\input ptxplus-character-kerning.tex
% We want to import this module here, but it has to come after the stylesheet is loaded.
%\input ptxplus-marginalverses.tex
```

A final setup is to have some fall back fonts defined. It is fully expected that
jobs will override these definitions later:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="107"}
% default font names (override in setup file)
\ifx\regular\undefined   \def\regular{"Times New Roman"}      \fi
\ifx\bold\undefined      \def\bold{"Times New Roman/B"}       \fi
\ifx\italic\undefined    \def\italic{"Times New Roman/I"}     \fi
\ifx\bolditalic\undefined\def\bolditalic{"Times New Roman/BI"}\fi
```

### Hooks

The PTX macros have an extensive set of hooks which are token lists that are
executed at appropriate points in the processing.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="51"}
% `\addtoendhooks` collects macros to be executed at the end of the job
\def\addtoendhooks#1{\x@\global\x@\@ndhooks\x@{\the\@ndhooks #1}}
\newtoks\@ndhooks
\let\s@ve@nd=\end
\def\end{\par\vfill\supereject \the\@ndhooks \s@ve@nd}

\def\addtoinithooks#1{\x@\global\x@\@nithooks\x@{\the\@nithooks #1}}
\newtoks\@nithooks

\def\addtoeveryparhooks#1{\x@\global\x@\@veryparhooks\x@{\the\@veryparhooks #1}}
\newtoks\@veryparhooks

\def\addtoparstylehooks#1{\x@\global\x@\p@rstylehooks\x@{\the\p@rstylehooks #1}}
\newtoks\p@rstylehooks
```

A CV hook is executed when the verse milestone occurs. The identifier takes the
form of BK1.2 and is based on exactly what the verse milestone value is. The
book is whatever is the book id.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="433"}
% other modules can use \addtoversehooks to insert macros that will be executed at each verse
\def\addtoversehooks#1{\x@\global\x@\v@rsehooks\x@{\the\v@rsehooks #1}}
\def\addtopreversehooks#1{\x@\global\x@\prev@rsehooks\x@{\the\prev@rsehooks #1}}
\newtoks\v@rsehooks
\newtoks\prev@rsehooks
% A CV hook is executed only for a particular CV when the verse milestone occurs.
\def\setcvhook#1#2{\x@\gdef\csname cv-#1\endcsname{#2}}
\def\docvhook{\edef\c@rref{\id@@@\ch@pter.\v@rse}\csname cv-\c@rref\endcsname}
\addtoversehooks{\docvhook}
```

There are also diglot hooks:

\fileheader{ptx-diglot.tex}
```{.latex .numberLines startFrom="47"}
\newtoks\leftho@ks
\newtoks\rightho@ks
\def\addToLeftHooks#1{\x@\global\x@\leftho@ks\x@{\the\leftho@ks #1}}
\def\addToRightHooks#1{\x@\global\x@\rightho@ks\x@{\the\rightho@ks #1}}
```

Within the style system there a style specific hooks that run at different
points in style processing: before, start, end, after.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="227"}
% Allow "hooking" custom TeX code at the beginning or ending of specific styles.
% e.g. `\sethook{start}{s1}{-}` put a hyphen at the start of every section heading
\def\sethook#1#2#3{\x@\def\csname #1-#2\endcsname{#3}}
\def\setbookhook#1#2#3{\x@\def\csname book#1-#2\endcsname{#3}}
```

### Declarations

Various useful declarations. The parargraph types and positions:

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="684"}
% strings for testing against stylesheet parameters
\def\v@rsetext{versetext}
\def\c@nter{center}
\def\l@ft{left}
\def\r@ght{right}
\def\t@tle{title}
\def\s@ction{section}
\def\oth@r{other}
```

From notes we declare `+` and `-` letters:

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="191"}
\edef\pl@scatcode{\the\catcode`+}
\catcode`+=11
\edef\pl@s{+}
\catcode`+=\pl@scatcode
\def\min@s{-}
```

For figures we declare various strings to compare against:

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="581"}
\def\picw@rning#1#2{\msg{converted picture placement "#1" to "#2" in single-column layout}}

\def\size@COL{col}
\def\size@SPAN{span}
\def\size@PAGE{page}% a page, within the margins
\def\size@FULL{full}% the paper size
\def\loc@T{t}
\def\loc@B{b}
\def\loc@TL{tl}
\def\loc@TR{tr}
\def\loc@BL{bl}
\def\loc@BR{br}
\def\loc@Inl{h}% In-line graphic, not a float.
\def\loc@Cut{c}% cutout
\def\loc@Par{p}% post-paragrpah
\def\loc@Page{P}% Page (with headers/footers)
\def\loc@Page{F}% FullPage (no headers/footers)
\def\@lignInner{i}
\def\@lignOuter{o}
\def\@lignLeft{l}
\def\@lignRight{r}
\def\@lignTop{t}
\def\@lignBot{b}
\def\keyR@TATE{rotate}
\def\val@dd{odd}
\def\val@ven{even}
\def\valb@th{both}
\def\val@BIND{binding}
\def\val@EDGE{edge}

\newbox\picb@x % Delayed picture
\newbox\picb@xR % (diglot, right-hand) delayed picture.
\newcount\p@ramnumber
\newdimen\p@cinswid
\newdimen\p@cwidth
\newdimen\p@cheight
\newdimen\otherinsht % In a diglot, an insert doesn't affect availht if it's smaller

\newif\ifmorep@rams
\newif\ifpicp@gefile \picp@gefilefalse
\newread\picl@ctest
\newwrite\picp@ges
```

### Utility Functions

There are numerous utility functions spread around the code.

When processing USFM text we treat numbers as letters. This protects us from
accidental calculations, etc. We have macros for switching the interpretation of
digits.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="449"}
\def\m@kedigitsletters{\catcode`0=\el@ven \catcode`1=\el@ven \catcode`2=\el@ven \catcode`3=\el@ven
 \catcode`4=\el@ven \catcode`5=\el@ven \catcode`6=\el@ven \catcode`7=\el@ven
 \catcode`8=\el@ven \catcode`9=\el@ven \relax}
\def\m@kedigitsother{\catcode`0=\tw@lve \catcode`1=\tw@lve \catcode`2=\tw@lve \catcode`3=\tw@lve
 \catcode`4=\tw@lve \catcode`5=\tw@lve \catcode`6=\tw@lve \catcode`7=\tw@lve
 \catcode`8=\tw@lve \catcode`9=\tw@lve \relax}
\def\el@ven{11}
\def\tw@lve{12}
```


### Tracing

The PTX macros have a tracing mechanism by which tracing can be added to any
job. There are various different log traces that are available and a job may
enable as many as it wants. Each trace has an identifier.

There is nothing special that says the tracing code has to be a single character.
It is also better to have more identifiers than less to allow for more targeted tracing.
Trace identifiers allocated in ptx macros:

| Identifier | Trace
|------------|------
| a | all traces
| b | balancing (info for external page break analysis)
| C | cutouts
| d | diglot construction
| D | Diglot gory details
| Ds | Diglot stylesheet
| f | footnotes
| F | fonts
| g | figures
| h | headings
| H | Headers, marks, etc
| i | inserts (tracking the value of holdinginserts)
| j | paragraph adjustments
| n | notes
| o | rebalancing
| p | page output
| P | Piclists
| s | stylesheet
| S | side-dependent swapping 
| v | marginal verses

Within the code, text may be output to a trace using the `\trace` macro that
takes an identifier and the text to output. A user configuration may use the
`tracing` macro with an identifier as its parameter to enable that trace. Each
trace state is held in a token and when `\trace` runs it tests the token for its
identifier to see whether to write out the text or not. If no tracing is enabled
then the whole mechanism is short circuited.

\fileheader{ptx-tracing.tex}
```{.latex .numberLines startFrom="47"}
% Now modified so that multiple \tracing{} commands can be issued.
\newcount\TRACEcount %Numbered tracing for is useful for diglot. May be for something else too.
\def\y@s{y}
\def\tracing#1{\x@\xdef\csname tr@cemode-#1\endcsname{\y@s}\let\trace=\tr@cer}%
\def\notr@cer#1#2{\relax}%
\def\tr@cer#1#2{%
    \let\next=\notr@ceout
    \x@\ifx\csname tr@cemode-#1\endcsname\y@s \let\next=\tr@ceout\fi
    \x@\ifx\csname tr@cemode-a\endcsname\y@s \let\next=\tr@ceout\fi
    \next{#2}}%
\def\tr@ceout#1{%
    \immediate\write-1{#1}}%
\def\traceNum#1#2{\global\advance\TRACEcount by 1\trace{#1}{+\the\TRACEcount: #2}}
\def\notr@ceout#1{\relax}%
\let\trace=\notr@cer
```

## Running

Here we examine the processing of a USFM file. The first step in loading a USFM
file is to do any one time setup. Such setup occurs before the first file is
processed but is also blocked from executing again before any other files in the
job.

### One Time Setup

This code is run once, since the definition is overwritten at the end ❶. It
calls various other setup macros which we will examine here. We capture the
current baselineskip as being the default baselineskip for the document. Then we
call the various setup macros and also various hook setup routines. Then we set
a flag to say that we are inside a USFM file. Now we can call the job `init`
hooks.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="556"}
\def\@netimesetup{
 % stuff to execute after loading all stylesheets but before processing the first USFM file
 \origb@selineskip=\baselineskip
 \s@tupsizes
 \defineheads
 \@ddcvhooks
 \@ddspecialhooks
 \global\lastptxfiletrue
 \the\@nithooks
 \let\@netimesetup=\relax}                                                      ①
```

First we set up various sizes. Setting the body baseline involves setting the
baselineskip and the `\le@dingunit` and the vertical space unit. If the
baselineskip is too small then set it to $14 * {\rm LineSpaceFactor} * {\rm FontSizeUnit}$.
The LineSpaceFactor is usually 1.0 which given the fontsize for `\p` is
typically 12 in the stylesheet, gives us a text size to leading of 12 units on
14 units where units are the FontSizeUnit. If the `baseline` parameter for `\p`
is not set, then set it. This applies to diglot sided versions too.

So to set up sizes we set up the baselineskip and set `lineskiplimit` to
something pretty hugely negative which means that `lineskip` will not kick in
unless someone asks for that. We set the baselineskip from the `\p` style, even
if we've just set it. We set the amount of space to add to the top of a column
to be a baseline. We calculate the gutter width and the total textwidth
available to us. We also calculate the width of a double column column. We do
the same for the diglot column widths. We set the actual textwidth (`hsize`) to
be the single column width minus 2 columnshifts. `columnshift` is usually 0 for
single column text, so this is merely calculating how much text width we have
for 2 columns or 1 single column. We calculate the real margin dimensions and
from that the textheight, which we then set as the page breaking page height. We
set up the physical page size for the PDF file and then reset the vsize to
textheight.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="716"}
\def\s@tb@dyb@seline#1{%Parameter is {} for monoglot, L / R for diglot.
 \baselineskip=\origb@selineskip
 \le@dingunit=\LineSpacingFactor\FontSizeUnit
 \verticalsp@ceunit=\VerticalSpaceFactor\le@dingunit
 \ifdim\baselineskip < 1pt \baselineskip=14\le@dingunit\fi % If the baselineskip has been specifically
                                                           % set it will remain. Otherwise, the default
                                                           % of 14 will be applied here and set text will
                                                           % hold to the grid.
 \getp@ram{baseline}{p#1}\ifx\p@ram\relax\setp@ram{baseline}{p#1}{\the\baselineskip}%
 \MSG{Baselineskip for p#1 undefined, set to \the\baselineskip}\fi
}
\def\s@tupsizes{
 \s@tb@dyb@seline{}%
 %\tracingifs=1
 \lineskiplimit=-7\le@dingunit
 \lineskip=0pt
 \s@tbaseline{p}%
 \topskip=\baselineskip\MSG{topskip=\the\topskip}
 \gutter=\ColumnGutterFactor\FontSizeUnit
 \dimen0=\PaperWidth \dimen2=\SideMarginFactor\MarginUnit
 \advance\dimen0 by -2\dimen2
 \ifBindingGutter \advance\dimen0 by -\BindingGutter \fi
 \advance\dimen0 by -1\ExtraRMargin
 \textwidth=\dimen0
 \colwidth=0.5\textwidth \advance\colwidth by -0.5\gutter\advance\colwidth by -\columnshift
% Diglot dimensions
 \advance\dimen0 by -\gutter\advance\dimen0 by -2\columnshift
 \columnLwidth=\DiglotLeftFraction\dimen0
 \columnRwidth=\DiglotRightFraction\dimen0
 \hsize=\textwidth \advance\hsize by -2\columnshift
 \topm@rgin=\TopMarginFactor\MarginUnit
 \advance\topm@rgin by -\topskip \advance\topm@rgin by 12\FontSizeUnit
 \bottomm@rgin=\BottomMarginFactor\MarginUnit
 \dimen0=\PaperHeight
 \advance\dimen0 by -\topm@rgin
 \advance\dimen0 by -\bottomm@rgin
 \textheight=\dimen0
 \vsize=\textheight
 \ifrotate\pdfpagewidth=\PaperHeight \pdfpageheight=\PaperWidth\else
 \pdfpagewidth=\PaperWidth \pdfpageheight=\PaperHeight\fi
 \trace{p}{setupsizes: \the\pdfpagewidth, \the\pdfpageheight}
 \resetvsize
}
```

There are a number of special case USFM markers that do more than simply switch
styles and style types. These often need special handling. We declare them here.

The whole definition is grouped in a group with `\obeylines` to enable us to
access `^^M` end of line character. `\h` is used to indicate the book name as
printed in headings and elsewhere. Since we are collecting a string, we turn off
all the active characters and then use pattern matching to capture the rest of
the line as the book name. Which variable is set depends on diglot sides.

The `\cl` chapter label has two modes of usage. If it occurs anywhere than
between a `\c` and the following paragraph start, it is treated as a global
setting. Otherwise it is simply a paragraph style that clears any drop chapter
number. Collecting the chapter label globally is almost identical to processing
`\h`.

The `\id` line is generally useful to collect, particularly to output as part of
any cropmarks. In addition we collect the first up to 3 characters as the book
id. Again we do the same trick for handling the id line. In addition we convert
space back to its normal interpretation and so any initial or final space will
be ignored.

`\fig` simply captures its contents and then calls `\d@figure` with that
contents ❶. `\nb` is a special non-breaking paragraph marker and needs special
handling which we redirect to here.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="467"}
\begingroup
\obeylines%
\gdef\@ddspecialhooks{% there are a few special USFM markers that we give "magic" properties
 \let\@H=\h%
 \def\h{\bgroup\deactiv@tecustomch@rs
        \obeylines\@h}% \h gets stored as the book name (for references)
 \def\@h ##1^^M{\ifdiglot\ifdiglotL\gdef\b@ok{##1}\else\gdef\b@okR{##1}\fi\else\gdef\b@ok{##1}\fi\egroup}% store book id in \b@ok
 %
 \let\@CL=\cl%
 \def\do@CL{\global\ch@pterfalse\@CL}%
 \def\cl{\ifch@pter \let\n@xt=\do@CL \else \let\n@xt=\st@recl \fi \n@xt}%
 \def\st@recl{\bgroup\obeylines\@cl}% \cl gets stored as chapter label and changes \c format
 \def\@cl ##1^^M{\ifdiglot\ifdiglotL\gdef\ch@plabel{##1}\else\gdef\ch@plabelR{##1}\fi\else\gdef\ch@plabel{##1}\fi\egroup}%
 %
 \let\@ID=\id%
 \def\id{\bgroup\obeylines\unc@tcodespecials \m@kedigitsother
   \catcode32=10 \@id}% \id gets stored and printed in the margin with cropmarks
 \def\@id ##1^^M{\gdef\c@rrID{##1}\uppercase{\@@id##1ZZZ\end}\egroup
        \csname bookstart-all\endcsname
        \csname bookstart-\id@@@\endcsname}%
 %
 \def\fig{\m@kedigitsother\ptx@fig}% \fig has its own special macro to parse the fields
 %
 \let\nb=\ptx@nb% \nb is a special code that suppresses a paragraph break across \c
}%
\endgroup

\def\unc@tcodespecials{\def\do##1{\catcode`##1=12 }\dospecials}
\def\@@id#1#2#3#4\end{\gdef\id@@@{#1#2#3}} % get first 3 chars of the \id
\def\ptx@fig #1\fig*{\d@figure{#1}\m@kedigitsletters}                           ①
```

### Processing USFM

Reading a USFM file involves setting up for a new book. We start by ensuring
that one time setup code is run and if creating a diglot we set up the various
baselines for the left and right text.

Which routine to use for gridding a box. There is a diglot specific one and one
for when we want to lose extra space at the top of a column and one for when we
want to keep it. The user can set `squashgridboxfalse` to keep the extra space.

We then clear the chapter labels and clear the style stack. Initialising the
paragraph styles involves clearing all the flags for which type of paragraph we
are in now:

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="39"}
\def\initp@rastyles{\@ntrofalse \t@tlefalse \b@dyfalse \def\m@rker{}}
```

And initialising the notes involves clearing all the note boxes and supporting
skips, etc.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="573"}
\def\ptxfile#1{
 \saveLRspecificOrig%This becomes a \relax after first use. Always call it.
 \@netimesetup
 \ifdiglot\bgroup%This must be outside of @onetimesetup as there's no guarantee that diglot will be true for all ptxfiles.
   \dimen0=\baselineskip
   \diglotLfalse
   \showLRspecific
   \setLRspecific\s@tb@dyb@seline{R}%
   \global\baselineDelta=\baselineskip
   \saveLRspecificSide{R}%
   \baselineskip=\dimen0
   \diglotLtrue
   \showLRspecific
   \setLRspecific\s@tb@dyb@seline{L}%
   \global\advance\baselineDelta by -\baselineskip
   \saveLRspecificSide{L}%
   \baselineskip=\dimen0
   \egroup
   \global\let\gridb@x\diglotgr@db@x
 \else
   \ifsquashgridbox\global\let\gridb@x\gr@db@@x\else\global\let\gridb@x\gr@db@x\fi % liberated from onetimesetup, as it might not be one-time.
 \fi
 \gdef\ch@plabel{}
 \gdef\ch@plabelR{}
 \gdef\mcstack{,}
 \initp@rastyles
 \initn@testyles
```

Now we can load the file. But with each usfm file there may be associated
supporting files. There is the paragraph adjustments file and the pictures list
file that a user may create. Also there is the picture pages file that says
where every picture is in the job and we reload that for each file.

A USFM file is not a TeX file and so many of the characters do not have the same
interpretation in a USFM file as they do in a TeX file. Most characters are
treated as `other` meaning that they are just treated as text with no special
interpretation. `~` is treated as active since it usually means a non-breaking
space. `_` is treated as a letter so that it may occur in SFM markers. `/` is
active in that a double slash is treated as a line break while a single slash is
just that.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="681"}
\catcode`\/=\active
\def/{\futurelet\n@xt\sl@sh}
\def\sl@sh{\ifx\n@xt/\let\n@xt\sl@shbreak\else\let\n@xt\sl@shprint\fi\n@xt}
\def\sl@shbreak/{\unskip\penalty-250{} \ignorespaces}
\def\sl@shprint{\char`\/}
\catcode`\/=12
```

We also turn on all the active characters because we want to process them in the
text. Digits become letters (since we don't want to do any maths with them). Now
we open the file. If it is at the end of file, i.e. it failed to open, then our
action is to report the fault. Otherwise our action is to have TeX interpret the
file. OK do the action!

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="602"}
 \openadjlist "\the\AdjListPath#1.adj"
 \openpiclist "\the\PicListPath#1.piclist"
 \openpicpages "\jobname.picpages"
 %\catcode`\$=12
 \catcode`\^=12 % make these printable
 \catcode`\&=12 
 \iftildenbsp
  \catcode`\~=13 %Normal value
 \else
  \catcode`\~=13 %printable
 \fi
 \catcode`\#=12
 \catcode`\{=12 \catcode`\}=12
 \catcode`\_=11 % treat as letter for TE custom styles
 \catcode`\/=\active
 \catcode13=10
 \catcode`+=11 % treat as letter
 \activ@tecustomch@rs
 % The last comment on all matters
 \catcode`\%=12
 \m@kedigitsletters
 \openin\t@stread="\the\PtxFilePath#1"
   \ifeof\t@stread \def\n@xt{\MSG{USFM file "\the\PtxFilePath#1" not found -- ignored}}
   \else \closein\t@stread \def\n@xt{\input "\the\PtxFilePath#1"\relax}\fi
 \n@xt
```

Once the file is processed we need to tidy up. We close any open character
styles and stop skipping any text. We finish any open tables and close off the
diglot. We run any `bookend` hooks. And then we undo all our character setup for
reading the file. We make digits digits again. We get back our comment character
and turn off special characters. We give back characters their normal TeX
interpretation. If we processing the last file in a job then we close the
piclist, otherwise we keep it open until the next job starts. We close the
adjustments list file and reset more characters. We go to single column and
force a page break. This page break may not actually result in a page break if
we are running books together. If we are forcing a true break, then we shipout
any partial box remaining and clear up from that. Finally we simply say: we are
in single column normal text mode now. And with that we return to the driving
.tex file.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="629"}
 \ifhmode \unskip\end@llcharstyles \par \fi
 \ifsk@pping\egroup\fi
 \endt@ble
 \ifdiglot\ifdiglotL\norighttext\fi\enddigl@t\fi
 \ifx\b@ok\relax\else\csname bookend-\id@@@\endcsname\relax\csname bookend-all\endcsname\fi
 \m@kedigitsother
 \catcode`\%=14 % The return of commentary
 \deactiv@tecustomch@rs
 \catcode13=5
 \iflastptxfile\closepiclist\fi
 \closeadjlist
 \catcode`\/=12
 \catcode`\#=6 \catcode`\%=14 % restore TeX meanings for those we might use
 \catcode`\{=1 \catcode`\}=2
 \catcode`+=\pl@scatcode % don't treat as letter any more
 \singlecolumn\pagebreak
 %\ifendbooknoeject\else\global\output={\global\setbox255=\box\voidb@x}\eject\xdef\p@gefirstmark{}\setbox\partial=\box\voidb@x\fi
 \ifendbooknoeject\else\global\output={\shipout\vbox{\box\partial\box255}}\eject\xdef\p@gefirstmark{}\setbox\partial=\box\voidb@x\fi
 \global\output={\onecol}
}
```

# Styles

Typesetting is nothing if text cannot be styled. The PTX macros have the
concepts of character styles, paragraph styles and note styles (for footnotes,
etc.). In addition styles may be stacked, thus a run of text in one character
style may be embedded in a run of another style, such that anything not
specifically defined in the inner style is interpreted as coming from the outer
style, which may in turn derive the information from an outer paragraph style.

A USFM text is marked up in terms of styled runs of text witch rules about how
runs are closed. Each run starts with a marker that sets up the style.
Internally in the PTX macros, each style marker has parameters associated with
it, e.g. `fontsize` which the macros can then query when they need to set such
things in the typesetting process.

There is also a fourth category of marker in USFM: a milestone. While milestones
may take parameters following them in text, they have are not opened and closed,
they simply do their thing when they occur and life continues after them. The
world may be a different place, but they do not create a new style environment
for anything to embed in, for example. Typical examples are `\c` and `\v`.

## Stylesheet

A core principle of character, paragraph and note styling, in the PTX macros is
the use of a stylesheet file, which, being in a SFM format, can simply be
executed as a special kind of TeX file. Stylesheets are executed and the
information in them is stored as parameters on a style marker. The core macros
for defining these use the `\csname` mechanism in TeX to construct a token and
then to define the value of the expansion of that token.

\\defp@ram: store the value of a parameter from the .sty file

-- ------
#1 name of parameter to store
#2 value
-- ------
Constructs a macro name \\_<marker>_:_<parameter>_ to hold the value.
`csname` is required here in order to build a macro name containing a colon and possibly a number.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="133"}
\def\defp@ram#1#2{\x@\def\csname\m@rker\ds@ffix:#1\endcsname{#2}}
\def\condp@ram#1#2#3{\edef\t@mp{#1}\ifx\t@mp\h@phen\relax\def\t@mp{#3}\else\def\t@mp{#2}\fi\t@mp}
\def\defbinp@ram#1#2{\edef\t@mp{#2}\ifx\t@mp\h@phen\defp@ram{#1}{false}\else\defp@ram{#1}{true}\fi}
\def\setp@ram#1#2#3{\x@\xdef\csname#2\ds@ffix:#1\endcsname{#3}} % expand now, not later 
```

The corresponding macro for looking up a parameter is, at its core, very simple.
But the additional needs of diglot processing, where a parameter value is
different depending on which side of the diglot is being processed, add to the
complexity:

\\getp@aram: fetch the value of a style parameter into \\p@ram

-- ------
#1 name of parameter to fetch
#2 name of marker
-- ------
Sets temporary macro \\p@ram to the value
The macro is diglot aware, allowing all parameters to have L Left/Right variant or use
default. (e.g when asked for parameter for v, check for vL|vR, default to v)

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="151"}
\def\getp@r@m#1#2{\x@\let\x@\p@ram\csname#2:#1\endcsname}
\def\getp@ram#1#2{\trace{Ds}{getp@ram #2:#1}%
\ifdiglot
  \ifdiglotL\getp@r@m{#1}{#2L}\else\getp@r@m{#1}{#2R}\fi
  \ifx\p@ram\relax
    \getp@r@m{#1}{#2}\trace{Ds}{...default -> \p@ram}%
  \else\trace{Ds}{...side-specfic -> \p@ram}%
  \fi
\else\getp@r@m{#1}{#2}%
\fi
\trace{s}{\space\space #2:#1 is \p@ram}%
}
```

Now we come to the long list of markers that can occur in stylesheet. We have to
support everything that is allowed to occur in a stylesheet. Unfortunately, if
an unknown marker occurs in a stylesheet, processing stops at that point in the
stylesheet and no further stylesheets will load. We define some key macros to
start with: The `\Marker` identifier starts the definition or additional
definition of a marker. We define a default empty font for the marker and just
collect the marker for use in all future definitions.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="40"}
\def\h@phen{-} % for matching
\def\ds@ffix{} % diglot suffix (L/R)
\def\m@rker{} % The currently being defined \Marker

% Remember the name of the marker currently being defined
\def \Marker         #1\relax{\def\m@rker{#1} % store name of marker currently being defined
                              \expandafter\let\csname font<#1>\endcsname\relax}
                              %\expandafter\let\csname extrafont<#1>\endcsname\relax}
```

Each marker follows a common pattern of skipping whitespace and capturing the
rest of the line, even if it is expected to be empty or the marker is being
ignored.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="51"}
% Make sure we list everything that can occur in a .sty file. If a .sty file contains a
% missing sfm marker, then processing for that and all subsequent stylesheets will stop
% at that point.
% Ignore stylesheet markers that do not affect formatting 
\def \Name           #1\relax{}
\def \Description    #1\relax{}
\def \OccursUnder    #1\relax{}
\let \Occursunder\OccursUnder
\def \Rank           #1\relax{}
\def \Underline      #1\relax{}
\let \underline\Underline
\def \NotRepeatable  #1\relax{}
\let \Notrepeatable\NotRepeatable
\def \Color          #1\relax{\defp@ram{color}{#1}}
\let \color\Color
\def \ColorName      #1\relax{}

% For each property that affects formatting, define a macro to store the value
% of this field, these will be accessed via getp@ram.
% Constructs a macro name \<marker>:<parameter> to hold the value
\def \Endmarker      #1\relax{\defp@ram{endmarker}{#1}} % endmarker is not currently checked
\def \TextType       #1\relax{\lowercase{\defp@ram{type}{#1}}}
\let \Texttype\TextType
\def \TextProperties #1\relax{\lowercase{\defp@ram{properties}{#1}}}
\let \Textproperties\TextProperties
\def \FontSize       #1\relax{\defp@ram{fontsize}{#1}}
\let \Fontsize\FontSize
\def \FontScale      #1\relax{\defp@ram{fontscale}{#1}}
\let \Fontscale\FontScale
\def \FontFactor     #1\relax{\defp@ram{fontfactor}{#1}}
\def \FontName       #1\relax{\defp@ram{fontname}{#1}}
\let \Fontname\FontName
\def \FirstLineIndent #1\relax{\defp@ram{firstindent}{#1}}
\let \Firstlineindent\FirstLineIndent
\def \LeftMargin     #1\relax{\defp@ram{leftmargin}{#1}}
\let \Leftmargin\LeftMargin
\def \RightMargin    #1\relax{\defp@ram{rightmargin}{#1}}
\let \Rightmargin\RightMargin
\def \Italic         #1\relax{\defbinp@ram{italic}{#1}}
\def \Bold           #1\relax{\defbinp@ram{bold}{#1}}
\def \Superscript    #1\relax{\condp@ram{#1}{\defp@ram{raise}{\SuperscriptRaise}\defp@ram{fontfactor}{\SuperscriptFactor}}{\defp@ram{raise}{0pt}\defp@ram{fontfactor}{1}}}
\def \Raise          #1\relax{\defp@ram{raise}{#1}}
\def \Regular        {\defp@ram{regular}{true}\defp@ram{italic}{false}\defp@ram{bold}{false}\defp@ram{superscript}{false}\defp@ram{smallcaps}{false}}
\let \superscript\Superscript
\def \SpaceBefore    #1\relax{\defp@ram{spacebefore}{#1}}
\let \Spacebefore\SpaceBefore
\def \SpaceAfter     #1\relax{\defp@ram{spaceafter}{#1}}
\let \Spaceafter\SpaceAfter
\def \Justification  #1\relax{\lowercase{\defp@ram{justification}{#1}}}
\def \CallerStyle    #1\relax{\defp@ram{callerstyle}{#1}} % ptx2pdf extension
\def \CallerRaise    #1\relax{\defp@ram{callerraise}{#1}}
\def \NoteCallerStyle    #1\relax{\defp@ram{notecallerstyle}{#1}} % ptx2pdf extension
\def \NoteCallerRaise    #1\relax{\defp@ram{notecallerraise}{#1}}
\def \NoteBlendInto      #1\relax{\defp@ram{notebase}{#1}}
\def \TEStyleName    #1\relax{} % Translation Editor extension
\def \SmallCaps      #1\relax{\defbinp@ram{smallcaps}{#1}}
\let \Smallcaps\SmallCaps
\def \BaseLine       #1\relax{\defp@ram{baseline}{#1}}
\def \LineSpacing    #1\relax{\defp@ram{baseline}{#1\FontSizeUnit}}
% Make a TeX macro based on the StyleType
\def \StyleType      #1\relax{\lowercase{\def\styl@type{#1}}\m@kestyle}     ①
\let \Styletype=\StyleType
% New extras that PTX supports
\def \XMLTag         #1\relax{}
\def \Encoding       #1\relax{}
\def \Rank           #1\relax{}
\def \TEStyleName    #1\relax{}
\def \NotRepeatble   #1\relax{}
\def \Attributes     #1\relax{}
```

The `StyleType` marker ❶ makes reference to `\m@kestyle` and is the way that
the PTX macros decide what kind of style this is: character, paragraph or note.
Each style type is processed very differently. `\message` is a TeX primitive
that outputs the contents to the console and log file but puts a space after
rather than a newline. We clear any font associated with the marker and then
call the type appropriate definition for the marker. In each case we create a
definition for the marker token that calls the appropriate style routine. In the
case of character styles we also create a handler for the emebdeed form of the
character style that is prefixed by `+`.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="200"}
\def\m@kestyle{{\uccode`\|=`\\\uppercase{\message{|\m@rker}}}
 \x@\let\csname font<\m@rker>\endcsname=\relax 
 \ifx\styl@type\P@ra \x@\defp@rstyle\x@{\m@rker}
 \else\ifx\styl@type\Ch@r \x@\defch@rstyle\x@{\m@rker}
 \else\ifx\styl@type\N@te \x@\defn@testyle\x@{\m@rker}
 \else \message{unknown style type \styl@type}
 \fi\fi\fi}
\def\P@ra{paragraph}
\def\Ch@r{character}
\def\N@te{note}
```

\\def*style: define a USFM marker as a paragraph, character or note style marker
which will expand to \\p@rstyle, \\ch@rstyle or \\n@testyle, with the marker name
as its parameter

\\csname...\\endcsname is used because the marker may contain numbers as well as letters

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="218"}
\def\defp@rstyle#1{\x@\def\csname#1\endcsname{\p@rstyle{#1}}}
\edef\pl@scatcode{\the\catcode`+}
\catcode`+=11
\def\defch@rstyle#1{\x@\def\csname#1\endcsname{\ch@rstyle{#1}}\x@\def\csname +#1\endcsname{\ch@rstylepls{#1}}}
\catcode`+=\pl@scatcode
\def\defn@testyle#1{\x@\def\csname#1\endcsname{\n@testyle{#1}}\m@ken@tecl@ss{#1}}
```

A stylesheet is read and processed line by line ❷. We start by ensuring digits
are treated as digits rather than letters. In general, in a USFM we don't treat
digits as numbers, but simply as text that is to be output. But here we need to
store digits as digits so that we can do numeric processing on them elsewhere in
the system. It is very hard to change the category of a token once it is set.
There are markers in the stylesheet
that correspond to various default font markers in the code. We need to store
those current values away and redefine the font marker tokens to stylesheet
routines, at least for the duration of reading a stylesheet. Next ❶ we open
the stylesheet file and turn on the 'keep reading' flag. But if the file is
empty or failed to open, we flag an error and don't read the file.

If the file
is good to go we inform the user and tell TeX not to add anything to the end of
each line read. USFM stylesheets use `#` as a comment character. We will do the
same for this file. This means we can't define any macros with parameters for
the moment, but that's fine because we don't want to.
Inside the read and process loop we read a line from the file ❷ and then do
that line. If the file is now at its end we clear the keep going flag and if we
are to keep going, we repeat the loop. Once the loop is completed we reset the
end of line insertion; close the file and get back `#` for macro definitions.

Finally, even if we don't read the file, we put back the saved tokens since we
don't need those routines outside of stylesheet reading.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="522"}
% \stylesheet{...} reads a Paratext stylesheet line by line
%
\newif\ifc@ntinue
\newread\styl@sheet
\def\stylesheet#1{
 \m@kedigitsother
 \let\save@regular=\regular \let\regular=\Regular
 \let\save@bold=\bold \let\bold=\Bold
 \let\save@italic=\italic \let\italic=\Italic
 \openin\styl@sheet="#1" \c@ntinuetrue                      ①
 \ifeof\styl@sheet\errmessage{Paratext stylesheet "#1" not found}\else
   \message{Reading Paratext stylesheet "#1"...}%
   \endlinechar=-1
   \catcode`\#=5 % paratext comment char
   \loop
    \read\styl@sheet to \th@line                            ②
    \th@line \relax
    \ifeof\styl@sheet \c@ntinuefalse \fi
    \ifc@ntinue\repeat
   \endlinechar=13
   \closein\styl@sheet
   \catcode`\#=6 % restore default TeX catcode
 \fi
 \let\regular=\save@regular
 \let\bold=\save@bold
 \let\italic=\save@italic
}
```

## Character Styles

The lowest level styling is character styling. Paragraph and note styling both
also require character styling. There are two kinds of character styles in USFM
that only differ in how they start and finish. Normal character styles may only
occur inside paragraph styles and when they start, they close any active
character styles. Embedded character styles may occur within other character
styles and are either closed by a closing marker or the start of a new normal
character style. Likewise normal character styles may be closed explicitly with
a closing marker or by the start of a new normal character styles. It is obvious
that a new paragraph style will close all open character and paragraph styles.

There are two entry points for character styles corresponding to their types. In
each case we need to capture whatever comes after the marker, whether it is a
`*`, which indicates a close marker or a space ` ` that indicates an opening
marker. We treat end of line as a space here. We set up the catcodes for space
and end of line and then capture the next token (which is immediately after the
marker) and store it in `\n@xt`. We can then call another macro to process the
result and that macro can use `\n@xt` to decide what to do.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="63"}
\def\ch@rstyle#1{\trace{s}{CH@RSTYLE:#1}%
 \gdef\newch@rstyle{\detokenize{#1}}% record the name of the style
 \catcode32=12 % make <space> an "other" character, so it won't be skipped by \futurelet
 \catcode13=12 % ditto for <return>
 \futurelet\n@xt\doch@rstyle % look at following character and call \doch@rstyle
}

%Version of above for plus versions
\def\ch@rstylepls#1{\leavevmode%Stacking character styles (at least in headers) seem to break paragraph styling if they are invoked before leaving vertical mode. It's something to do with grouping. On the assumption that there will *be* text coming, it ought to be safe to leave vertical mode on meeting a stacking character style
 \trace{s}{CH@RSTYLEPLS:#1}%
 \gdef\newch@rstyle{\detokenize{#1}}% record the name of the style
 \catcode32=12 % make <space> an "other" character, so it won't be skipped by \futurelet
 \catcode13=12 % ditto for <return>
 \futurelet\n@xt\doch@rstylepls % look at following character and call \doch@rstylepls
}
```

The following macros need to test for space and end of line (which in TeX is
stored as a carriage return character U+000D). But those are so necessary in
defining the macros that we can't just test for them. Instead we use a trick
that encapsulates the macro definitions in a `\lowercase`. TeX lowercases all
the `other` characters, but has already ignored all the whitespace characters in
collecting tokens, so now we can safely have whitespace tokens in the result. We
achieve this by specifying two other characters that map to space and carriage
return when lowercased, and then use those inside the `\lowercase`.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="81"}
\def\c@rrfontsize{12}
\catcode`\~=12 \lccode`\~=32 % we'll use \lowercase{~} when we need a category-12 space
\catcode`\_=12 \lccode`\_=13 % and \lowercase{_} for category-12 <return>
\lccode`\|=`\\
\lowercase{
```

The two types of character style macros ❶ are very similar as we track down the
two paths. We start by treating space and carriage return as space. Notice that
we don't treat carriage return as a carriage return because we don't want a
double line break to be considered a paragraph break. Instead we treat
everything as one very long line, until we get to the end of the character
style. Next we start testing `\n@xt` which contains the character after the
style marker. If it is `*` then call the end character style routine. Notice we
reuse `\n@xt` here. Otherwise we call an appropriate macro according to the type
of space following the marker. If there is no space, but somehow they have
managed to close of a marker some other way, we don't consume the character and
simply jump into the start character style routine itself. Notice that we can
now merge the paths and we differentiate later using the global macro
`\stylet@pe` to differentiate ❷. There are two macros that we call to consume
the space or carriage return before calling the start character style ❸.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="88"}
 \def\startch@rstyle@misc{\MSG{startch@rstyle@misc}\startch@rstyle \relax}%
 \def\doch@rstyle{% here, \n@xt has been \let to the next character after the marker    ①
  \catcode32=10 % reset <space> to act like a space again
  \catcode13=10 % and <return> is also a space (we don't want blank line -> \par)
  \if\n@xt*\let\n@xt@\endch@rstylen % check for "*", if so then we need to end the style
  \else\if\n@xt~\let\n@xt@\startch@rstyle@spc\else
      \if\n@xt_\let\n@xt@\startch@rstyle@nl\else\let\n@xt@\startch@rstyle@misc\fi\fi
    \end@llcharstyles % a char style closes all other char styles
  \fi % else we need to start it
  \xdef\stylet@pe{C}%                                                                   ②
  \n@xt@} % chain to the start or end macro
 % doch@rstylepls is like doch@rstyle, but wraps the style in a group and generates a comma-separated stack of styles.
 \def\doch@rstylepls{% here, \n@xt has been \let to the next character after the marker ①
  \catcode32=10 % reset <space> to act like a space again
  \catcode13=10 % and <return> is also a space (we don't want blank line -> \par)
  \if\n@xt*\let\n@xt\endch@rstylepls % check for "*", if so then we need to end the style
  \else\if\n@xt~\let\n@xt\startch@rstyle@spc
    \else\if\n@xt_\let\n@xt\startch@rstyle@nl
      \else\let\n@xt\startch@rstyle
    \fi\fi
  \fi % else we need to start it
  \xdef\stylet@pe{c}%                                                                   ②
  \n@xt} % chain to the start or end macro
 % when \startch@rstyle is called, the following <space> or <return> has become category-12
 % so we have to explicitly consume it here as part of the macro parameter list
 \def\startch@rstyle@spc~{\startch@rstyle}%                                             ③
 \def\startch@rstyle@nl_{\startch@rstyle}%
}
```

### Style Stack

Since character styles can embed inside each other, it is necessary to have a
stack of currently open styles. TeX doesn't have a stack or array type, so we
use strings instead. Stack items are separated by a comma `,` and are stored
with the top of the stack first in the string. Within each
item the two components are separated by a plus `+`. The first component is the
style type:

Type  Description
----- -----------
 c    Embedded character style
 C    Normal non emebded character style
 P    Paragraph style
 N    Note

The second component is the marker itself. Thus one might have a stack string of
`C+nd,c+ft,N+f,c+wj,P+p,+,` which says we are in an embedded `\nd` marker inside
a `\ft` inside a footnote that has been called from text within a `\wj`
character style inside a `\p` paragraph. Notice there is always an empty element
at the bottom of the stack to make processing easier.

We define quite a few macros to handle all this. First there are the generic
stack handling macros that work with any kind of stack and then there are the
macros we use specifically for working with the `mcstack` which contains the
style stack we are interested in. The good news is that TeX's parameter matching
capabilities make handling a stack relatively straightforward. The first three
macros are the core definition for a stack: pop, push, peek. The up and down
macros ❶ are for iterating through the stack either from bottom to top (up) or
top to bottom (down). They each call a predefined `\d@` macro. The top macro
calls `\d@` for just the item on the top of the stack. Notice that we don't use
`\n@xt` because too many other macros do and we don't want to clash with them.
The `\cstackrelax` is a macro that `\d@` can be set to to quit out of a stack
iteration early.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="500"}
% marker stack operations (mcst@ck)
\def\E{}
\def\cstackpop#1,#2\E{#2}
\def\cstackpush#1#2{#2,#1}
\def\cstackpeek#1,#2\E{#1}
\def\cstackup#1,#2\E{\edef\tmp{#2}\ifx\tmp\empty\let\n@x=\relax\else\let\n@x=\cstackup\fi\n@x #2\E\edef\tmp{#1}\ifx\tmp\empty\else\d@ #1\E\fi}                  ①
\def\cstackdown#1,#2\E{\edef\tmp{#1}\ifx\tmp\empty\else\d@ #1\E\fi\edef\tmp{#2}\ifx\tmp\empty\let\n@x=\relax\else\let\n@x=\cstackdown\fi\n@x #2\E}
\def\cstacktop#1,#2\E{\edef\temp{#1}\ifx\temp\empty\else\d@ #1\E\fi}
\def\cstackrelax#1\E{}
```

Now we use these macros to implement a concrete stack for styles. Using the
stack macros with a particular stack is just complicated enough to warrant its
own set of macros.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="512"}
\gdef\mcstack{+,}
\def\cstackempty{,}
\def\mcpop{\traceNum{s}{pop stack: \mcstack}\xdef\mcstack{\x@\cstackpop\mcstack\E}\ifx\mcstack\empty\xdef\mcstack{+,}\fi}
\def\mcpush#1{\traceNum{s}{push #1 onto \mcstack}\xdef\mcstack{#1,\mcstack}}
\def\mcup{\x@\cstackup\mcstack\E}
\def\mcdown{\x@\cstackdown\mcstack\E}
\def\mctop{\x@\cstacktop\mcstack\E}
```

This allows us to describe how starting a regular character style can close all
currently open character styles. `\end@allcharstyles` iterates the stack top
down calling the macro that tests whether that stack item is a character style.
Notice that the way the stack macros work, if the stack changes during
processing, the processing itself is not affected because the whole stack is
passed to the first macro and then the parameter list is chopped as it iterates,
with no further reference to the stack itself. Note also the use of
`\cstackrelax` once a non character style is encountered. This stops any more
iteration of the stack and potentially closing styles that should not be closed.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="196"}
\newif\ifskipch@rstyle
\newcount\n@tenesting \newcount\p@ranesting
\def\SuperscriptRaise{0.85ex} % note that this is in terms of the scaled-down superscript font size

%
% end all character styles in effect within the current note or paragraph
%
\def\end@llcharstyles{\let\d@=\end@llcharstyle\mcdown}
\def\end@llcharstyle#1+#2\E{\trace{s}{endcharstyles: #1+#2}\edef\tmp{#1}%
    \ifx\tmp\empty\else\if#1c\endch@rstyle*\else\if#1C\endch@rstyle*\else\let\d@=\cstackrelax\fi\fi\fi}
```

As an example of scanning a stack, `end@allcharstyles` is a good first example
and worth analysing. The `\mcdown`, `\mctop` and `\mcup` macros all use the
`\d@` macro to do their per item work. The use, therefore of the macros is one
of setting the `\d@` macro and calling the appropriate routine. The `\d@` is
then called with each item in turn. Since the style stack structures each item
as type `+` tag, we can use parameter pattern matching to break apart the
structure. When `\d@` is called, the stack macros append the item with `\E` as a
delimiting token to aid in pattern matching. Inside the macro we store the type
in a temporary macro to make testing it easier. String matching in TeX is a pain
and just deciding whether the value is empty (which happens with the bottom of
the stack which has an empty sentinal item) involves storing the value. We test
if it is empty, and ignore the item. If the type is `c` (for embedded character
style) then simply close the character style. We do the same for a normal type
`C` character style as well (since we are closing all character styles). If the
type is anything else, then we want to stop any further processing. We do this
be resetting the `\d@` macro to the `\cstackrelax` macro that simply does
nothing with the item.

The other key macros involving the stack are those for getting the current value
of a parameter. `getmcp@ram` and its corresponding `R` specific version for
diglots, starts at the bottom of the stack ❶ and sets the parameter each time a
style is encountered that sets that parameter. Well it's more complex than that
because it takes into account whether the item on the stack is a paragraph or
note style in which case the result is force reset. ❶ After running the stack, the
result is in a global `r@s` which is then stored in `p@ram` as the normal return
value from such macros.

There is also a macro for getting the value of a parameter if the top of stack
is of the given type, else looking back through the stack for a value. This is
like the `getmcp@ram` but allows the top of stack to trump the value, even if
none, if it is of the right type. And there is a diglot R version of the macro
too.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="166"}
%Main utility function for font parameters, stacking-styles aware
\def\getmcp@ram#1{\let\r@s=\relax
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else\if##1P\global\let\r@s\relax\else\if##1N\global\let\r@s\relax\fi\fi
    \getp@ram{#1}{##2}\ifx\p@ram\relax\else\global\let\r@s\p@ram\fi\fi}%
  \mcup\global\let\p@ram\r@s\traceNum{s}{param #1 for \mcstack\space is \p@ram}}    ①
\def\getmcp@ramR#1{\let\r@s\relax
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else\if##1P\global\let\r@s\relax\else\if##1N\global\let\r@s\relax\fi\fi
    \getp@ram{regular}{##2}\ifx\p@ram\relax\getp@ram{#1}{##2}\ifx\p@ram\relax\else\global\let\r@s\p@ram\fi
                           \else\global\let\r@s\relax\fi\fi}%
  \mcup\global\let\p@ram\r@s\traceNum{s}{paramR #1 for \mcstack\space is \p@ram}}
 
\def\getFp@ram#1#2{%
  \def\d@##1+##2\E{\edef\tmp{##2}\edef\tmpa{#2}\ifx\tmp\tmpa\getmcp@ram{#1}\else\getp@ram{#1}{#2}\fi}%
  \mctop}
\def\getFp@ramR#1#2{%
  \def\d@##1+##2\E{\edef\tmp{##2}\edef\tmpa{#2}\ifx\tmp\tmpa\getmcp@ramR{#1}\else\getp@ram{#1}{#2}\fi}%
  \mctop}
```

A more complex question is what is the current font size. This involves
considering the `fontscale` parameter as well as `fontsize`. ❸ Again we
iterate the stack from the bottom to the top. But for each item if it is a
parameter or note then get its fontsize. If undefined, default to 12. We say
everything is in pt just so we can deal with a dimension, but we will strip off
the pt later. If the item is a character style then get its fontscale ❶. If
the fontscale is not 1, then simply use it to multiply the current size ❷ Also
get the font size and if the fontsize is not set or is the same as the `p`
paragraph style (system default), then use the scale otherwise set the font
size. Then go round again until we have a final result.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="186"}
\def\getmcfonts@ze{\getp@ram{p}{fontsize}\ifx\p@ram\relax\edef\ps@ze{12}\else\edef\ps@ze{\p@ram}\fi
  \def\d@##1+##2\E{\edef\tmp{##2}\ifx\tmp\empty\else
      \dimen0=\c@rrfontsize pt\ifnum\if##1P 1\else\if##1N 1\else0\fi\fi =1
        \getp@ram{fontsize}{##2}\dimen0=\ifx\p@ram\relax 12\else\p@ram\fi pt%
      \else\getp@ram{fontscale}{##2}\edef\sc@le{\p@ram}%                            ①
        \ifx\p@ram\relax\edef\sc@le{1}\getp@ram{fontsize}{##2}%
          \ifnum\ifx\p@ram\relax 1\else\ifx\p@ram\ps@ze 1\else 0\fi\fi =1
            \dimen0=\sc@le\dimen0\else\dimen0=\p@ram pt\fi
        \else\dimen0=\sc@le\dimen0                                                  ②
    \fi\fi\xdef\c@rrfontsize{\strip@pt{\dimen0}}\trace{s}{\space working c@rrfontsize from ##2 is \c@rrfontsize}\fi}%
  \mcup\trace{s}{set c@rrfontsize for \mcstack\space is \c@rrfontsize}}             ③
```

### Processing Character Styles

Now that we have a style stack, we use it everywhere.

#### Start

On starting a new character style run, the first thing the routine does is to
push the new character style information on the style stack. It then tests
whether the style marker is marking text that is publishable. That is that we
actually want to output the text in this run. This involves seeing if the string
`nonpublishable` is in the properties parameter for this marker. This is done
using TeX's macro pattern matching. We get the parameter and then assemble a
string of the parameter value followed by `nonpublishable!`. Then we match for
`nonpublishable` and the sentinal `!`. If the parameter value has nonpublishable
in it, then that first nonpublishable will match the `nonpublishable` in the
macro parameter match and there will be something after that (at least the
`nonpublishable` we appended to the parameter) in `#2` and so the parameter
contained `nonpublishable` and we can set the flag, else there is nothing and we
don't se the flag. Phew!

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="234"}
% All types of marker use this to check for the "nonpublishable" property
\def\t@stpublishability#1{\n@npublishablefalse % check if "nonpublishable" occurred in the marker's \Properties
 \getp@ram{properties}{#1}%
 \x@\t@stnonpub\p@ram nonpublishable!}
\def\t@stnonpub #1nonpublishable#2!{%
 \def\t@st{#2}\ifx\t@st\empty\else\n@npublishabletrue\fi}
\newif\ifn@npublishable
```

Returning to starting a character style. If the text is not to be published ❶
we group it up into an hbox which we will dump later. But we don't have to do
anything regarding setting up any styling. We do start a new group, because all
character styles start a new group. While grouping is a way to handle a style
hierarchy, it doesn't allow interrogating of style information above us in the
groups. We also track the currently open style in the group.

❷ Normally we do want to publish the text and to do that we need to be in
horizontal mode, since this is character styling and not paragraph styling. If
there is a `before` hook for this style, we execute that. If we are in a diglot,
we set which side we are on and perhaps run a per side `before` hook. Then we
start the group that contains the character style. We set the current style and
then set the font for the style. Rather than take a long excursus into how a
font is set, we will address that later. There are various depth counters that
we update, which are hang overs from before we had a full style stack. We find
out whether this run is to be raised text. ❸ If it is then we need to collect
the text in a box that we can raise. This limits raised text because no line
breaks can occur within a raised text run.

Now that we are in the character style, we run the `start` hook if it is
present, and if in a diglot, set the side and run any side specific start hook.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="132"}
\def\startch@rstyle{\trace{s}{startch@rstyle \newch@rstyle}%
  \mcpush{\ifx\stylet@pe\empty C\else\stylet@pe\fi+\newch@rstyle}%
  \t@stpublishability{\newch@rstyle}\ifn@npublishable                   ①
   \setbox0=\hbox\bgroup\skipch@rstyletrue
   \let\thisch@rstyle=\newch@rstyle
  \else
   \leavevmode % in case the paragraph hasn't started yet               ②
   \csname before-\newch@rstyle\endcsname % execute any <before> hook
   \ifdiglot\setsid@ % \MSG{start-\thisch@rstyle\sid@}%
     \csname before-\newch@rstyle\sid@\endcsname\relax % handle side-specific <before> hook
   \fi
   \bgroup % start a group to encapsulate the style's formatting changes
    \let\thisch@rstyle=\newch@rstyle % remember the current style
    \s@tfont{\thisch@rstyle}% set up font attributes
    \ifnum\n@tenesting>0 \global\advance\n@tenesting by 1 % record nesting level in para or note
    \else \global\advance\p@ranesting by 1 \fi
    \getmcp@ram{raise}%
    \ifx\p@ram\relax\else \setbox0=\hbox\bgroup \fi                     ③
    \csname start-\thisch@rstyle\endcsname % execute any <start> hook
    \ifdiglot\setsid@ % \MSG{start-\thisch@rstyle\sid@}%
      \csname start-\thisch@rstyle\sid@\endcsname\relax % handle side-specific <start> hook
      %\ifx\tmp\relax\else\MSG{tmp: \tmp}\fi
    \fi
  \fi
}
```

#### End

There are two end
character style macros. The normal close macro has to close all open character
styles, while the plus close macro only needs to close the currently open
character style. Each routine starts by analysing the top item on the stack. The
normal routine tests that the top of stack contains a character style, while the
plus routine tests that the style is of the right name. If either test fails an
error is output and the actual work of closing the character style is not done.
Otherwise each routine passes off the work of closing the character style to a
common routine.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="119"}
\def\endch@rstylen*{%Consume the star..
  \trace{s}{endch@rstylen \newch@rstyle}%
  \def\d@##1+##2\E{\tempfalse\if ##1c\else\if ##1C\else\temptrue\fi\fi}\mctop
  \iftemp\MSG{Unexpected closing marker for no plus \newch@rstyle * on stack \mcstack. Ignoring}\else\endch@rstyle*\fi
}
\def\endch@rstylepls*{%Consume the star..
  \trace{s}{endch@rstylepls \newch@rstyle}%
  \def\d@##1+##2\E{\edef\tmp{\detokenize{##2}}\edef\tmq{\newch@rstyle}\tempfalse\ifx\tmp\tmq\else\temptrue\MSG{\tmp !=\tmq}\fi}\mctop
  \iftemp\MSG{Unexpected closing marker for plus +\newch@rstyle * on stack \mcstack. Ignoring}\else\endch@rstyle*\fi
}
```

The routine to handle ending character styles is encapsulated in a `\lowercase`
so that it can use a `\\` as a character in an error message. The first thing is
to collect the current character style from top of the style stack. Assuming it
is defined, if we are in a mode where we are skipping nonpublishable text,
simply close off that group, which then stops the collecting of data into the
hbox. And since we don't want to output the hbox, we need do nothing. Otherwise
we need to put things back to how they were before the character style started.
We start by doing any diglot side specific `end` hook, or a normal end hook.
Then we look to see if we were being raised. If we were then we end the group
that collects the data in the box and then raise that box by the amount of the
raise. _Do we need a better box than box0 here?_. ❶ Next we collect the `after`
hook so that we can run it outside the group for the character style. We also
collect any diglot side specific `after` hook. Then we update the nesting counts
and ❷ close the character style. Then we run the after hooks.

Finally regardless of whether the style was publishable or not, we pop the style
stack.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="160"}
\lccode`\|=`\\ % for printing backslash in error message
\lowercase{
 \def\endch@rstyle*{\TRACE{endch@rstyle}% consume the * that marked the SFM as ending a style
   \def\d@##1+##2\E{\xdef\thisch@rstyle{##2}}\mctop
   \trace{s}{endch@rstyle \thisch@rstyle\space from \newch@rstyle}%
   \ifx\thisch@rstyle\undefined
     \MSG{*** unmatched character style end-marker |\newch@rstyle*}%
   \else
    \ifskipch@rstyle\egroup\else%
     \ifdiglot\setsid@ % \MSG{end-\thisch@rstyle\sid@}%
       \csname end-\thisch@rstyle\sid@\endcsname % handle side-specific <start> hook
     \fi
     \csname end-\thisch@rstyle\endcsname % execute any <end> hook
     \getmcp@ramR{raise}%
     \ifx\p@ram\relax\else \egroup \raise\p@ram\box0 \fi
     \x@\global\x@\let\x@\n@xt % remember the <after> hook, if any, beyond the current group
     \csname after-\thisch@rstyle\endcsname                             ①
     \global\let\n@xtt=\relax%
     %\tracingassigns=1
     \ifdiglot%\MSG{end-\thisch@rstyle\sid@}%
       \x@\global\x@\let\x@\n@xtt% remember the <after> hook, if any, beyond the current group
       \csname after-\thisch@rstyle\sid@\endcsname % handle side-specific <start> hook
     \fi
     \ifnum\n@tenesting>0 \global\advance\n@tenesting by -1 % decrement nesting level
     \else \global\advance\p@ranesting by -1 \fi
     \egroup % end the style's group, so formatting reverts             ②
     \n@xtt % execute the <side-specific after> hook, if there was one
     \n@xt % execute the <after> hook, if there was one
    \fi
   \mcpop
   \fi
 }
}
```

### Setting the Font

TeX was written before the prevalence of scalable font technology. Therefore a
TeX font is created at a particular size and colour.

#### Colours

Processing the `color` style property is not simple. There are two ways of
describing a colour in USFM (apart from `\Colorname` which is not yet
supported). The first is with an `x` prefix as 6 hex digits, with each pair
giving a brightness for each of Red, Green and Blue. The other is as a decimal
that if in hex would have 6 digits, but here the pairs represent Blue, Green and
Red!

The entry point is the `\ParseColor` macro ❶ that takes a `color` property and
parses into a `r@s` result as a 6 digit hex RGB value. Parsing the `x` type is
easy. But the purely numeric value is more interesting. We call `colorhex` to do
the mathematics of shifting and adding values to get the right RGB decimal
value. Then we call the `hex` routine to convert a decimal number to hex. The
hex routine needs to pad the value to 6 digits with initial 0s.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="34"}
\def\hex#1{\count3=#1\relax%
  \edef\r@s{}\count1=0
  \loop%
    \count2=\count3 \divide\count2 by 16 \multiply\count2 by 16
    \advance\count3 by -\count2
    \ifnum\count3=0\edef\r@s{0\r@s}\else\ifnum\count3<10 \edef\r@s{\number\count3 \r@s}%
    \else\advance\count3 by -10 \edef\r@s{\ifcase\count3 A\or B\or C\or D\or E\or F\fi\r@s}\fi\fi%
    \divide\count2 by 16 \count3=\count2 \advance\count1 by 1
    \ifnum\count1<6\repeat%
  \count3=0 \count1=0 \count2=0
}

\def\colorhex#1{\count1=#1\divide\count1 by 256\multiply\count1 by 256
    \count2=#1\advance\count2 by -\count1 \multiply\count2 by 65536 % r << 16
    \count3=#1\divide\count3 by 65536 \multiply\count3 by 65536 % b << 16
    \advance\count1 by -\count3 \divide\count3 by 65536 % count1=g << 8, count3=b
    \advance\count3 by \count2 \advance\count3 by \count1%
    \hex{\count3}%
}

\def\ParseColor#1#2\end{\edef\t@mp{#1}\trace{F}{Color prefix is "#1"}%
    \if x\t@mp \edef\r@s{#2}\else\colorhex{#1#2}\fi}                                ①
```

A key macro needed in setting a font is giving it a name by which to reference
it. This is basically the style name along with the size of the text the style
is being used at. Since fonts are
instantiated at a particular size the size is included in the name. Taking the
top item from the stack we test to see if it is the same as passed to the macro.
If it is then get the font size for this run otherwise get the font size for the
marker passed in, defaulting it to 12. We could well be doing this within
another stack operation, so we keep and restore any old value for `d@`.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="219"}
\newif\ifColorFonts \ColorFontstrue
%
% Set up the font attributes for a given marker (used by all style types, not only char styles)
%
\let\SpaceStretchFactor=\empty %default, do-nothing value
\let\SpaceShrinkFactor=\empty %default, do-nothing value

\def\g@tfontname#1{%
 \ifdiglot\ifdiglotL\def\f@ntstyle{#1L}\def\sid@{L}\else\def\f@ntstyle{#1R}\def\sid@{R}\fi\else\def\f@ntstyle{#1}\def\sid@{-}\fi%
 \let\d@@=\d@
 \def\d@##1+##2\E{\edef\tmp{#1}\edef\tmpa{##2}\ifx\tmp\tmpa\getmcfonts@ze\else
                        \getp@ram{fontsize}{#1}\ifx\p@ram\relax\xdef\c@rrfontsize{12}%
                        \else\global\let\c@rrfontsize=\p@ram\fi\fi}%
 \mctop\let\d@=\d@@\edef\f@ntstyle{\f@ntstyle-\c@rrfontsize}}
```

Setting the font starts by getting a name for the font and set the side for
diglot. Fonts are cached by name and if there is no font for the given name then
we need to make one. We set up references to the main fonts, which are diglot
side specific, hence the references. We get the name of the font if there is one
for this style. If not then we work out which of the standard fonts to use based
on `Bold` and `Italic` settings for the style. ❶ We then look at the `smallcaps`
parameter and if present add the small caps feature to the font description. ❷ If
there is color for this style, then parse it and add a color attribute to the
font description. ❸ Next we calculate a size for this font. Starting with the
calculated fontsize for this style in its context. Then for superscript we use a
`fontfactor` parameter, which we multiply the calculated font size by. ❹ At this
point we have a sufficient description to instantiate the font. This is done
directly into the cache.

One thing we can do is to change the default space stretch and shrink factors
for this particular font. This allows the user to change the stretchiness of
spaces in this font. We do that by setting appropriate `fontdimen` values. ❺ Once
this is all completed, we simply instantiate the font from the cache, whether or
not we created a new cache entry. So for most cases where the font has already
been created, this runs pretty quickly.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="236"}
\def\s@tfont#1{%
 \g@tfontname{#1}%
 \ifdiglot\setLRspecific\fi % FIXME: Whether diglot or not, it might have been diglot before.
 \x@\ifx\csname font<\f@ntstyle>\endcsname \relax 
  \trace{s}{s@tfont font for #1 at \c@rrfontsize}%
  \trace{S}{Normal font for \sid@\space is \regular}%
  \let\regul@r=\regular
  \let\b@ld=\bold
  \let\it@lic=\italic
  \let\b@lditalic=\bolditalic
  \let\typef@ce=\regul@r
  \getFp@ram{fontname}{#1}% see if \FontName was specified in the stylesheet
  \ifx\p@ram\relax % if not, check the \Bold and \Italic properties
	  \getFp@ramR{bold}{#1}%
	  \ifx\p@ram\tru@
		\let\typef@ce=\b@ld
		\getFp@ramR{italic}{#1}%
		\ifx\p@ram\tru@ \let\typef@ce=\b@lditalic \fi
	  \else
		\getFp@ramR{italic}{#1}%
		\ifx\p@ram\tru@ \let\typef@ce=\it@lic \fi
	  \fi
  \else
    \edef\typef@ce{"\p@ram"}% use font name from the stylesheet
  \fi
  \getFp@ramR{smallcaps}{#1}%                                           ①
  \ifx\p@ram\tru@
    \edef\typef@ce{\typef@ce\SmallCapsSuffix}%
  \fi
  \getFp@ram{color}{#1}%                                                ②
  \ifColorFonts\ifx\p@ram\relax\else
    \ParseColor\p@ram\end\edef\typef@ce{\typef@ce :color=\r@s}%
  \fi\fi%
  \dimen0=\c@rrfontsize\FontSizeUnit                                    ③
  \getFp@ramR{fontfactor}{#1}% scale down by \SuperscriptFactor if superscripted style
  \ifx\p@ram\relax\else \dimen0=\p@ram\dimen0\fi
  %\edef\f@ntstyle{\f@ntstyle-\c@rrfontsize}%
  % create the font identifier for this style
  \trace{F}{font<\f@ntstyle>=\typef@ce\space at \the\dimen0}%
  \x@\global\x@\font
    \csname font<\f@ntstyle>\endcsname=\typef@ce\space at \the \dimen0  ④
  \ifx\SpaceStretchFactor\empty\else
    \dimen0=\SpaceStretchFactor\x@\x@\fontdimen2\csname font<\f@ntstyle>\endcsname
    \x@\x@\fontdimen3\csname font<\f@ntstyle>\endcsname=\dimen0
    \trace{F}{Font \f@ntstyle, space stretch \the\dimen0}%
  \fi
  \ifx\SpaceShrinkFactor\empty\else
    \dimen0=\SpaceShrinkFactor\x@\x@\fontdimen2\csname font<\f@ntstyle>\endcsname
    \x@\x@\fontdimen4\csname font<\f@ntstyle>\endcsname=\dimen0
    \trace{F}{Font \f@ntstyle, space shrink \the\dimen0}%
  \fi
 \fi
 % switch to the appropriate font
 \csname font<\f@ntstyle>\endcsname                                     ⑤
}
```

In many texts, there are extra characters in the text that are not in the main
body text font. For these we want to switch to a different font just for that
character. We use an _extra font_ for this. The font instantiation is simpler
than for a main font, but it still involves a cache and the creation of a font
description.

\fileheader{ptx-char-style.tex}
```{.latex .numberLines startFrom="294"}
\def\extraregular{"Times New Roman"}
\def\s@textrafont#1{%
  \ifcsname extrafont<#1>\endcsname\else
    \let\typef@ce=\extraregular
    \getmcfonts@ze
    \dimen0=\c@rrfontsize\FontSizeUnit
    \getmcp@ramR{fontfactor}% scale down by \SuperscriptFactor if superscripted style
    \ifx\p@ram\relax\else \multiply\dimen0 by \p@ram\fi
    \x@\global\x@\font\csname extrafont<#1>\endcsname=\typef@ce\space at \dimen0
    \trace{s}{define extrafont<#1> \typef@ce\space at \the\dimen0}%
  \fi
  \trace{s}{extrafont<#1> =\csname extrafont<#1>\endcsname}%
  \csname extrafont<#1>\endcsname
}
\def\tru@{true}
\def\SuperscriptFactor{0.75}
\def\SmallCapsSuffix{/ICU:+smcp}
```

## Paragraph Styles

One of the characteristics of Bible typesetting is that the resulting book is
long and so is often printed on thin paper. This results in visual bleed through
of text from one side of the paper to the other. To maximise contrast, it is
best if text on one side is in the same place as text on the other side of the
page. Thus between line space on each side aligns and remains white rather than
turning grey. To achieve this _backing up_, text is typeset on a grid. The PTX
macros work hard to maintain this grid wherever possible.

Paragraphs in the PTX macros are grouped into a title block, headings blocks,
intro paragraphs and
body paragraphs. The blocks are groups of paragraphs that are then spaced in
order to keep the following body paragraphs on the grid.

Starting at the top, a paragraph style marker calls the `\p@rstyle` routine with
the marker tag. The start of a new paragraph implicitly ends a previous
paragraph. The first part of handling a paragraph marker, therefore, is closing
the previous paragraph. As with character styles, a marker may be marked
`nonpublishable` and the contents will be grouped into a box and dumped. If the
user has specified any parstylehooks, these are executed here just before the
end of the paragraph. Only empty paragraphs do not finish in horizontal mode. We
undo any paragraph final space and then close off all open character styles.

❶ We write out the current position on the page to a `.parlocs` file. This
file is used to work out whether the layout has changed significantly between
runs. Notice that the position is not written immediately. A `\write` command
actually stores a _whatsit_ in the page. This zero sized item is generally
ignored until the page containing it is shipped out. When the item reaches the
point of being written to the output file, it is executed. At that point the
`\pdflastposx`, etc. are expanded (and known) and the actual position on the
page is output to the `.parlocs` file.

Now we finish the paragraph. Calling `\par` involves more than having TeX finish
the paragraph. We will examine that in a moment. After closing the paragraph, we
look at the depth of the last line. If it is above 0pt, we collect it, else we
set the collection to an impossible value.

❷ If we are in a paragraph that includes a dropped chapter number in the
middle (from `\nb`) then we need to store the number of lines in the paragraph.
We do that in `.parlocs` file using a `\write` as in ❶. But we need to expand
the `\prevgraf` at this point and not have its expansion delayed until shipping
time. This is done by a chain of expandafter commands. Each expandafter first
expands another expandafter all the way to the `\the\prevgraf` which gets
expanded, and then the rest of the tokens are unwound and the `write` executed.

If there is only one line in the paragraph, that isn't enough to hold a dropped
chapter number, which needs 2 lines and so we inhibit any page break at this
point and tell the next paragraph it has a dropped chapter number to include.
Otherwise we clear the flag.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="233"}
\newif\ifhe@dingstyle
\newif\ifnsp@cebefore
\newif\ifJustifyPars \JustifyParstrue
\newdimen\lastdepth
\def\p@rstyle#1{\trace{s}{p@rstyle: #1}%
 \ifsk@pping \egroup \fi % if we were skipping nonpublishable text, end that mode
 \the\p@rstylehooks % allow other modules to hook in here
 \ifhmode\unskip % remove any trailing space
   \end@llcharstyles % end any character styles in effect
   \beginL\pdfsavepos
   \write\p@rlocs{\noexpand\@parend{\the\pdflastxpos}{\the\pdflastypos}}\endL       ①
   %\ifnum\pagetracing>0\tracingparagraphs=1\ifnum\pagetracing>1\looseness=-1%\emergencystretch=1sp
   %  \fi\else\tolerance=10\fi
   \par % end the paragraph
   \ifdim\prevdepth>0pt\lastdepth=\prevdepth\else\lastdepth=-1pt\fi
   \ifnum\pagetracing>0\tracingparagraphs=0\fi
   \ifdr@ppednumber % the preceding par had a dropped number;                       ②
                    % add \nobreak if it was a single line, else clear the flag
     \x@\write\x@\p@rlocs\x@{\x@\noexpand\x@\@parlines\x@{\the\prevgraf}}%
     \ifnum\prevgraf=1 \nobreak \else \dr@ppednumberfalse \fi
   \fi
 \fi
```

What happens when `\par` is executed? Before we actually close the paragraph, we
adjust its parshape to include any cutouts. How cutouts work is delayed to
(here)[#cutouts]. We then call any `end` hooks for the marker, be they for the
diglot side or more generally. Now we can finally close off the paragraph.

The first thing we need to do in the next paragraph is carry over any remaining
cutout from the previous paragraph. For example, if the just closed paragraph
was only one line long, then we need to carry over one line of cutout to the
next paragraph. Finally if there are any post paragraph pictures, we should
output those. See (Figures)[#figures] for more details.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="167"}
% end a paragraph, handling cutouts (shaping around drop-cap) if any, and the <end> hook
\def\par{\ifhmode
   \makecutouts
   \ifdiglot\setsid@%\MSG{end-\m@rker\sid@}%
     \csname end-\m@rker\sid@\endcsname % handle side-specific <end> hook
   \fi
   \csname end-\m@rker\endcsname
   \trace{j}{baselineskip = \the\baselineskip, looseness = \the\looseness}%
   \endgraf
   \cutoutcarryover 
 \fi
 \do@ndofthispar
}
```

Meanwhile, back in `\p@rstyle` we are ready to start the new paragraph. We first
need to find out whether text in this style is publishable. If it is not then we
break the paragraph now, because it will be empty when the next paragraph starts
and so will not be in horizontal mode and so will not close the paragraph
normally. Then we start a new box to place the contents of the paragraph. The
minimum needed is to set the current paragraph marker and indicate that we are
skipping.

The rest of this massive routine is treated as the else to this question of
publishability. If the text is publishable, then we have a lot of work to do.
While the paragraph has been closed by TeX, we are still processing the old
paragraph. We first need to see if there is any space to insert below the
previous paragraph. If so, then if we are in a heading block then do not allow a
page break at this point. Headings stick together and to their following
paragraph. ❶ Then we insert the space.

Next we reset the paragraph style to its defaults. This is a relatively
straightforward routine. It resets the left and right and parfill skips and the
paragraph indent, ready for being set for the new paragraph.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="695"}
\def\resetp@rstyle{%
 \leftskip=0pt \rightskip=\leftskip
% \dimen0=\hsize \advance\dimen0 by -4em \parfillskip=2em plus \dimen0 minus 1em
 \parfillskip=0pt plus 1fil
 %\emergencystretch=11in
 \parindent=0pt }
```

The next step is to pop the style stack ready to start the new paragraph. But
first we check that the top of stack does indeed correspond to the paragraph we
are closing. Then we pop the stack ❷. Next we run any `after` hooks for the
marker we are closing. And finally we are done with the old paragraph.

We store the new marker as the current paragraph marker and we push it onto the
style stack. Then we run any `before` hooks for this new marker.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="257"}
 \t@stpublishability{#1}% test if the new marker is nonpublishable
 \ifn@npublishable
  \par % End the present paragraph, to make sure that cutouts, etc. are handled properly
  \setbox\j@nkbox=\vbox\bgroup\def\m@rker{#1}\sk@ppingtrue % and if so, start a box to consume and discard the text
 \else % else we need to actually process it!
  \getp@ram{spaceafter}{\m@rker}% output any <spaceafter> for the previous style
  \ifx\p@ram\relax \else
    \ifhe@dings\nobreak\fi
    \vskip\p@ram\verticalsp@ceunit                                              ①
  \fi
  \resetp@rstyle
  \def\d@##1+##2\E{\edef\tmp{##2}%
    \ifx\tmp\m@rker\else\ifx\m@rker\relax\else\MSG{Bad closing "marker" \tmp\space expecting "\m@rker"}\fi\fi}%
  \mctop \mcpop                                                                 ②
  \ifdiglot\setsid@ % \MSG{start-\thisch@rstyle\sid@}%
    \csname after-\m@rker\sid@\endcsname\relax% handle side-specific <start> hook
  \fi
  \csname after-\m@rker\endcsname % handle <after> hook for the previous style
  \gdef\m@rker{#1}% remember the new style name
  \mcpush{P+#1}%
  \csname before-\m@rker\endcsname % handle its <before> hook
  \ifdiglot
    \csname before-\m@rker\sid@\endcsname\relax % handle side-specific <start> hook
  \fi
```

But we are not done with the old paragraph quite yet. We need to work out if
there is a transition between blocks. E.g. from a heading block to normal body
text paragraphs. We start by testing to see if we are starting an intro
paragraph.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="44"}
\def\t@stintro#1#2\relax{\if#1i\global\@ntromarkertrue\else\global\@ntromarkerfalse\fi}
```

Also if we are in a table and that table is in the context of an introduction
then we are also an intro paragraph. The next step is to use the `type`
parameter of our marker to work out what type of paragraph we are. We clear the
`he@dingstyle` flag to its default and look up the type of the paragraph and for
each type we do what needs to be done. If it is `title` then set the reference
mark to the sentinal `title` to indicate that we are on a title page and not to
output headers and footers. This also applies to diglot marks. If we are not in
a title block already but we are in a headings block, then finish the headings
block. Now start a title block (which does nothing if we are already in a title
block) and set that we are in a title block.

❶ If, on the other hand, this is a `section` type headings paragraph then if
we are in a title headings block then we need to close that to start a new
headings block. If we are an introductory text marker as well as being a
heading, then perhaps start the introductory text (from the title block),
otherwise we are a body text heading and so we may need to start body text. Then
we set the flag to say we are in a heading style. For body text type markers, we
treat paragraphs of type `other` as headings. In introductory text they are
normal introductory text markers. If the paragraph type is anything else then if
it is an introductory marker then make sure we are introductory text else make
sure we are in body text.

❷ Now that we have set the major mode of text we are in (title, intro, body),
we can deal with headings. If we are starting a heading style paragraph then are
we already in a headings block. If so, set the baselineskip for the new style,
but other than that do nothing. Just keep going. On the other hand, if we are
not in headings block, we better start one.

At the start of a new headings block, we collect the space before the first
paragraph (this paragraph) so that we can make sure the space is removed at the
top of a column. Although in titles we don't remove any space at the top of a
page because titles always come at the top of a page and we want all that lovely
whitespace to make the title heading stand out. Then we start a new headings box
to collect the paragraphs in. Then we set the baselineskip for the marker and
make it impossible to break a page inside a headings block. We also turn off
line breaking at hyphens. People should not be writing books in heading blocks!
Finally we say "no page break here".

If, though, this is not a heading style paragraph and we are in a headings block
then we need to end the headings block. We cover this in (Gridding)[#gridding].

Now we can insert the before space for a paragraph. If there is before space
then if we are in a heading then don't break. If we are not the first paragraph
in a headings block then `nsp@cebefore` will be true. In this case we don't want
to add any extra space to pull such paragraphs apart. The space above in this
context is implicitly saying: only space above for the first heading in a block.
Unless the space above is negative. Then the implicit assumption is that we only
want the space above to act if the the paragraph is not the first, because we
want to pull lines closer together when grouped. Mind you since we are using the
default here, we do allow initial paragraphs to have negative space before, just like
we do for non heading styles.

And so we come to the start of the paragraph. Finally!

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="287"}
  \x@\t@stintro\m@rker\relax
  % \tr is treated as an intro marker if we're already in intro mode
  \if@tablerow\if@ntro\@ntromarkertrue\fi\fi
  \global\he@dingstylefalse
  \getp@ram{type}{\m@rker}%
  \ifx\p@ram\t@tle
    \mark{\t@tle}\ifdiglot\ifdiglotL\marks1{\t@tle}\else\marks2{\t@tle}\fi\fi
    \ift@tle\else\ifhe@dings\endhe@dings\fi\fi
    \st@rttitle
    \global\he@dingstyletrue 
  \else\ifx\p@ram\s@ction                                                       ①
    \ift@tle\ifhe@dings\endhe@dings\fi\fi
    \if@ntromarker\st@rtintro\else\st@rtbody\fi
    \global\he@dingstyletrue
  \else\ifx\p@ram\oth@r
    \ift@tle\ifhe@dings\endhe@dings\fi\fi
    \if@ntromarker\st@rtintro\else\st@rtbody\fi
    \if@ntromarker\else\global\he@dingstyletrue\fi
  \else
    \if@ntromarker\st@rtintro\else\st@rtbody\fi
  \fi\fi\fi                                                                     ②
  \ifhe@dingstyle\TRACE{headingstyle true}%
    \ifhe@dings\nsp@cebeforetrue\s@tbaseline{\m@rker}%In a heading again, may be different so set a new baseline
      \else
        % Headingtopspace gets removed at top of page, preserve for titles.
        \getp@ram{spacebefore}{\m@rker}\ifx\p@ram\relax\xdef\headingtopspace{0}\else
          \ift@tle\xdef\headingtopspace{0}\else\xdef\headingtopspace{\p@ram}\fi\fi
        \setbox\he@dingbox=\vbox\bgroup\global\he@dingstrue
        \s@tbaseline{\m@rker}% Obey baseline changes for headings
        \linepenalty=1000 % minimize line count
        \interlinepenalty=10000 % never break column/page between lines
        \XeTeXdashbreakstate=0 % mainly for ranges in \r
        \hyphenpenalty=10000 \exhyphenpenalty=10000 % don't hyphenate in headings
    \fi
    \nobreak
  \else\TRACE{headingstyle false}%
    \ifhe@dings\endhe@dings\fi
  \fi
  \getp@ram{spacebefore}{\m@rker}% output <spacebefore> for this style
  \ifx\p@ram\relax \else
    \ifhe@dings\nobreak\fi
    \ifnsp@cebefore\nsp@cebeforefalse
      \ifnum\p@ram<0\vskip\p@ram\verticalsp@ceunit\fi
    \else\vskip\p@ram\verticalsp@ceunit\fi
  \fi
  \global\startparatrue
```

There are a number of routines, referenced above, to describe before we continue.
Each of the paragraph modes needs to switch to the appropriate number of
columns. For each mode start we first test to see if we are already in that
mode. If we are not, then if we are not creating a diglot, we test to see if twe
have to change the number of columns and if so we call the appropriate column
switching routine. These are described in the Output Routines chapter. Then we
set the flag for the mode. In the case of starting the body text then we also
suggest that this is a good place to break a page and we insert a blank line
before the main body text starts.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="48"}
% start title/intro/body, if not already in that mode, switching columns if needed
\def\st@rtintro{\TRACE{st@rtintro}\if@ntro\else
  \ifdiglot\else
    \ifnum\IntroColumns=\c@rrentcols\else
      \ifnum\IntroColumns=2 \doublecolumns\else\singlecolumn\fi
    \fi
  \fi
  \global\@ntrotrue\global\t@tlefalse\global\b@dyfalse\fi}

\def\st@rttitle{\TRACE{st@rttitle}\ift@tle\else
  \ifdiglot\else 
    \ifnum\TitleColumns=\c@rrentcols\else
      \ifnum\TitleColumns=2 \doublecolumns\else\singlecolumn\fi
    \fi
  \fi
  \global\t@tletrue\global\@ntrofalse\global\b@dyfalse\fi}

\def\st@rtbody{%\endhe@dings
  \ifb@dy\else\TRACE{st@rtbody}%
  \ifdiglot\else
    \ifnum\BodyColumns=\c@rrentcols
      \penalty-200\vskip\baselineskip
    \else
      \ifdiglot\diglotcolumns\else
      \ifnum\BodyColumns=2 \doublecolumns\else\singlecolumn\fi\fi
    \fi
  \fi
  \global\b@dytrue\global\@ntrofalse\global\t@tlefalse\fi}

\newcount\c@rrentcols \global\c@rrentcols=1
```


### Gridding

Heading blocks often involve text of different sizes and baselines and so takes
the text off grid. We group all this off grid text into a block and then insert
space above the block to ensure that body text following the block is back on
grid.

Following closing any paragraph, ending headings may involve cutouts (_why?!_)
Thus we make any needed and close the paragraph and close the box containing the
headings. Next we reset line spacing to that for the default `\p` styling and
then call the routine to expand the box to be an integral number of lines tall.
The resulting box is output and we reset the various flags associated with
headings.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="84"}
\newif\ifhe@dings
\newbox\he@dingbox
\def\endhe@dings{\ifhe@dings\TRACE{endhe@dings}%
  \makecutouts \endgraf
  \egroup \cutoutcarryover
%{\showboxbreadth=200 \showbox\he@dingbox}
  \s@tbaseline{p}%
  \gridb@x\he@dingbox\unvbox\he@dingnotes
  \global\he@dingsfalse
  \global\first@fterheadingtrue
 \fi
}
\newif\iffirst@fterheading
```

There are two `gridb@x` routines. The first is the earliest gridding function
and does not remove space at the top of a page. Both functions use the
`\killd@scenders` routine. This removes any depth from the last line in the box.
This is a bit of an undertaking. We unpack the box and get hold of any final
skip and the final penalty so that we can put them back afterwards. Then we get
the lastbox and its depth. We then clear the depth of that box and reassemble
the box by putting back the adapted box, any penalty and final skip. All this is
bundled into the returned vbox.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="100"}
\def\killd@scenders#1{%
  \vbox{\unvbox#1 \skip0=\lastskip\unskip \count255=\lastpenalty\unpenalty
    \setbox0=\lastbox\dimen4=\dp0  % Remember last box's depth
    \ifvoid0\else\dp0=0pt \box0 \fi
    \ifdim\skip0>0pt \penalty\count255 \vskip\skip0 \fi}}
```

The first gridbox routine works by inserting just enough blank lines to cover
the box and then overlays the headings box over that, thus extending the box
upwards by enough space to get the next paragraph back on the grid. We start by
collecting the box. If this is a picture box then we insert a little extra
border space. Next we measure the box for its height and
depth and start another dimension that will increase until it surpasses the
measurement. If this is a picture we insert an extra blank line. This is because
by default the starting point of the cursor is one line below the bottom of the
previous paragraph due to the start of a new paragraph and its baselineskip. But
a picture is not in the main text and so the cursor starts one line up and we
need to insert a line to compensate.

❶ Now we start the main loop and while our increasing dimension is smaller
than the box size we insert lines. Each time we insert line, we also insert a
penalty to stop any page breaking. Once we have enough lines inserted, we create
a box that first inserts
a kern to shift us back up to the top of the headings box (which isn't back to
where we started) and then expand the headings box. Finally we insert that box
and stop any page break after it.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="111"}
\def\gr@db@x#1{%
% \setbox0=\vbox{\kern-#1pt\vrule\kern#1pt\kern-.4pt\box#1\kern-.4pt\vrule}%
\setbox0=\ifgridp@c\vbox{\box#1}\else\killd@scenders#1\fi%
\trace{h}{before gridbox: ht0=\the\ht0; dp0=\the\dp0 (dp was \the\dimen4)}%
%\MSG{after killd: ht0=\the\ht0; dp0=\the\dp0}
%{\showboxbreadth=100 \showboxdepth=10 \showbox0 }%
 \dimen2=\ht0 \advance\dimen2 by \dp0
 %\dimen0=\ifnum\@djustment>0 -\baselineskip\else0pt\fi
 \dimen0=0pt
 \ifgridp@c\line{}\nobreak\fi % otherwise first \line in loop won't get any baselineskip
                              % when doing a picture box, because it's not part of the
                              % current page
 \loop \ifdim\dimen0<\dimen2                                                    ①
   \advance\dimen0 by \baselineskip
   \line{}\nobreak \repeat
 \setbox0=\vbox to 0pt{\kern-\ht0\unvbox0}%
 \trace{h}{after gridbox: dimen0=\the\dimen0; dp0=\the\dp0}%
 \unvbox0 \nobreak
}
\newif\ifgridp@c % if applying \gridb@x to a picture box rather than headings
```

The second gridbox routine is the default routine ❷ and there is a control
that is used once to set the gridbox routine.

There is a mathematical macro whose job is to calculate how much space we would
need to add to a dimension to give a result that is an integral number of
another dimension. The macro relies on integer mathematics to do its job. Thus
we divide the input by the gridsize and then multiply it again to bring it down
to a integral number of gridlines. Then we subtract that result from the
original value. Finally we add that to the gridsize and return the result.

The approach this gridding box uses to have a different amount of space at the
top of a page than within the page is to remember that TeX removes any initial
vskip at the start of a page. Thus we want to have an initial vskip which is the
difference between the gridded height of the box at the top of a page and the
gridded height of a box within a page.

TeX remembers the depth of the previous box output and sets the inter line
spacing based on that and the baselineskip. But we don't want to set the space
to the baseline of the first line after the headings box based on that. We the
adjustment set to 0. But we have captured the depth of the last line of the
previous paragraph in `\lastdepth` so we can use it later. Here we tell TeX to
pretend that the last paragraph had a depth of 0.

Next we set a box to either the box or the box without
descenders. Then we set the baseline for the default paragraph style. We now
take the height of the box and the baseline for the grid size and calculate how
much to add to its height and store that (in `dimen2`). This is the space to
allocate when not at the top of a page. Now we do the same thing again but
this time we reduce the height of the box by the headingtopspace. I.e. we want
the space to allocate at the top of a page. We subtract the adjustment from the
main box adjustment. Now `dimen2` holds the main box adjustment minus the top of
page adjustment. We now add the headingtopspace to that and that gives us how
much space we want when not at the top of a page, and so in out initial vksip.
We also have the grid adjustment for within the page, in `dimen0`. ❶
If we are not a picture box, we also need to remove any depth from the text
above. Since we are only interested in this mid page we want that adjustment to
disappear at the top of a page so we reduce the space by that depth.

Now we output the calculated values. If we are in a diglot, we don't want the
top space skipped, so we use a kern rather than a skip for the initial space.
Then we kern by the mid page grid adjustment. Since we have added the
headingtopspace to the initial space, we need to remove it from the contents of
the box, we undo the skip by skipping by its negative and then comes the heading
box, in which the first item will be the headingtopspace (net result 0). Finally
we inhibit page breaking after the heading box, and we are done.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="134"}
% returns in \dimen0 how much to advance \dimen1 to be an integral multiple of \dimen0
\def\m@d{\dimen3=\dimen1\divide\dimen1\dimen0\multiply\dimen1\dimen0\advance\dimen3 by -\dimen1\advance\dimen0 by -\dimen3}

\def\gr@db@@x#1{%
  \ifhmode\endgraf\fi % Not sure why, but sometimes we get here in hmode
  \prevdepth=0pt
  \setbox0=\ifgridp@c\vbox{\box#1}\else\killd@scenders#1\fi
  \trace{h}{before gridbox: ht0=\the\ht0; dp0=\the\dp0 (\the\dimen4); spacebefore=\headingtopspace*\the\verticalsp@ceunit; depth=\the\lastdepth}%
  \s@tbaseline{p}\dimen1=\ht0 \dimen0=\baselineskip \m@d \dimen2=\dimen0 % dimen2 is grid space
  \dimen1=\ht0 \advance\dimen1 by -\headingtopspace \verticalsp@ceunit
  \dimen0=\baselineskip \m@d \advance\dimen2 by -\dimen0
  \advance\dimen2 by \headingtopspace\verticalsp@ceunit                         ①
  \ifgridp@c\else
    \ifdim\lastdepth>0pt\advance\dimen2 by -\lastdepth\fi
  \fi
  \ifdiglot\kern\else\vskip\fi\dimen2
  \vbox{\kern\dimen0\vskip-\headingtopspace\verticalsp@ceunit
    \trace{h}{after gridbox: skip \the\dimen2, kern \the\dimen0; baselineskip=\the\baselineskip}%
    \unvbox0}\nobreak
}

\newif\ifsquashgridbox\squashgridboxtrue                                        ②
\let\gridb@x\gr@db@@x % overridden during \ptxfile setup, depending on \ifdiglot and \ifsquashgridbox 
```

### Every Paragraph

The next part of the paragraph style routine is to specify what will happen when
the first characters appear in the paragraph. We delay because we want all the
character styling setup to be done, etc. So we declare a routine at this point
that TeX will call when switching into horizontal mode.

If there are any `\addtoeveryparhooks` and there are some core ones (See
adjustments and table of contents), run those hooks now. `\pdfsavepos` tells
XeTeX to save the current position (the start of the paragraph) so that it can
be accessed later via `\pdflastposx`, etc. And we also write out the position we
just saved, when the paragraph is finally shipped out. The next step is to work
out what the right and left skips are. These are the skips that are inserted at
the left and right of each line when the paragraph is completed. For right to
left text, everything is swapped. The default is 0pt on either side to give
fully justified text. If the user has chosen ragged right (or non justified
paragraphs) then the appropriate end line skip is set to allow up to $1/4$ of a
column width of rag.

Based on the `justification` parameter for the paragraph style we now set the,
in effect, start and end of line skips. For centered text we set both skips to
be stretchy glue up to a column width each. For left justified we set the right
skip to stretch up to $1/4$ column. And if this is right to left then do not add
any extra stretch to after the end of a paragraph. Likewise the opposite for
right justified text.

Now we get the margins for the paragraph ❶. They are used to increase the
appropriate side skips by a fixed amount. We also set up some of the basic
character styling by setting the font for this marker. We assume this is a
normal paragraph and we allow normal paragraph indentation. That may not hold to
the end of the setting up this paragraph. More setting up calls for a PDF
outline bookmark if we have changed book (which is unlikely), and getting 
the first line indent for the paragraph.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="335"}
  \everypar={%
   %
   % \everypar will be triggered when the paragraph actually starts (normally at the first character of text,
   % or something like a verse number); then we'll set up margins/indents and font
   %
   \the\@veryparhooks
   \beginL\pdfsavepos
   \write\p@rlocs{\noexpand\@parstart{\the\pdflastxpos}{\the\pdflastypos}}\endL
   \ifRTL \rightskip\else\leftskip\fi =0pt
   \ifRTL \beginR \leftskip\else\rightskip\fi =0pt \ifJustifyPars\else plus .25\hsize\fi
   \getp@ram{justification}{\m@rker}%
   \ifx\p@ram\c@nter
    \leftskip=0pt plus \hsize \rightskip=\leftskip \parfillskip=0pt
   \else\ifx\p@ram\l@ft
    \rightskip=0pt plus .25\hsize \ifRTL\parfillskip=0pt\fi
   \else\ifx\p@ram\r@ght
    \leftskip=0pt plus .25\hsize \ifRTL\else\parfillskip=0pt\fi
   \fi\fi\fi
   \getp@ram{leftmargin}{\m@rker}%                                              ①
   \ifx\p@ram\relax \else \advance \ifRTL\rightskip\else\leftskip\fi\p@ram \IndentUnit \fi
   \getp@ram{rightmargin}{\m@rker}%
   \ifx\p@ram\relax \else \advance \ifRTL\leftskip\else\rightskip\fi\p@ram \IndentUnit \fi
   \trace{s}{\m@rker\ifdiglot\ifdiglotL L \else R\fi\fi\space iu=\the\IndentUnit, ls=\the\leftskip, rs=\the\rightskip}%
   %\getp@ram{fontsize}{\m@rker}\edef\c@rrfontsize{\ifx\p@ram\relax12\else\p@ram\fi}%
   \s@tfont{\m@rker}%
   \trace{j}{baselineskip=\the\baselineskip ; UseGlyphMetrics=\the\XeTeXuseglyphmetrics}%
   \allowp@rindenttrue
   %
   % Generate top-level PDF bookmark if the \h book name has changed
   \pdfb@@kmark
   \getp@ram{firstindent}{\m@rker}\let\f@rstindent=\p@ram
```

Reading the code linearly, the next part of this paragraph style routine is
concerned with drop chapter number support. We will discuss that as part of
(Milestones)[#milestones].

The last part of the `everypar` routine sets up the initial indentation. If
there is a first line indent we need to analyse whether we still do actually
allow first line indentation. If the indentation is negative, then yes.
Otherwise we don't allow first line indentation if IndentAfterHeading is not
true. If we are actually going to do the indentation, we manually insert the
indentation ❶. If there is a chapter number box, then we shift backwards by
its width and insert it. We set the flag to say we are in a paragraph and then
run any `start` hook for the paragraph marker. This also applies to diglot side
specific `start` hooks. If there is a chapter number in this paragraph we
disable marginal verses around the drop chap. Finally we say we are no longer
starting up the paragraph. That brings us to the end of the macro that is run
when the paragraph text starts. And that brings us to the end of a very long
`\if` that started way back whether this parargraph is publishable or not.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="428"}
   \ifx\f@rstindent\relax \else
    \x@\ifdim\f@rstindent pt<0pt
     \allowp@rindenttrue % redundant
    \else
     \iffirst@fterheading \ifIndentAfterHeading\else \allowp@rindentfalse \fi\fi
    \fi
    \ifallowp@rindent % create first-line indent, unless suppressed at dropped chapter number
                      % (note that we don't suppress negative indents, as in \q1 etc)
     \trace{Ds}{\m@rker\ifdiglot\ifdiglotL L \else R\fi\fi\space  First indent \f@rstindent * \the\IndentUnit}%
     \kern\f@rstindent \IndentUnit                                              ①
    \fi
   \fi
   \ifvoid\ch@pterbox\else \kern-\wd\ch@pterbox \box\ch@pterbox \fi
   \global\p@ranesting=1
   \csname start-\m@rker\endcsname % handle <start> hook
   \ifdiglot\setsid@ % \MSG{start-\m@rker\sid@}%
     \csname start-\m@rker\sid@\endcsname % handle side-specific <start> hook
   \fi
   \ifdr@ppednumber \spacefactor=0\n@wchaptersf \fi
   \startparafalse
   % set special \spacefactor if we're at a chapter number, so \v 1 can omit the verse number here
  }% end everypar
 \fi}
```

### PDF Bookmark

At various points in the code, a call is made to `\pdfb@@kmark` to possibly
insert an outline entry for the start of a book. The choice of which routine to
use is diglot governed. We examine only the monoglot version, with the right
diglot alternative being nearly identical apart from which variable is used. If
the book is the same the previous book, then there is no book transition and no
output is needed. OTherwise we stop any drop number for this paragraph (_why?_)
and create a PDF outline entry for the book.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="454"}
\newif\ifRTL
\newif\ifallowp@rindent
\newif\ifdr@ppednumber
\newif\ifIndentAtChapter
\newif\ifIndentAfterHeading \IndentAfterHeadingtrue
\newif\ifOmitVerseNumberOne \OmitVerseNumberOnefalse
\newif\ifOmitVerses \OmitVersesfalse
\newif\ifDropActions \DropActionsfalse
\def\n@wchaptersf{998}
\let\b@ok\relax
\let\prevb@ok\relax
\let\b@okR\relax
\let\prevb@okR\relax
\def\pdfb@@kmark{\ifdiglot\ifdiglotL\pdfb@@km@rk\else\pdfb@@km@rkR\fi\else\pdfb@@km@rk\fi}

\def\pdfb@@km@rk{\ifx\b@ok\prevb@ok
 \else
  \global\dr@ppednumberfalse
  \ifDropActions\else\bgroup\liter@lspecials
    \special{pdf:dest (\id@@@.) [@thispage /Fit]}%
    \ifx\b@ok\relax \let\t@mp=\id@@@ \else \let\t@mp=\b@ok\fi
    \special{pdf:outline 0 << /Title (\t@mp)
             /A << /S /GoTo /D (\id@@@.) >> >>}%
    \global\let\prevb@ok\b@ok\egroup\fi
 \fi}

\def\Alternative{\ /\ }%
\let\b@okC=\relax

\def\pdfb@@km@rkR{\ifx\b@okR\prevb@okR
 \else\ifDropActions\else
  \bgroup\liter@lspecials
   \special{pdf:dest (\id@@@.) [@thispage /Fit]}%
   \ifx\b@ok\relax \let\t@mpL=\relax \else \let\t@mpL=\b@ok \fi
   \ifx\b@okR\relax \let\t@mpR=\id@@@ \else \let\t@mpR=\b@okR \fi
   \ifx\t@mpL\relax \let\b@okC=\t@mpR\else\ifx\b@okR\relax \let\b@okC=\t@mpL\else\def\b@okC{\t@mpL\Alternative\t@mpR}\fi\fi
   \special{pdf:outline 0 << /Title (\b@okC)
            /A << /S /GoTo /D (\id@@@.) >> >>}%
   \global\let\prevb@okR\b@okR
  \egroup
 \fi\fi}
```

## Note Styles

Dealing with note styles starts long before a note is encountered. When a style
marker is identified as a note style marker, we need to create an insert for
that kind of note. We start by setting a flag to say that as far as we know, we
are a new class. We also store the identifier (marker) for the class so that the
checking process can test against it.
Then we iterate through all the existing classes to see if any of them are the
same as the marker. If not, then we allocate the class.

For each class we call the `\ch@ckifcl@ss` which tests to see if the class
identifier in question is the same as the marker we are making a class for. If
it is then we indicate that this is not a new class.

Allocating a class is where the note class is actually made. We add the
execution `\\<marker>` to the list of note class tokens for rapid iterating
through all the note classes, just as we did for `\ch@ckifcl@ss`. Then we create
an insert for the note (or two in the case of diglot). Creating a new note is
simply a matter of creating a `newinsert` for the class. The problem is that
`newinsert` cannot be called from inside a macro. So we have to `\let` another
token be the content of `\newinsert` and call that instead. Sigh.

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="34"}
% We keep a list of all the note classes in \n@tecl@sses, each prefixed with \\ and enclosed in braces.
% Then we can define \\ on the fly, and execute the \n@tecl@sses list to apply it to all classes.
\newtoks\n@tecl@sses

% for each Note marker defined in the stylesheet, we allocate a "note class"
% with its own \insert number (see TeXbook!)
%
\def\m@ken@tecl@ss#1{%
  \newcl@sstrue
  \def\n@wcl@ss{#1}
  \let\\=\ch@ckifcl@ss \the\n@tecl@sses % check if this note class is already defined
  \ifnewcl@ss \allocatecl@ss{#1} \fi
}
\def\ch@ckifcl@ss#1{\def\t@st{#1}\ifx\t@st\n@wcl@ss\newcl@ssfalse\fi}
\newif\ifnewcl@ss

% new note class: append to the list in \n@tecl@sses, and allocate an \insert number
\def\allocatecl@ss#1{
  \x@\n@tecl@sses\x@{\the\n@tecl@sses \\{#1}}%
  \relax%
  \ifdiglot%
    \n@wnoteins@rt{#1}%
    \n@wnoteins@rt{#1R}% May not always need this, but somsone might change their minds.
  \else%
    \n@wnoteins@rt{#1}%
  \fi%
}
\def\n@wnoteins@rt#1{
	\x@\n@winsert\csname note-#1\endcsname
}
\let\n@winsert=\newinsert % work around the \outer nature of \newinsert
```

### Start Notes

When a note style marker is encountered we call `\n@testyle`. Note styles are
closed just like character styles. In this routine we analyse the character
after the marker to test for `*` or anything else (including space). Although
what follows a start marker is expected to be only a space. On entry to the
routine, we capture the marker and set up space as a normal character and then
use `\futurelet` to grab the next token (read character) after the marker. This
then calls into `\don@tstyle` which analyses the grabbed token. If it is a `*`
then we call the `\endn@testyle` else we call `\startn@testyle`.

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="91"}
\def\n@testyle#1{\TRACE{n@testyle:#1}%
 \def\newn@testyle{#1}%
 \catcode32=12\relax % look ahead to see if space or * follows (like char styles)
 \futurelet\n@xt\don@testyle}
\def\don@testyle{\catcode32=10\relax 
 \if\n@xt*\let\n@xt\endn@testyle\else\let\n@xt\startn@testyle\fi
 \n@xt}
```

We use the lowercase trick on `\startn@testyle` to handle the space following
the marker. This has an unfortunate side effect that we can't use capital
letters for anything important in the macro. So we get around this by creating a
macro for our uppercase string, and since the definition is outside
`\lowercase`, no lowercasing happens.

We start the note style, like so many others, by testing to see if the text in
the note is publishable. If it is not then we open a whole nest of groups that
correspond to the groups that get created for a publishable marker. The first
group encapsulates resettting paragraph controls, via `\resetp@rstyle` ❶ (In
the next code fragment). Then
we clear the tokens to execute after the note. Then if we are inside a heading,
we create a new group to correspond to the box that is created to delay the
output of notes. Then we create a box to capture the notes contents and turn on
note skipping. We are inside a note and we set a flag to say whether there was
space before this note.

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="101"}
\def\b@lance{BALANCE}
\lowercase{
 \def\startn@testyle~#1 {% get the caller code as a space-delimited parameter
  \trace{n}{startn@testyle #1}%
  \t@stpublishability{\newn@testyle}\ifn@npublishable
    \begingroup
    \let\aftern@te\relax
    \ifhe@dings\bgroup\fi
    \setbox0=\hbox\bgroup \skipn@testyletrue
    \global\n@tenesting=1\relax
    \ifdim\lastskip>0pt \sp@cebeforetrue \else \sp@cebeforefalse \fi % was there a preceding space?
```

Otherwise this note is publishable and we have to do something about it. The
first step is that, because of the caller, we need to be in horizontal mode.
Then we get the `notebase` parameter of the note. This allows someone to specify
that a different note class will receive the contents of notes of this marker.
For example if they want to merge `\f` footnotes and `\x` cross references. If
nothing is specified, then use this marker as the note class.

If there is a `before` hook to run, then run it. Now capture the function's
parameter which is the caller character for this note. If the caller is a `+`
then we need to auto generate the caller. We do this by incrementing the caller
index and inserting the caller at that index. Otherwise if the caller is a `-`
then no caller is output, otherwise use the caller character itself.

We start a group for the note and its caller. We collect any `after` hook for
the note. Was there some space before the note, then flag the need later. Then
we reset the paragraph style within the note group for the note text itself. ❶

The core of note handling is a call to `\m@kenote`. The parameters to that macro
are themselves token sequences. Notice that the sequences are not expanded until
inside that macro. The first parameter is the note class into which the note
will go. The second is the note marker. The third is the code to insert the
caller into the main text. This code also sets up the paragraph for the note
text. The default style for the caller is `\v` unless specified for the note.
The caller is then created in a box, which might be empty if the caller content
is empty. The content of the box is character styled by the callerstyle.
In addition to the superscript of the callerstyle, there is the callerraise. If
set then raise the box by that amount.

The fourth parameter contains the code to insert the note's caller as a box. If
there is a notecaller style then use that to style the mark. In addition use the
notecallerraise to raise the box.

Calling `\m@kenote` is the same as starting a footnote in plain TeX. The macro
returns with us inside the note insert. So we begin a new group and flag that we
are inside a note now. If there is a `start` hook for the note, we execute that
here and skip any following spaces.

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="114"}
  \else
    \leavevmode
    \getp@ram{notebase}{\newn@testyle}\edef\n@tebase{\ifx\p@ram\relax\newn@testyle\else\p@ram\fi}%
    \csname before-\newn@testyle\endcsname
    \def\t@st{#1}%
    \ifx\t@st\pl@s % if it is + then generate an auto-numbering caller
      \inc@utonum{\newn@testyle}%
      \x@\gen@utonum\x@{\newn@testyle}%
    \else\ifx\t@st\min@s \def\them@rk{}% if it is - then there is no caller
    \else \def\them@rk{#1}% otherwise the caller is the parameter
    \fi\fi
    \begingroup
    \x@\let\x@\aftern@te\csname after-\newn@testyle\endcsname
    \ifdim\lastskip>0pt \sp@cebeforetrue \else \sp@cebeforefalse \fi % was there a preceding space?
    \resetp@rstyle                                                              ①
    \m@kenote{\n@tebase}{\newn@testyle}{%
        \everypar={}\cancelcutouts % begin a note insertion in the given style
        \getp@ram{callerstyle}{\newn@testyle}% see if a caller style was defined
        \ifx\p@ram\relax\edef\c@llerstyle{v}\else\edef\c@llerstyle{\p@ram}\fi % if not, treat it like "v"
        \ifx\them@rk\empty \setbox0=\box\voidb@x \else
          \trace{s}{Note main caller}%
          \setbox0=\hbox to 1ex{\hss\x@\ch@rstylepls\x@{\c@llerstyle}~\them@rk\x@\ch@rstylepls\x@{\c@llerstyle}*\hss}\ht0=0pt
        \fi
        \getp@ram{callerraise}{\newn@testyle}\ifx\p@ram\relax\box0\else\raise\p@ram\box0\fi % suppress height of caller
        \ifnum\pagetracing>0
          \edef\n@tetxt{\b@lance\space note \newn@testyle\space in \n@tebase. \id@@@\space \ch@pter.\v@rse}%
          \x@\x@\x@\write-1\x@{\n@tetxt}%
        \fi
      }{\getp@ram{notecallerstyle}{\newn@testyle}\ifx\p@ram\relax\else
          \edef\c@llerstyle{\p@ram}%
          \ifx\them@rk\empty \setbox0=\box\voidb@x \else
            \trace{s}{Note caller}%
            \setbox0=\hbox to 1ex{\hss\x@\ch@rstylepls\x@{\c@llerstyle}~\them@rk\x@\ch@rstylepls\x@{\c@llerstyle}*\hss}\ht0=0pt
          \fi
          \getp@ram{notecallerraise}{\newn@testyle}\ifx\p@ram\relax\box0\else\raise\p@ram\box0\fi
        \fi}\bgroup
    \global\n@tenesting=1\relax
    \trace{b}{BALANCE note: style=\newn@testyle}%
    \csname start-\newn@testyle\endcsname % execute the <start> hook, if defined
    \ignorespaces
  \fi
 }
}
```

The `\m@kenote` macro parallels the footnote moacro in plain TeX. It's job is to
output the caller into the main text. If we are at the start of a paragraph (why
should we) then use the default space width otherwise continue with the existing
space glue. If we are in a heading then output the caller in that place in the
heading, but append the actual insert to the end of the headings. This reduces
any pressure to break a page within a headings bloxk by placing all the page
length cost at the end of the headings block. If we are in a chapter box then
append the ntoe to the chapternote. Otherwise just output the caller as normal.
Now set the spacefactor for the text inside the footnote and call to setup the
note insert, which may get wrapped. Notice that if there is no notecallerstyle
then simply use the same caller as in the main text.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="115"}
% footnote macros based on plain.tex \footnote, \vfootnote
\newbox\he@dingnotes
```

#1 ~ class to store the note in. E.g. f, x. The results of `\\NoteBlendInto`.
#2 ~ class to use for styling (what the source had in it)
#3 ~ styled text for main text caller
#4 ~ styled text for in note caller

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="122"}
\def\m@kenote#1#2#3#4{\let\@sf\empty
  % text is read later
  \ifhmode\edef\@sf{\spacefactor\the\spacefactor}\/\fi%
  % if footnote is on a chapter number ...
  \ifhe@dings #3\edef\@wrap{\global\setbox\he@dingnotes=\vbox\bgroup\unvbox\he@dingnotes}\else\edef\@wrap{}%
    \ifch@pter \everypar={}\ch@pterfalse%
      \global\setbox\ch@pternote=\hbox{\box\ch@pternote #3}%
    \else #3\fi % output caller
  \fi%
  % @sf preserves the space factor (e.g. extra space after a period), restore it now
  \@sf \@wrap\vm@kenote{#1}{#2}{\getp@ram{notecallerstyle}{#2}\ifx\p@ram\relax #3\else #4\fi}}
```

This is where we actually start making the note itself. We are passed the target
note class, the note marker and the code for the caller box. To set up, we set
the flag to say we are in a note and we clear the `next` token ready for the end
of the routine. We capture the note class into which the note is going, with
appropriate diglot adaptation. Then we start the insert. An insert is a vbox
that is inserted into the main contribution list before the main text line it is
part of. The insert starts a vbox and we start a group for it.

### Ending Notes

When we come to close off a note we need to end all the active character styles.
Then if we are skipping this note, then don't run any `end` hook. Then we close
off the note group, which closes the footnote and executes any `aftergroup` code
it has. Then if we are in a heading, there is an extra level of grouping to
collect all the notes in a heading block at the end. We clear some flags.

Very often users in effect type a space both before a note marker and also after
the end of the closing note marker. We only want one of those spaces, so if
there was a space before the starting marker, skip any space following the
closing note marker. The `after` hooks were collected when the note started and
are executed here. Finally we end the whole group that was created when we
started this note and perhaps skip any following spaces.

\fileheader{ptx-note-style.tex}
```{.latex .numberLines startFrom="160"}
\def\endn@testyle*{\TRACE{endn@testyle}%
 \trace{f}{endn@testyle}%
 \end@llcharstyles % end any character styles within the note
 \ifskipn@testyle \else
  \csname end-\newn@testyle\endcsname % execute <end> hook
 \fi
 \egroup \ifhe@dings\egroup\fi% end the insert (started in \m@kenote) or skip-box
 \global\inn@tefalse
 \global\n@tenesting=0 
 \ifsp@cebefore \global\let\n@xt=\ignorespaces % ignore following spaces if there was a preceding one
   \else \global\let\n@xt\relax \fi
 \aftern@te
 \endgroup\n@xt}
\newif\ifsp@cebefore
\newif\ifskipn@testyle
```

### Paragraphed Notes

There are two kinds of notes: paragraphed notes are grouped into a single
paragraph while separate notes are output one per paragraph. We test to see
which kind of note class this is. Setting paragraphed notes is a user option for
a class.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="266"}
\def\ParagraphedNotes#1{\Par@gr@phedNotes{#1}\ifdiglot\ifdiglotSepNotes\Par@gr@phedNotes{#1R}\fi\fi}
\def\Par@gr@phedNotes#1{\TRACE{Par@gr@phedNotes #1}\x@\let\csname paranotes-#1\endcsname=1}
\newif\ifp@ranotes
\def\checkp@ranotes#1{\x@\ifx\csname paranotes-#1\endcsname\relax
  \p@ranotesfalse\else\p@ranotestrue\fi}
```

We set up the text width for the note. For paragraphed notes, we set the text
width to infinite otherwise we use the current textwidth. Then we reduce the
width by the column shift (since notes are shifted by the column shift, for
marginal verse numbers). The linepenalty says how hard we do not want footnotes
to split across a page boundary. This is a plain TeX parameter which defaults to
100. The `\floatingpenalty` is set to the maximum of 10000, saying we do not
want notes spread across pages. We reset all the side and space skips. We set
the baseline based on the target note, not the marker, since all notes in a
class should have the same baselineskip.

### Separate Notes

If these are separate notes, then create full height strutbox and if the height
of that box is less than the baselineskip then skip by the difference between
that height and the baselineskip. Now we start the paragraph in the note. In a
diglot we insert any side hooks. If we are right to left then insert right to
left start before whatever is already output.

We now test to see if we want callers in this note type. If so then create a box
from the note caller and output it. If it has width then add a small kern of
.2em after it. This is not user configurable.

Now we push this note type onto the style stack and set the font. Finally we
collect the bgroup that follows the call and call plain TeX's footnote handling
routine. 

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="136"}
\def\vm@kenote#1#2#3{%
  \inn@tetrue%
  \let\next\relax%
  \def\n@tetype{#1}%
  \ifdiglot\ifdiglotSepNotes\ifdiglotL\def\n@tetype{#1}\else\def\n@tetype{#1R}\fi\fi\fi%
  \TRACE{vm@kenote \n@tetype}%
  \x@\insert\csname note-\n@tetype\endcsname\bgroup% insert note-f (or note-x)
%%% single-column notes:
  \checkp@ranotes{#1}% check whether this note class is to be paragraphed 
  \hsize=\ifp@ranotes\maxdimen\else\textwidth\advance\hsize by -\columnshift\fi % insert penalties to control breaking of footnotes
  \interlinepenalty\interfootnotelinepenalty % set penalty to break lines
  \floatingpenalty\@MM % make sure note does not float away from caller to another page
  \leftskip\z@skip \rightskip\z@skip \spaceskip\z@skip \xspaceskip\z@skip % reset extra space around paragraph 0
  \s@tbaseline{#1}%
  \ifp@ranotes\else\setbox0=\hbox{\XeTeXuseglyphmetrics=0 \char32}\dimen0=\ht0
      \ifdim\dimen0<\baselineskip
        \dimen1=\baselineskip\advance\dimen1 by -\dimen0
        \vskip\dimen1
		\trace{f}{\reference : Footnote vskip=\the\dimen1 baselineskip=\the\baselineskip strut height=\the\dimen0}
	  \fi\fi
  \leavevmode % begin paragraph
  \ifdiglot\ifdiglotL\the\leftho@ks\else\the\rightho@ks\fi\fi%
  \ifRTL\setbox2=\lastbox\beginR\box2\fi % if RTL text this paragraph needs to be RTL
  % if note omitting caller from note (i.e. all callers are *'s)
  \testomitc@ller{#2}\ifomitc@ller\else
    % save copy of caller in temporary box, if non-empty add a little space
    \setbox0=\hbox{#3}\setbox1=\copy0\unhbox1\ifdim\wd0>0pt\kern.2em\fi
  \fi
  % currently we do not allow footnotes to break to the next page, so this may not be necessary
%  \splittopskip\ht\f@@tstrut % top baseline for broken footnotes
%  \splitmaxdepth\dp\f@@tstrut
  \mcpush{N+#2}%
  %\getp@ram{fontsize}{#2}\edef\c@rrfontsize{\ifx\p@ram\relax12\else\p@ram\fi}%
  \s@tfont{#2}%
  \futurelet\next\fo@t}% use plain.tex footnote processor
```

`\fo@t` is a plain TeX macro and is described in the TeXbook, but in summary, in
our context, it calls `\@foot` after then end of the note style. Our `\@foot`
first ensures no skip at the end of paragraphed notes. This is because we are
merely collecting the note into an hbox inside a vbox. For separate notes, we
include a strut to ensure an appropriate size for the last line. Then we close
of the horizontal mode and close the styling group we started for the note. Next
we check that the style stack is in good order and then pop it.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="197"}
\def\@foot{\ifp@ranotes \parfillskip=0pt \else\strut\fi
  \par\egroup\ifRTL\endR\fi\end@llcharstyles
  \def\d@##1+##2\E{\if ##1N\else\MSG{Bad marker ##2\space but expected a closing note marker}\fi}\mctop
  \mcpop}
\newbox\f@@tstrut
\def\n@teglue{2em plus 1em minus .5em\relax} % glue to be used between paragraphed notes
```

# Milestones

Milestones do not fit into the style hierarchy since they do not style text so
much as insert text at a point in the document. They have no concept of opening
and closing since they are a single event. The primary two milestones we examine
are chapter and verse markers.

## Chapters

We define the `\c` macro as part of the one time setup that runs when the first
sfm file is processed.
Most chapter numbers are a drop number. What makes scripture typesetting tricky
is that there are a few drop chapter numbers that occur mid paragraph. Since
USFM says that paragraphs occur under a chapter marker. There is a special
paragraph marker for the non paragraph break: `\nb`. To achieve the cutout we
have various things to set up in the chapter marker itself. We start by
squirrelling away the `\c` paragraph style. After this, there are two parts
to the chapter marker processing. We
start with the pattern matching chapter that collects the chapter number and
processes it.

If we are currently not outputting any text, due to it not being publishable,
for example. we are in a dumping group. We need to close that group for now and
get back to normal paragraph land. We collect the chapter number for references.
We also collect the chapter number text (e.g. from `\cp`) for output. We clear
the verse number since we are at the start of a chapter. If we omit chapter
numbers then we are done. Otherwise, if there is a chapter label then use the
appropriate one for diglot and output the `\cl` paragraph style with the chapter
label followed by the chapter label text.

The actual `\c` macros is pretty simple. We make digits into digits and call the
pattern matching chapter macro. We also define `\cp` to simply pattern match and
capture the chapter number as the chapter number text.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="297"}
  \let\@C=\c
  % Define a macro to process space delimited chapter number
  % ## is necessary because this is a nested macro definition
  \def\@c@ ##1 {\ifsk@pping \egroup \fi % if we were skipping, stop it
   \gdef\ch@pter{##1}% remember chapter number
   \gdef\ch@ptert@xt{##1}% the chapter number we will actually output
   \gdef\v@rse{}% clear verse number
   \m@kedigitsletters
   % If omitting chapter number, skip this. 
   % We would have to set \OmitChapterNumbertrue on a book by book basis
   % in the configuration file in order to omit chapter numbers for single chapter books.
   \ifOmitChapterNumber\else
    % if chapter label not present, set \ch@ptertrue to cause chapter number to be printed
    % at start of first text paragraph.
    \global\let\ch@pl@bel=\ch@plabel % p@rstyle{cl} may end a group.
    \ifdiglot\ifdiglotL\else\global\let\ch@pl@bel=\ch@plabelR\fi\fi
    \ifx\ch@pl@bel\empty \global\ch@ptertrue 
    \else % if \cl present, output chapter label here
      \p@rstyle{cl}\ch@pl@bel\ \ch@pter
      \pdfb@@kmark \pdfch@ptermark
    \fi
   \fi}
  %
  \def\c{\m@kedigitsother\@c@}
  \def\cp ##1 {\gdef\ch@ptert@xt{##1}}
```

### Drop chapter number size

Drop chapter numbers need to be of the right size and users almost never get the
number right. It is better to calculate it. But calculating the proper
size of a dropped chapter numbers is tricky. The aim is to have a chapter number
that stretches from the baseline on the second line to the top of the x-height
of the first line. But if the digits have descenders then we need to test
whether the descenders will go below the descender of the second line. If so
then we calculate the drop chapter to fit into the space range from the
descender of the 2nd line to the ascender of the 1st line, and then shift them
to fit.

We start by getting the currently specified fontsize for dropped chapter
numbers. Then we find the ascent and the descent of the main paragraph font
(in box1) ❶. We also get the
vertical metrics of all the digits in the chapter font at the fontsize for the
chapter marker. Notice that to get the
font metrics we tell XeTeX to give us those. Then we switch to have XeTeX give
us true glyph metrics. We clear out the chapter font in anticipation of
recalculating it with a new size. Then we get the x-height of the paragraph
text ❷. Now we have all the external numbers needed to calculate the drop number
size.

TeX does fixed point calculations in sp with 1pt having a value of 65536.
The problem with this is if you divide two dimensions you get an integer
division, which is often not very useful. To increase accuracy, we multiple up
by 128 (giving a maximum dimension of 512pt which should be enough for 2 lines
of text). This means keeping track of when we multiply, values are in effect
multiplied by $2^{16}$ and if a number that is multiplied by $2^{16}$ is divided by
another number multiplied by $2^{16}$ then the result has no multiplier, and so on.
Multiplying numbers by 128 for extra accuracy can either result in having to
divide the result by 128 or multiply it by $512 = (2^{16} / 2^7)$.

The calculation is in 3 sections. The second section does a default calculation
of the new chapter size needed to get the height of the digits to fit from the
baseline of the second line to the x-height of the first. The first section
calculates a notional height to pass into that scaling. In the normal case where
there is no depth to speak off, this value is the height of the digits. But if
there is a problem, then we scaled the height of the digits such that the final
result comes out being the total height from the descender of the second line to
the ascent of the first. The final section calculates any shift needed for
digits with large depths.

❷ First we calculate X, which is the distance from the baseline of the second
line to the top of the x-height of the first line. And then we calculate X/C *
128. We also calculate height T, the distance from the second line descender to
the first line ascender, based on what the font says about ascenders and
descenders. Next we need CX/T (where C is the point size specified by the
chapter style). This is the height the digits would have to be to fit into T
rather than X. We also calculate the maximum depth of the digits scaled if
the maximum height was scaled to fit with top x-height.

If CX/T is less than the maximum height of the digits, or if there is
insufficient room below the baseline for the scaled depth, then use the CX/T to
scale. Otherwise use the digits height. ❸ This is then scaled such that height
will stretch from the baseline of the second line to the x-height of the first line.
We know that the whole thing will fit, but we may need to shift the number if
the descender would clash with the line below ❹. We calculate what the shift is.

The dropnumbersize dimension is converted into a string so that it can be stored
as the `\c` font size, as if it were specified in the .sty file.

For diglots we need to store the drop chap number size for each side. _There is
work to be done here_

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="325"}
  \ifdim\dropnumbersize=0pt
    \calcdr@psize
  \fi
  \def\m@rker{c}\defp@ram{fontsize}{\dr@psize}
  \ifdiglot \resetdropc@p\fi%Can't do this here since things get lowercased
 }
}

\def\calcdr@psize{%
    \getp@ram{fontsize}{c}\dropnumbersize=0\p@ram\FontSizeUnit \relax % C in following
	% if font size specified for chapter number stylesheet is less than 2*paragraph font size ...
    %\ifdim\dropnumbersize<\dimen255
      \edef\@seglyphmetrics{\the\XeTeXuseglyphmetrics}%
      \s@tfont{p}%workaround for Lotus Elam Bold issue - ensure the \p font is loaded first
      \XeTeXuseglyphmetrics=0\relax\setbox1=\hbox{0}% get font metrics          ①
      \XeTeXuseglyphmetrics=3\s@tfont{c}\relax\setbox0=\hbox{0123456789}% set a box at the size specified by the \c marker
      \XeTeXuseglyphmetrics=\@seglyphmetrics% \tracingcommands=0\MSG{useglyphmetrics=\the\XeTeXuseglyphmetrics}
	  %clear font<c> so that it will get rebuilt on next setfont for \c (after we have figured out real size)
      \x@\let\csname font<c>\endcsname=\relax 
	  % Calculate drop cap height = base line height + (lower case) x height
      % get x height (appendix F) 5 is x-height of font X=x + baselineskip
      \s@tfont{p}\dimen0=\fontdimen5\font\advance\dimen0\baselineskip           ②
      \dimen1=\dimen0 \multiply\dimen1 by 128 \divide\dimen1 by \dropnumbersize % X/C * 128
      \dimen2=\ht1 \advance\dimen2 by \dp1 \advance\dimen2 by \baselineskip % total height available: T
      \dimen3=128\dimen0 \divide\dimen3 by \dimen2 \multiply\dimen3 by \dropnumbersize \divide\dimen3 by 128 % CX/T
      \dimen4=\dp1 \multiply\dimen4 by \dimen1 \divide\dimen4 by 128 % scaled available
      \trace{h}{dimen0=\the\dimen0, dimen1=\the\dimen1, dimen2=\the\dimen2, dimen3=\the\dimen3,
                dimen4=\the\dimen4, dp0=\the\dp0, ht0=\the\ht0, dp1=\the\dp1, ht1=\the\ht1,
                FontSizeUnit=\the\FontSizeUnit, dropnumbersize=\the\dropnumbersize}%
      \ifdim\dimen3<\ht0 \dimen2=\dimen3\else\ifdim\dimen4<\dp0\dimen2=\dimen3\else\dimen2\ht0\fi\fi % min(CX/T, ht(0))
      \trace{h}{starting height=\the\dimen2}%
      % The following calculations are scaled by 128 in order to get better accuracy even though calculations are integer values
	  % divide desired height by current height
      \multiply\dimen0 by 128                                                   ③
      \divide\dimen0 by \dimen2
	  % multiply by original size from \c marker in stylesheet
      \trace{h}{font x-height \x@\the\fontdimen5\font, ht of digits \the\ht0, dp of digits \the\dp0, baselineskip \the\baselineskip, for dropcaps \the\dimen0\ multiply by \the\dropnumbersize}%
      \dimen3=\dimen0 % depth scale factor * 128
      \multiply\dimen0 by \dropnumbersize
      \dropnumbersize=\dimen0
      % divide by the \FontSizeUnit to get value for fontsize param of marker \c
      \divide\dropnumbersize by \FontSizeUnit
      \multiply\dropnumbersize by 512 % (2^16 / 128)
      \multiply\dimen3 by \dp0  % new depth
      \divide\dimen3 by 128
      \trace{h}{dropnumbersize=\the\dropnumbersize, dimen1=\the\dimen1, dimen3=\the\dimen3}%
      \ifdim\dimen3>\dp1 % would overflow downwards. Need to shift              ④
        \advance\dimen3 by -\dp1% \divide\dropnumberraise by 2
        \setp@ram{raise}{c}{\the\dimen3}
      \fi
      \trace{h}{dropnumbersize = \the\dropnumbersize, dropnumberraise = \the\dropnumberraise}%
    %\fi
    \edef\dr@psize{\strip@pt\dropnumbersize}%
}

\def\resetdropc@p{%The above code is in \lowercase which  breaks L and R
  \message{Setting L drop-cap size to \dr@psize}%
  \setp@ram{fontsize}{cL}{\dr@psize}%
  \getp@ram{raise}{c}\ifx\p@ram\relax\else\setp@ram{raise}{cL}{\p@ram}\fi
  \g@tfontname{c}\x@\let\csname font<\f@ntstyle>\endcsname=\relax
  \diglotLfalse
  \calcdr@psize
  \g@tfontname{c}\x@\let\csname font<\f@ntstyle>\endcsname=\relax
  \diglotLtrue
  \message{ Setting R drop-cap size to \dr@psize}%
  \setp@ram{fontsize}{cR}{\dr@psize}%
  \getp@ram{raise}{c}\ifx\p@ram\relax\else\setp@ram{raise}{cR}{\p@ram}\fi
  %\x@\let\csname font<cL>\endcsname=\relax %
  %\x@\let\csname font<cR>\endcsname=\relax %
}
```

### Stripping pt dimension

One of the trickier processes in TeX is string processing. This is because TeX
doesn't work in terms of strings, but of tokens. The text TeX reads is broken
into tokens and tokens have category codes. So a token `a` with catcode 12
(other) is a different token to the token `a` with catcode 11 (letter).

The `\the` command in TeX can be used to expand out many things, including a
dimension. The TeXbook says that the output of `\the` is a sequence of tokens
each with catcode 12. Thus a dimension is a sequence of tokens corresponding to
the size of the dimension in points followed by `p`~12 and `t`~12. If we want to
strip off the `pt` to get back to just a string that can be output say in a
`\special`, then we have some processing to do.

This code has to use quite a few TeX processing tricks to do what is basically a
very simple string processing job. The core is `\@strip@pt` which consumes
everything after it up to the first `p`~12 `t`~12 as parameter 1. Everything
after that is stored in parameter 2 up to the sentinel `\E`. The sentinel can be
any defined token.

What makes the definition of this macro tricky is that normally `p`, in TeX
code, has a catcode of 11. So how do we use both a `p`~11 in the macro name and
`p`~12 in the parameter pattern match? The trick is to use the `\lowercase`
macro that lower cases everything within it, while not changing its catcode.
Thus, since we don't need the letter `P` for any other purpose, we can
temporarily give it a catcode of 12 (also for `T`) and then use them in the
parameter pattern. Then we lower case the whole thing and we get what we want.

But, this is not sufficient for our needs. Passing the output of `\the` to our
new macro is no easy feat. So to make things easier we write a macro that calls
`\the` and passes its output to our `\@strip@pt`. This involves expanding all
kinds of things. Starting from the right hand end, we need to expand `\@pt` to
get the fallback `p`~12 and `t`~12 in case they are not in the output of `\the`.
We also need to expand `\the #1` to get the text of the passed token. The result
is that scary looking `\strip@pt` which gets used in `\special` commands.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="398"}
\let\E=\empty
{\catcode`P=12 \catcode`T=12 \lowercase{\gdef\@strip@pt#1PT#2\E{#1} \xdef\@pt{PT}}}
\def\strip@pt#1{\x@\x@\x@\@strip@pt\x@\the\x@ #1\@pt\E}
```

### Making a chapter box

When a paragraph starts with a drop chapter number we need to make a box for the
chapter number. For this we need box metrics to be based on the glyphs themselves
and not on the font metrics. We then create a default macro for printing the
chapter number. There is a user definable hook `\PrepChapterNumber` that can
redefine that `\printchapter` macro to style the chapter number text
appropriately. Then we create a box with the font set to the drop chapter size
and font and print the chapter number.

If the chpater needs to be rotated, for example, for vertical text, then we do
that here. In a vertical context, we still want the chapter numbers to be
presented horizontally across two lines. To do this we have to rotate the
chapter numbers so that when the whole page is rotated, they end up horizontal
again. In addition, the space after the chapter number, therefore, has to come
under the chapter numbers. In our calculations:

dimen value
----- -----
 0    Height of the chapter box. The width of the new box
 1    Height + depth of chapter box plus `\AfterChapterSpaceFactor`. The height of the rotated box 
 2    Half the height - width of the chapter box. The amount to shift the chapter box

Then we create the box and rotate it. Then we set the height of the box to the
width of the chapter box and the width to the new height, because height and
width get swapped in anticipation of rotation.

Otherwise and normally, we lower the chapter box by a baselineskip (adjusted by any
special dropnumber raise) and then insert the `\AfterChapterSpaceFactor`.
Finally we tidy up to set the glyph metrics back to the user setting. We need to
collect the width of the cutout we need to make and we clear any depth to the
box we created.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="612"}
\newdimen\ch@pterwd
\newbox\ch@pterbox
\newbox\ch@pternote
\def\AfterChapterSpaceFactor{3}
\def\m@kechapterbox{%
 \edef\@seglyphmetrics{\the\XeTeXuseglyphmetrics}\XeTeXuseglyphmetrics=3%
 \edef\printchapter{\ch@ptert@xt}%
 \csname PrepChapterNumber\endcsname
 \setbox\ch@pterbox=\hbox{\s@tfont{c}\printchapter}%
 \ifrotate
  \dimen0=1.0\ht\ch@pterbox
  \dimen1=\ht\ch@pterbox \advance\dimen1 by \dp\ch@pterbox\advance\dimen1 by \AfterChapterSpaceFactor\FontSizeUnit
  \dimen2=0.5\wd\ch@pterbox \advance\dimen2 by -0.5\ht\ch@pterbox
  \setbox\ch@pterbox=\hbox{\lower\dimen2\hbox to \dimen0{%
    \hskip\ht\ch@pterbox \special{x:gsave}\special{x:rotate 90}%
    \box\ch@pterbox\special{x:grestore}\hss}}%
  \ht\ch@pterbox=\wd\ch@pterbox\wd\ch@pterbox=\dimen1
 \else
  \getp@ram{raise}{c}%
  \dimen0\baselineskip\ifx\p@ram\relax\else\advance\dimen0 by -\p@ram\fi
  \setbox\ch@pterbox=\hbox{\lower\dimen0\box\ch@pterbox
    \box\ch@pternote\kern\AfterChapterSpaceFactor\FontSizeUnit}%
 \fi
 \XeTeXuseglyphmetrics=\@seglyphmetrics
 \ch@pterwd=\wd\ch@pterbox
 \dp\ch@pterbox=0pt
}
```

### Processing chapter in a paragraph

When a paragraph starts, in the `\everypar` macro there is a section that
handles what happens if we have encountered the start of a chapter before this
paragraph started. It first checks that this paragraph is a `VerseText` type
paragraph and not a section header, for example. Then, assuming the text is
publishable, it makes the chapter box. Then depending on directionality, we
choose which cutout function to use.

If there is no left margin, for example in a normal paragraph, we call the
cutout function with the width of the chapter box. Each cutout is numbered
sequentially and when a cutout is made it simply defines the various tokens for
that cutout number. These will be used later in dealing with cutouts.

We also see that cancelling a cutout is as simple as resetting the cutout count.
The cutout count is reset after all the cutouts for a paragraph are processed,
so the count rarely gets very high.

\fileheader{ptx-cutouts.tex}
```{.latex .numberLines startFrom="40"}
\def\leftcutout{\@cutout{L}}
\def\rightcutout{\@cutout{R}}

\def\@cutout#1#2#3#4{%
  \x@\trace{C}{@cutout #1 #2 #3 #4}%
  \global\advance\@numcuts by 1
  \expandafter\xdef\csname cut@side\the\@numcuts\endcsname{#1}%
  \expandafter\xdef\csname cut@width\the\@numcuts\endcsname{#2}%
  \expandafter\xdef\csname cut@after\the\@numcuts\endcsname{#3}%
  \expandafter\xdef\csname cut@lines\the\@numcuts\endcsname{#4}%
}
\newcount\@numcuts

% Forget any current cutouts
\def\cancelcutouts{\ifnum\@numcuts>0 \trace{C}{Cancelled \the\@numcuts\space cutout(s)}\fi\@numcuts=0 }
```

If, on the other hand, there is a margin, for example in poetry ❶ then we need
to calculate the actual indent of the first line. If this is less than the width
of the chapter number then we insert a cutout of the difference in width for the
first line and a cutout for the difference in width between the margin (the
indent of the second line) for one line for the second line. There is no need to
do this if the margin is greater than the width of the width of the chapter box.
But if the first line indent is wider than the chapter box then we simply widen
the chapter box to the first line indent 

We can now clear the flag to say there is an outstanding chapter number to
process. If there is no indent at a chapter number then clear the flag to insert
a first line indent. And set that dropped number processing is needed in
subsequence paragraphs. This will get cleared if the paragraph has more than 1
line. Finally output a PDF bookmark for the chapter.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="371"}
   \ifch@pter
    \getp@ram{type}{\m@rker}%
    \ifx\p@ram\v@rsetext
     \t@stpublishability{c}\ifn@npublishable
     \else
      \m@kechapterbox
      \ifRTL\let\c@tcmd=\rightcutout\else\let\c@tcmd=\leftcutout\fi
      \getp@ram{leftmargin}{\m@rker}%
      \ifx\p@ram\relax % simple case - no left indent
        \x@\c@tcmd\x@{\the\ch@pterwd}{0}{2}%
      \else % probably \q or something like that;                               ①
            % need to compare cutout width with leftindent
        \dimen0=\p@ram\IndentUnit \dimen2=\dimen0
        \ifx\f@rstindent\relax \else \advance\dimen0 by \f@rstindent\IndentUnit \fi
        % now \dimen0 is the real indent of the 1st line
        \dimen4=\ch@pterwd \advance\dimen4 by -\dimen0
        \ifdim\dimen4>0pt % if the chapter number doesn't fit there...
          \x@\c@tcmd\x@{\the\dimen4}{0}{1}% create extra indent
          \dimen4=\ch@pterwd \advance\dimen4 by -\dimen2 % and for wrap if needed
          \ifdim\dimen4>0pt \x@\c@tcmd\x@{\the\dimen4}{1}{1}\fi
        \else % the indent is already big enough, so just use it as is
          \setbox\ch@pterbox=\hbox to \dimen0{\box\ch@pterbox\hfil}%
        \fi
      \fi
      \global\ch@pterfalse
      \ifIndentAtChapter\else \allowp@rindentfalse \fi
      \dr@ppednumbertrue
     \fi
     % generate second-level PDF bookmark for the chapter
     \pdfch@ptermark
    \fi
```

Inserting the PDF bookmark for a chapter is only complicated by diglots. The
normal case we output a PDF destination for the bk.chapter and an outline entry
for the book (or id) space chapter.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="498"}
\def\pdfch@ptermark{\ifdiglot\ifdiglotL\pdfch@pterm@rk\else\pdfch@pterm@rkR\fi\else\pdfch@pterm@rk\fi}
\def\pdfch@pterm@rk{\ifDropActions\else\bgroup\liter@lspecials
  \special{pdf:dest (\id@@@.\ch@pter) [@thispage /Fit]}%
  \ifx\b@ok\relax \let\t@mp=\id@@@ \else \let\t@mp=\b@ok \fi
  \special{pdf:outline 1 << /Title (\t@mp\space\ch@pter)
           /A << /S /GoTo /D (\id@@@.\ch@pter) >> >>}%
  \egroup\fi}

\def\pdfch@pterm@rkR{\ifDropActions\else\bgroup\liter@lspecials
  \special{pdf:dest (\id@@@.\ch@pter) [@thispage /Fit]}%
  \ifx\b@okR\relax \let\t@mp=\id@@@ \else \let\t@mp=\b@okR \fi
  \special{pdf:outline 1 << /Title (\t@mp\space\ch@pter)
           /A << /S /GoTo /D (\id@@@.\ch@pter) >> >>}%
  \egroup\fi}
```

### Dropped chapter numbers in a paragraph

In the rare case that this paragraph follows a single line paragraph containing
a chapter cutout, drop any cutouts in this paragraph and prepare to recalculate.
Against we choose the appropriate side for the cutout and, as per the chapter
processing above, we test for a margin. With no margin, we simply insert a
single line cutout (since the first line was in the previous paragraph). If
there is a margin, then we find the first line indent. If it is less than the
chapterbox width then insert an appropriately sized cutout just for the first
line. Now that the chapter box has been consumed vertically, we can clear the
dropped number flag. No further paragraphs need get involved in this chapter
number cutout. Also disable hanging verses for this paragraph.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="404"}
   \else
    \ifdr@ppednumber % second line of chapter number, need to check indent/cutout
     \cancelcutouts % forget existing cutout, we're re-doing it
     \ifRTL\let\c@tcmd=\rightcutout\else\let\c@tcmd=\leftcutout\fi
     \getp@ram{leftmargin}{\m@rker}%
     \ifx\p@ram\relax % simple case - no left indent
       \x@\c@tcmd\x@{\the\ch@pterwd}{0}{1}%
     \else % probably \q or something like that;
           % need to compare cutout width with leftindent
       \dimen0=\p@ram\IndentUnit \dimen2=\dimen0
       \ifx\f@rstindent\relax \else \advance\dimen0 by \f@rstindent\IndentUnit \fi
       % now \dimen0 is the real indent of the 1st line
       \dimen4=\ch@pterwd \advance\dimen4 by -\dimen0
       \ifdim\dimen4>0pt % if the chapter number doesn't fit there...
         \x@\c@tcmd\x@{\the\dimen4}{0}{1}% create extra indent
       \else % the indent is already big enough, so just use it as is
       \fi
     \fi
     \dr@ppednumberfalse
     \spacefactor=\n@wchaptersf % prevent hanging verse number here
    \fi
   \fi
```

### Delayed chapter numbers

In many paragraphings of the Bible, there are paragraphs where the chapter break
occurs within a paragraph. This is difficult to model in USFM and instead of
keeping the paragraph unbroken, USFM marks a notional paragraph break and then
starts a special `\nb` paragraph that is special since it carries on the
previous paragraph. This is handled in the PTX macros with a special `\parstyle`
that doesn't actually break the paragraph. Remember that the `\parstyle` macro
has the job of closing the old paragraph as well as starting a new one. We have
the advantage, then of not needing to do either of those actions. Instead we
need to set up for a cutout in the middle of a paragraph, for the chapter
number. Given we cannot be sure that the paragraph will not be broken by a
column or page break, we store the desired position of the cutout in a special
`.delayed` file and reread that in a subsequent run. This means the job needs to
be re run if there is not already a `\.delayed` file (and that that file is in
sync with this file).

After this initial test where we simply tell the user they need to re run, if
necessary, we make sure we are already in horizontal mode and insert a strut ❹ to
ensure the line height at this point is appropriate for inserting a chapter box
❶. We are processing the chapter number now, so there is no need to annoy
other paragraphs with this. If the text is not publishable then dump the chapter
box. Otherwise, we make the chapter box and insert the appropriate end of the
line skip after it. Now we look up how many lines down in the paragraph we need
to go to insert the cutout. This gets output during the shipout and so is
measured against the top of the paragraph or column.  Then we make a cutout on
the appropriate side. The cutout is shifted down by the previously read delay.

The actual chapter box is output as a `\vadjust`, which inserts a vbox after
the current line. By setting the vbox to a height of 0pt, it adds no extra
height to the line on the page. Inside the box we have to shift from the current
position after the previous line up by the depth and then further up to the top
of the chapter box. Then we look for any further raise and if so go up by that
or a single line. Then we create a left or right aligned line of the chapterbox
and insert whatever shrink or stretch will keep the box 0 height. Finally we
also we insert PDF outline entries for the book, if needed, and the chapter.

Next ❸ we save the position in the output and capture the book and chapter in
a string that we can expand into the `write` command to the paragraph locations
(`.parlocs`) file with the this position in the page. These will get read in on
the next run to calculate the number of lines to shift the cutout down. Finally
we say: the next paragraph may need to deal with a cutout.

❹ A strut is simply a 0 width box with the height and depth corresponding to
the ascent and descent of the current font.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="642"}
% Used to delay a cutout until later in the paragraph, for no-break chapter numbers
\def\DelayedChapter#1#2#3{\uppercase{\def\ucb@@k{#1}}%
  \x@\edef\csname delay-\ucb@@k.#2\endcsname{#3}}

% Used to set a delayed paragraph number one line higher (projecting above the line with v.1 instead of below it)
\def\RaiseChapter#1#2{\uppercase{\def\ucb@@k{#1}}%
  \x@\let\csname raise-\ucb@@k.#2\endcsname=1}

\def\ptx@nb{%
  \ifch@pter
    \x@\let\x@\t@st\csname delay-\id@@@.\ch@pter\endcsname
    \ifx\t@st\relax \MSG{*** no-break at \id@@@\space\ch@pter, re-run to generate \string\DelayedChapter\space setting}%
    \else \MSG{* no-break at \id@@@\space\ch@pter}\fi
    \leavevmode\str@t                                                           ①
    \global\ch@pterfalse
    \t@stpublishability{c}\ifn@npublishable
     \setbox\ch@pterbox=\box\voidb@x
    \else
     \m@kechapterbox
     \setbox\ch@pterbox=\hbox{\box\ch@pterbox
       \kern\ifRTL\rightskip\else\leftskip\fi}%
     \ifRTL\let\c@tcmd=\rightcutout\else\let\c@tcmd=\leftcutout\fi
     \x@\let\x@\d@lay\csname delay-\id@@@.\ch@pter\endcsname
     \x@\c@tcmd\x@{\the\ch@pterwd}{0\d@lay}{2}%
     \vadjust{\vbox to 0pt{\kern-\dp\str@tbox \kern-\ht\ch@pterbox              ②
      \x@\let\x@\t@st\csname raise-\id@@@.\ch@pter\endcsname
      \ifx\t@st\relax \else \kern-\baselineskip \fi
      \ifRTL\let\n@xt\rightline\else\let\n@xt\leftline\fi
      \n@xt{\ifRTL\beginR\fi\box\ch@pterbox\ifRTL\endR\fi}\vss}%
      \pdfb@@kmark\pdfch@ptermark\nobreak}%
     \beginL\pdfsavepos                                                         ③
     \edef\dc@ref@rgs{\string\@delayedchapter\string{\id@@@\string}\string{\ch@pter\string}}%
     \x@\write\x@\p@rlocs\x@{\dc@ref@rgs{\the\pdflastxpos}{\the\pdflastypos}}\endL
     \dr@ppednumbertrue
    \fi
  \fi}
\newbox\str@tbox
\def\str@t{\setbox\str@tbox=\hbox to 0pt{\XeTeXuseglyphmetrics=0                ④
  \char32 \hss}\copy\str@tbox}
```

## Verses

A verse marker is a milestone and as such doesn't fit the normal character,
paragraph, note style category. It needs special handline. First we keep the
stylesheet `\v` marker definition for when we need to style the verse number
itself. Then we define a pattern matching macro to match the space and the verse
number text followed by a space. The verse number text is normally simply a
verse number, but verse numbers can include briding verses and partial verses.
Only one space is consumed after the verse number text.

The job of this pattern matching macro is to do the work of a verse number. That
is to run any pre verse hooks. Then is splits up the verse number text into from
and too verses. The calling macro may have set `\cancelfirstversetrue` in which
case we assume it was correct and don't output anything. If we are typesetting
vertical text we may want to rotate verse numbers to their horizontal
orientation. We do that here by inserting a hbox and using special commands to
rotate it. Otherwise we take the more normal route. We treat the styling of the
verse number text as a nested character style. We start that style, then print
the verse number, which can include addorning it with directionality and even
putting it inside a figure. And then we finish the nested style.

After that we insert a standard amount of space after the verse number. Notice this
isn't glue because we do not allow a line break here.

The outer calling macro has started a new group for all this styling and we can
close that here. Now that we have output the verse number text, we insert a mark
for the headers and footers, and anything else that wants it, giving the current
reference. Then we run any verse hooks. These differ from the pre verse hooks.
We declare what our current reference is and then insert a magic piece of glue
that is the smallest size possible. [I'm not sure why this is here. 0.5sp is
smaller than TeX can hold and nothing seems to reference it. Is it redundant?]

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="245"}
\newif\ifhangingverse
\lowercase{
 % `~` is set by lowercase to a space for delimiting \ch@rstylepls
 \def\@ddcvhooks{
  % called after \c and \v have been processed in stylesheet at beginning of typesetting file
  \let\@V=\v% remember \v defn for (A) below
  % Define a macro to read an actual space delimited verse number
  \def\@v@ ##1 {\gdef\v@rse{##1}%
   \the\prev@rsehooks
   \x@\spl@tverses\v@rse--\relax % split verse in a verse bridge (e.g. 3-4) into \v@rsefrom, \v@rseto
   % if not cancelling first verse, output verse number
   \ifc@ncelfirstverse\else
    \ifrotate
     \setbox0=\hbox{\ch@rstylepls{v}~\printv@rse\ch@rstylepls{v}*}\dimen0=\wd0%
     \dimen1=\ht0\dimen2=0.5\dimen0\advance\dimen2 -0.5\ht0%
     \setbox0=\hbox{~\lower\dimen2\hbox to \dimen1{\kern\ht0\special{x:gsave}\special{x:rotate 90}%
      \box0\special{x:grestore}\hss}}\ht0=0pt\dp0=0pt\@V\box0\@V*%
    \else
     \ch@rstylepls{v}~\printv@rse\ch@rstylepls{v}*% (A) output verse number using saved style. ~ will lowercase to a space
    \fi
    \kern\AfterVerseSpaceFactor\FontSizeUnit
   \fi
   \egroup
   \m@rkverse % generate a milestone for running headers
   % run the hooks for picture insertion, paragraph adjustments, etc.
   % these hooks were added via \addtoversehooks
   \the\v@rsehooks
   % remember current chapter:verse, not currently used. Could potentially be used
   % to insert chapter:verse in footnotes.
   \gdef\reference{\ch@pter:\v@rse}%
   \nobreak\hskip0.5sp % let \x detect that there's "space" (or maybe drop-chapter) here
  }
```

When we actually encounter a verse milestone we need to enter horizontal mode
and to do that we need to remember what the current paragraph marker is so that
we can put it back later. The default is to print the verse number (since
usually we not at verse 1). The start of a chapter is marked by setting a
sentinel spacefactor, which we then indicate in the text with a 0 width kern.
Since we are at the start of the chapter we may set cancelfirstverse.

If the paragraph style has marked for a hanging verse number then insert an
`llap` in front of the verse number text. This sits the verse contents to the
left of the left margin. We then open the versenumber text group and call the
verse number text output macro.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="280"}
  \def\v{%
   \ifvmode\xdef\prev@rsemode{\m@rker}\else\global\let\prev@rsemode\empty\fi
   \leavevmode % ensure we are in horizontal mode to build paragraph
   % set c@ncelfirstversetrue if we are immediately following a drop cap chapter number
   % and the user has requested omission of the first verse number in a chapter
   \c@ncelfirstversefalse
   \ifnum\spacefactor=\n@wchaptersf \kern0sp % override \hangversenumber here
    \ifOmitVerseNumberOne \c@ncelfirstversetrue \fi \fi
   % -1sp indicates that a hanging verse number has been requested here.
   % When this happens we make ll@p use llap to right justify the verse number at the current position.
   % Otherwise make ll@p do nothing.
   \ifdim\lastkern=-1sp \let\ll@p=\llap\hangingversetrue
   \else \let\ll@p=\relax\hangingversefalse \fi % hanging verse number?
   \ll@p\bgroup\m@kedigitsother\@v@}%
  % remember chapter macro for later
```

### Hanging Verses

Hanging verses are for indented paragraphs and hange the verse as if the
paragraph had no indent. A typical use is with poetry where the verse numbers
hang left for indented poetry. There are various user controls here. The
starting point for this code is `\printv@rse` ❶ which is executed to make a
printable verse number. The usual case is to use `\simpleprintv@rse` ❷. This
prepares the from verse number using `\AdornVerseNumber` ❸ which allows for
any modification of the verse number. If there is a bridge verse range then
`\simpleprintv@rse` inserts the emdash and the adorned final verse of the range.
The result is therefore a simple string.

For hanging verses we use `\hangprintv@rse`. This does not actually hang the
verse left, that is done higher up, but it prepares the verse number or bridge
for hanging. For a normal, non-bridge verse we simply adorn it and return. But
for bridged verses we want to stack the bridge. We calculate twice the
superscript factor of the baselineskip and we set the baselineskip to the
baseline of `\v` if set. We also calculate the space between the two lines as
the superscript minus the baseline (which is negative).
Then we create a box containing a dash and the final
verse number of a bridge. Then we build a top hanging vbox containing two boxes
on top of each other, the first is the adorned initial verse number, right
aligned. Then we insert the calculated gap between lines and the second box is
the final verse box we just created.

\fileheader{ptx-stylesheet.tex}
```{.latex .numberLines startFrom="404"}
\def\AfterVerseSpaceFactor{2}
\newif\ifOmitChapterNumber
\newif\ifc@ncelfirstverse
\def\simpleprintv@rse{\AdornVerseNumber{\v@rsefrom}\ifx\v@rsefrom\v@rseto       ②
                 \else\endash\AdornVerseNumber{\v@rseto}\fi}
\def\hangprintv@rse{\ifx\v@rsefrom\v@rseto\relax\AdornVerseNumber{\v@rsefrom}%
    \else
         \dimen1=\SuperscriptFactor\baselineskip \multiply\dimen1 by 2
         \getp@ram{baseline}{v}\baselineskip=\ifx\p@ram\relax\baselineskip\else\p@ram\fi
         \dimen0=\SuperscriptFactor\baselineskip \advance\dimen0 by -\baselineskip
         \setbox1=\hbox{\endash\AdornVerseNumber{\v@rseto}}%
         \setbox0=\vtop{\hbox to \wd1{\hfil\AdornVerseNumber{\v@rsefrom}}%
                        \kern\dimen0\box1}%
         \ht0=0.5\dimen1 \dp0=0pt
         \hbox{\box0}\fi}
\let\printv@rse=\simpleprintv@rse                                               ①
\def\@ne{1}
\def\AdornVerseNumber#1{#1}                                                     ③

% put \hangversenumber into the <start> hook for a style such as \q1
% in order to 'hang' verse numbers into the paragraph indent of the style
\def\hangversenumber{\kern-1sp\relax}
```

The actual hanging of the verse is done in the definition of `\v` with a `\llap`
prefix that puts the box to the left of the start of the line after the indent.

### Marginal Verses

Marginal verses, on the other hand, are a very different animal. They are set
into the margin of the text. Or in our case a `\columnshift` space that is
inserted at the start of the column. Thus the verse numbers are removed from the
text and then pulled out for easy visual identification. They also limit the
breakup in the flow of the text. Marginal verses are enabled by including the
file `ptxplus-marginalverses.tex` after `paratext2.tex` in a driving .tex file.

First we see how the new code will be integrated into the main macros. We
replace the re-directed `\v` by ptx-stylesheet to our new `\myv`. This much
simpler verse handler copies some of the `\v` in terms of ensuring we are in
horizontal mode and clears cancelling the first verse. If we are at the start of
a chapter then insert the special kern to help `\x`. If we omit verse one then
cancel the first verse. Then we start the group for the verse and set digits
back to digits and call our `\marginverse`.

To hook this in we set up our `\initmyverse` which moves '\@V` away so that we
can use it later and sets `\v` to `\myv` to hook in. This then gets added as an
initialisation hook that executes after ptx-stylesheet cv hook. And we also set
up to use hangprintv@rse to handle verses and bridge verses.

\fileheader{ptxplus-marginalverses.tex}
```{.latex .numberLines startFrom="46"}
\def\myv{%
    \ifvmode\xdef\prev@rsemode{\m@rker}\else\global\let\prev@rsemode\empty\fi
    \leavevmode\c@ncelfirstversefalse
    \ifnum\spacefactor=\n@wchaptersf \kern0sp %
     \ifOmitVerseNumberOne \c@ncelfirstversetrue \fi\fi
    \bgroup\m@kedigitsother\marginverse} % ensure we are in horizontal mode to build paragraph
\def\initmyverse{\let\myoldv=\@V\let\v=\myv}
%\def\initmyverse{\let\v=\myv}
\addtoinithooks{\initmyverse}%
\let\printv@rse=\hangprintv@rse
```

The `marginverse` macro is inside a `\lowercase` with handling for space and
`\*`. It collects the verse number text and calls any preverse hooks. It then
splits the verse text into from and to verse components. Then it sets the verse
in the styling for the verse. Then it measures the height of the box plus the
descent of the font. It now redirects `\everypar` since we intend to create a
paragraph. It now does much of the work of `\v` in setting the marks
for the verse and running any verse hooks. It also defines the current
reference. Now it inserts the verse box is a `\vadjust`. Inside the box it sets
the baseline to that of `\v` or the current baselineskip. It now moves the box
up by the height + depth we just calculated and creates a box that is the left
aligned box while removing the boxes to get back to the basic structure of the
two boxes. Then it adds space for the `\AfterVerseSpaceFactor`. It sets the
height of this box to the height + depth calculated. It now says not to insert a
line break and puts the magic space in the text and resets `\everypar`

One macro it does use is a `\marginremovehboxes` which unpacks all the `\hboxes`
in the box.

_This does seem a rather long winded way of doing this_

\fileheader{ptxplus-marginalverses.tex}
```{.latex .numberLines startFrom="6"}
\catcode`\@=11
%\let\myoldv=\v
%\newif\multipleverses
\newtoks\myeverypar
\newdimen\mybaseline
{\catcode`\~=12 \lccode`\~=32 \catcode`\*=12 \lowercase{%
\gdef\marginverse #1 {%
    \gdef\v@rse{#1}% 
    \the\prev@rsehooks
    \x@\spl@tverses\v@rse--\relax
    \global\setbox2\hbox{\ifc@ncelfirstverse\else\myoldv ~\printv@rse\myoldv *\fi}%
    \egroup\str@t\dimen0=\ht2\advance\dimen0 by \dp\str@tbox
    \myeverypar=\everypar\everypar={}%
    \dimen1=\columnshift\advance\dimen1 by -\AfterVerseSpaceFactor\FontSizeUnit
    \m@rkverse \the\v@rsehooks \gdef\reference{\ch@pter:\v@rse}%
    \vadjust{\getp@ram{baseline}{v}\ifx\p@ram\relax\let\p@ram\baselineskip\fi
        %\kern -\dimen0\setbox1=\vbox to \dimen0{\llap{\unhbox2\kern\AfterVerseSpaceFactor\FontSizeUnit}}\dp1=0pt\box1}\nobreak
        \kern -\dimen0\setbox1=\vbox{\llap{\vbox{\leftskip=0pt plus 1fill %
            \rightskip=\z@skip\hsize=\dimen1 \baselineskip=\p@ram
            \trace{v}{hs=\the\hsize , bl = \the\baselineskip}%
            \noindent \unhbox2 \marginremovehboxes}%
          \kern\AfterVerseSpaceFactor\FontSizeUnit}}%
        \ht1=\dimen0\dp1=0pt\tracingparagraphs=0
        \trace{v}{\reference - tolerance=\the\tolerance}\box1}\nobreak
    %\m@rkverse % generate a milestone for running headers
    % run the hooks for picture insertion, paragraph adjustments, etc.
    % these hooks were added via \addtoversehooks
    %\the\v@rsehooks
    % remember current chapter:verse, not currently used. Could potentially be used
    % to insert chapter:verse in footnotes.
    %\gdef\reference{\ch@pter:\v@rse}%
    \nobreak\hskip 1sp% *%
    \everypar=\myeverypar}}}

\gdef\marginremovehboxes{%
  \setbox0=\lastbox 
  \ifhbox0{\removehboxes}\unhbox0\fi}
```

## Cutouts

The whole handling of delayed cutouts gets involved in various parts of
paragraph processing. We have already seen how the details of a cutout are
defined. Cutouts get inserted at the end of a paragraph.

The objective of the `\makecutouts` routine is to create a `parshape` for the
current paragraph. We start by calculating how many lines go into our parshape.
If there are hanging indents, then start there. Then iterate through all
the cutouts and increasing the line account accordingly. Then we create the
parshape we are building ❶. To do this we iterate over the number of lines
just calculated and calculate the indent and width for the line. Thankfully the
width is just the standard width minus the indent ❷. For a normal hangindent
line we use the `\hangindent`. But then there is look at the cutouts, which may
modify the indent and width for this particular line. At the end inside the loop
we append the indent and width to the list and outside the loop, set the
parshape.

\fileheader{ptx-cutouts.tex}
```{.latex .numberLines startFrom="89"}
\def\makecutouts{%
  \ifnum\hangafter<0 \@parshapelines=-\hangafter
  \else \@parshapelines=\hangafter \fi
  \@index=0
  \loop \ifnum\@index<\@numcuts \advance\@index by 1
    \count@=\csname cut@after\the\@index\endcsname
    \advance\count@ by \csname cut@lines\the\@index\endcsname \relax
    \ifnum\count@>\@parshapelines \@parshapelines=\count@ \fi
  \repeat
  \advance\@parshapelines by 1
  \def\@shape{}%                                                                ①
  \@line=0
  \loop \ifnum\@line<\@parshapelines \advance\@line by 1
    \global\@hsize=\hsize
    \global\@indent=0pt
    \ifnum\hangafter<0
      \ifnum\@line>-\hangafter\else \global\@indent=\hangindent \fi
    \else
      \ifnum\@line>\hangafter \global\@indent=\hangindent \fi
    \fi
    \ifdim\@indent<0pt \global\advance\@hsize by \@indent \global\@indent=0pt
    \else \global\advance\@hsize by -\@indent \fi                               ②
    \@cutthisline
    \edef\@shape{\@shape\space\the\@indent\space\the\@hsize}%
  \repeat
  \parshape=\number\@parshapelines \@shape
}
```

Calculating what the cutout impact on a particular line involves iterating
through all the active cutouts looking for any that impact this line. If one
does then we get the cut width and reduce the width by that width and if the
cutout is on the left, we reduce the indent.

\fileheader{ptx-cutouts.tex}
```{.latex .numberLines startFrom="118"}
\def\@cutthisline{%
  \@index=0
  {\loop \ifnum\@index<\@numcuts
    \advance\@index by 1
    \@after=\csname cut@after\the\@index\endcsname
    \@until=\csname cut@lines\the\@index\endcsname
    \advance\@until by \@after
    \ifnum\@line>\@after
      \ifnum\@line>\@until \else
        \@width=\csname cut@width\the\@index\endcsname
        \global\advance\@hsize by -\@width
        \if L\csname cut@side\the\@index\endcsname
          \global\advance\@indent by \@width
        \fi
      \fi
    \fi
  \repeat}%
}
\newcount\@parshapelines
\newcount\@index \newcount\@line \newcount\@after \newcount\@until
\newdimen\@width \newdimen\@indent \newdimen\@hsize
```

Having decided what cutouts may occur on a paragraph, there is also the
question of carrying over any incomplete cutouts from one paragraph to the next.
The routine iterates the cutouts and creates a new cutouts list containing any
incomplete cutouts from the old list. For each old cutout it checks to see if
the cutout needs to carry over, in which case it changes the `after` and `lines`
accordingly (`after` = 0, for example) and replaces them in a new list (which
cannot be longer than the old list).

\fileheader{ptx-cutouts.tex}
```{.latex .numberLines startFrom="63"}
\def\cutoutcarryover{%
  \ifnum\@numcuts>0
    \count@=\@numcuts \@numcuts=0
    \@index=0
    \loop \ifnum\@index<\count@ \advance\@index by 1
      \@after=\csname cut@after\the\@index\endcsname
      \advance\@after by -\prevgraf
      \@until=\csname cut@lines\the\@index\endcsname
      \advance\@until by \@after
      \ifnum\@until>0
        \ifnum\@after<0 \@after=0 \fi
        \advance\@until by -\@after
        \@width=\csname cut@width\the\@index\endcsname
        \edef\@side{\csname cut@side\the\@index\endcsname}%
        \@cutout{\@side}{\the\@width}{\the\@after}{\the\@until}%
      \fi
    \repeat
  \fi
}
```

### Parlocs and Delayed Cutouts

Calculating where delayed cutouts go involves two auxiliary files. The
`.delayed` file contains entries for each delayed chapter number (i.e. `\nb`
paragraph). The `.parlocs` gives the x, y position of the start and end of each
paragraph on a page. It also gives the number of lines in a paragraph that has
a dropped number in it.

Managing the parlocs files are done together. We open the `.delayed` file to
read, and if it is present delay the reading until we have closed the test
opening. Then we may just `input` the file. We don't read the `.parlocs` file
here, we just open it for output. We attach this routine to the list of routines
to run at initialisation

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="515"}
\newwrite\p@rlocs
\newread\readp@rlocs
\def\initp@rlocs{%
  % check if there's a delayed-chapters file from a previous run
  \openin\readp@rlocs="\jobname.delayed"
  \ifeof\readp@rlocs \let\n@xt\relax
  \else \def\n@xt{\input "\jobname.delayed"}\fi
  \closein\readp@rlocs
  % and if so, read it so we'll use those settings
  \n@xt
  % open the parlocs file to record paragraph and no-break-chapter locations
  \immediate\openout\p@rlocs="\jobname.parlocs"
}
\addtoinithooks{\initp@rlocs}
```

Closing up the parlocs file is somewhat the opposite of initialising it. For
this we close the written `.parlocs` file and then set up to read it. We open
the `.delayed` file for writing and then read the `.parlocs` file and process
it, which will write things to the `.delayed` file which we close after we have
finished reading the `.parlocs` file. And we do this at the end of the job.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="532"}
\def\finishp@rlocs{%
  \immediate\closeout\p@rlocs
  \catcode`\{=1 \catcode`\}=2 \m@kedigitsother \catcode`\@=11
  \immediate\openout\delayf@le="\jobname.delayed"
  \input "\jobname.parlocs"
  \immediate\closeout\delayf@le
}
\newif\ifdelay@pen
\let\delayf@le=\p@rlocs % we write the delay file while reading the finished parlocs, so we can re-use the write stream
\addtoendhooks{\finishp@rlocs}
```

The next set of macros work together to work out what the delayed parameters
should be for a delayed dropped number. Each routine is called from the
`.parlocs` file.

The `\@parstart` indicates the start of a paragraph and takes the x and y
coordinates of the start of the paragraph. We are only interested in the y
coordinate.

The `\@parend` indicates the end of a paragraph and from this we are only really
interested if there is a pending chapter number. If there is then we assume that
the dropped number position is less than one column from the end of the
paragraph. If we are in the same column then calculate the number of lines from
the chapter location to the end of the paragraph. _(This needs work)_

The macro that actually causes output to the `.delayed` file is `\@parlines`
which lists how many lines are in the cutout. The y value, which is in lines, is
adjusted according to the number of lines needed and then a `.delayed` entry is
written to that file and the pending chapter and book are cleared.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="547"}
\let\pendingch@pter=\empty
\newcount\prev@y \newcount\this@y \newcount\chap@y

\def\@parstart#1#2{\prev@y=#2\relax}

\def\@parend#1#2{%
  \ifx\pendingch@pter\empty\else
    \this@y=#2\relax
    \ifnum\chap@y>\this@y
      \advance\this@y by -\chap@y
      \divide\this@y by \baselineskip
    \else
      \MSG{*** unable to determine \string\DelayedChapter\space setting for \pendingb@@k\space\pendingch@pter}%
      \let\pendingch@pter=\empty
      \let\pendingb@@k=\empty
    \fi
  \fi}

\def\@parlines#1{\ifx\pendingch@pter\empty\else%
  \advance\this@y by #1 \advance\this@y by -1
%  \MSG{* calculated \string\DelayedChapter{\pendingb@@k}{\pendingch@pter}{\the\this@y}}%
  \wr@teDelayedChapter{\pendingb@@k}{\pendingch@pter}{\the\this@y}%
  \let\pendingch@pter\empty\let\pendingb@@k\empty\fi}
```

When a `\nb` type paragraph is encountered, this outputs a `\@delayedchapter`
entry in the `.parlocs` file and this uses the last paragraph end and chapter
position to insert a cutout half way up paragraph. If the paragraph start is
lower than the chapter position, then assume a different column or page. In that
case collect the book and chapter and then wait for a `\@parlines` to sort
things out. Otherwise do the line calculation and output the delayed chapter
information.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="573"}
\def\@delayedchapter#1#2#3#4{\chap@y=#4\relax
  \ifnum\prev@y<\chap@y % para start was lower than chapter number, must have passed a col/page break
    \def\pendingb@@k{#1}%
    \def\pendingch@pter{#2}%
  \else % para start level with or above chapter number; OK to calculate # of lines
    \advance\prev@y by -\chap@y
    \divide\prev@y by \baselineskip
    \MSG{* calculated \string\DelayedChapter{#1}{#2}{\the\prev@y}}%
    \wr@teDelayedChapter{#1}{#2}{\the\prev@y}%
  \fi}
```

Ideally we do not want to change the delayed chapter if we can avoid it because
it will trigger a re-run of the job and that takes time. So we compare the
information we are expected to write against what we read last time. If the
`delay` value, which is the number of lines down, is the same, then we assume
everything else is the same and carry on. Otherwise we test to see if we have
shifted by 1 line. If so then we can use the RaiseChapter to do the dirty deed.
But that triggers a rerun, as does really using the DelayeChapter. And finally
we write out the information to the `.delayed` file.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="586"}
\def\wr@teDelayedChapter#1#2#3{%
  \x@\let\x@\t@st\csname delay-#1.#2\endcsname
  \ifx\t@st\relax \pr@vdelay=-2 % ensure undefined value will not match 0
  \else \pr@vdelay=\csname delay-#1.#2\endcsname\fi
  \th@sdelay=#3\relax
  \ifnum\pr@vdelay=\th@sdelay % if the delay value is unchanged, all is good
    %\MSG{PARLOC: OK}%
  \else
    \advance\pr@vdelay by 1
    \ifnum\pr@vdelay=\th@sdelay % if new delay is 1 greater than old, we can use \RaiseChapter
      \advance\th@sdelay by -1
      \ifx\t@st\relax \MSG{PARLOC: Rerun. RaiseChapter needed at #1 #2}%
      \else \MSG{PARLOC: OK using RaiseChapter at #1 #2}\fi
      \immediate\write\delayf@le{\string\RaiseChapter{#1}{#2}}%
    \else
      \MSG{PARLOC: Rerun. DelayedChapter setting changed at #1 #2}%
    \fi
  \fi
  \immediate\write\delayf@le{\string\DelayedChapter{#1}{#2}{\number\th@sdelay}}%
}
\newcount\pr@vdelay \newcount\th@sdelay
\newif\ifsk@pping \newbox\j@nkbox
```

# Output Routines

The output routines constitute the core of the typesetting system. They control
the layout of the page and is the most complex part of the system.

There are two layouts described here: single and double column. We start by
examining single column output. A document starts by setting the output routine
to `\onecol`. TeX collects paragraphs into the main page builder. Once the page builder has
more than a page full of text, the `\output` routine is called with the contents
of the main page in box255.

## Single Column Output

❶ The onecol macro takes this box and processes it by storing it in the `\galley`
box. This allows us to reprocess it as often as is needed during output. ❷ Next we
do a noddy vsplit (to the maximum dimension so that everything goes in the first
box). This is just to collect any final mark on the page so far. And we set a flag
to say whether there are marks on this page. ❸ We collect the `\outputpenalty`
which is the cost of the page break that caused the output to run. We will need
this to add it back when we put the excess back into the page builder to start
the next page. The page height used for testing for the best page break is
calculated. The `partial` box contains any material that was collected in a
previous forced page break. For example when we transition from single to double
columns at the end of introductory material at chapter 1. We switch the output routine to the processing
function whose job is to iterate the pagesize down until the text just fits on
the page. If there are no marks on the page then clear the first page mark for
the page. We tell the page breaker to extract the inserts from the copy of the
page we are going to reprocess. Then we reprocess the page and add on the
penalty we just copied.

❹ The TeXbook describes how an output routine is called. If there is a penalty at
the page break point, that is stored in `\outputpenalty` and a penalty in the
actual list is set to 10000. On the other hand, if there is no penalty, then the
`\outputpenalty` is set to 10000. Our aim to set the end of the contributions
list to be the same as it was in the main contribution list, i.e. with 0 or a
penalty. This also deals with the issue of not wanting to break pages mid
paragraph, at least for the output routines. This also explains why this has to
be done every time we use the contribution list to trigger a new output routine.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="351"}
\global\output={\onecol}
\global\holdinginserts=1
\def\onecol{%
  \trace{b}{BALANCE pagebuild: cols=1: textheight=\the\textheight}
  \global\setbox\galley=\copy255                                        ①
  % tempoarily split and see if there are marks in this text
  \bgroup\setbox0=\copy255 \setbox1=\vsplit0 to \maxdimen\egroup        ②
  \edef\t@mp{\splitbotmark}
  \ifx\t@mp\empty\else\global\m@rksonpagetrue\trace{H}{Found mark \splitbotmark}\fi
  \global\galleypenalty=\outputpenalty                                  ③
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \global\output={\onecoltrial}
  % No marks on the page, and it didn't fit, so add a blank mark
  \ifm@rksonpage\else\gdef\p@gefirstmark{}\trace{H}{No marks found. Setting empty mark}\fi
  \global\holdinginserts=0
  \unvbox255
  \penalty\ifnum\outputpenalty=10000 0 \else \outputpenalty \fi         ④
}
```

The next macro `\onecoltrial` is what does the work of assessing and assembling the page. We
collect the marks for this page. ❶ We calculate the height that is available for
this page, and will reduce it by the height of the notes and the top and bottom
inserts. For this we use the `\decr` macro that simply reduces by the skip and
height of the insert:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="715"}
\def\incr#1#2{\ifvoid#2\else\advance#1 by \skip#2\advance#1 by \ht#2\fi}
\def\decr#1#2{\ifvoid#2\else\advance#1 by -\skip#2\advance#1 by -\ht#2\fi}
```

At this point ❷ we test to see if there is any space left on the page for any
text. If not then complain, but keep going because if we reduce the original
pagesize perhaps one of the footnotes or a picture will not be on this page.
Continuing, we take a copy of the reduced page that we are seeing will fit on
this page. We check to see if when we split the text to the space left on the
page whether anything is left. If there is, then we will have to go round again.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="371"}
\def\onecoltrial{% single-column version of \twocoltrial (see below)
  \tracingparagraphs=0
  %\tracingall=1\tracingoutput=0\tracingpages=0\tracingparagraphs=0\tracingassigns=0\tracingscantokens=0
  \trace{i}{1c TRIAL with ht=\the\trialheight, vsize=\the\vsize, hIns=\the\holdinginserts}
  \edef\p@gebotmark{\botmark}% remember last \mark for running header
  \edef\t@st{\p@gefirstmark}%
  \ifx\t@st\empty\xdef\p@gefirstmark{\firstmark}\fi % remember first, if not already set
  \availht=\trialheight % amount of space we think is available             ①
  \f@rstnotetrue
  \let\\=\reduceavailht \the\n@tecl@sses % reduce it by the space needed for each note class
  \decr{\availht}{\topins}% and by the space needed for spanning pictures
  \decr{\availht}{\bottomins}
  \ifdim\availht<0pt                                                        ②
    \MSG{Page overfull with inserts. Perhaps a little more text and less pictures would help}
  \fi
  \setbox\s@vedpage=\copy255
  % split the galley to the actual size available
  \setbox\colA=\vsplit255 to \availht
  %\setbox\colA=\vbox{\unvbox\colA}
  % and check if it all fit; if not, we'll have to back up and try again
  \ifvoid255 \fitonpagetrue \else \fitonpagefalse \fi
```

But we examine what happens if it does completely fit on the page. If it does,
then it is the largest amount of text that does otherwise a previous round would
have fit.

The macro we create here ❸ returns a list of vboxes to be output as the main body
of the page, excluding headers.
We calculate the width of the page being the textwidth minus the ExtraRMargin
that allows for unbalanced pages. The side margins are set together to be the
same. This allows a user to unbalance them if they really want. The first vbox
is the partial content from a previous book or whatever. Then comes the topins
insert containing any top span images. Then we measure the depth of the main
text box and output it. If there is a bottomins (bottom span images) then we
remove the depth in order to get the content to balance, and output the
bottomins. Finally we output the notes. This is done using m@kenotebox which
outputs all the notes into box2:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="971"}
\def\m@kenotebox{
  \setbox2=\vbox{
  \let\\=\ins@rtn@tecl@ss \the\n@tecl@sses % output all note classes
  \iff@rstnote % no notes actually occurred!
    \trace{i}{No notes}
    \ifnoteseen\MSG{Page \the\pageno\space is being printed without any footnotes/xrefs, etc. But at least one was seen earlier. Maybe it's ended up on the previous page or moved to the next one, or maybe it's vanished. Human checking is needed.}\fi
    \kern-\dimen0 \vfil
  \else
    \setbox0=\lastbox
    \trace{i}{Inserted notes, ht \the\ht0\space dp \the\dimen0}
    \dimen0=\dp0 \box0 \kern-\dimen0
  \fi}}
```
This macro uses the note processing macros to collect the content of the notes
into the vbox2. If there are no notes, then potentially warn users that some
notes that were seen earlier haven't been output and perhaps some notes will
appear on the wrong page. Also if there are no notes, we turn the box into an
empty filler that expands to take up the rest of the page. Notice we have to
undo the initial note spacing kern. On the other hand if there are notes then we
take off the last box from the list, measure its depth, put it back and then
kern upwards to ignore the depth.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="394"}
  \iffitonpage
    \trace{i}{1 SUCCEEDED, shipping page hIns=\the\holdinginserts}
% at this point:
%   \box\colA is the page content
%   \availht is ht that definitely works
    \def\pagecontents{%                                                     ③
%      \msg{upwards mode = \the\XeTeXupwardsmode}
      \dimen1=\textwidth \advance\dimen1 -\ExtraRMargin
      \trace{b}{BALANCE pangeoutins: cols=1: text=\the\ht\colA, \the\dp\colA: partial=\the\ht\partial, \the\dp\partial: topins=\the\ht\topins: bottomins=\the\ht\bottomins}
      \ifvoid\partial\else \vbox{\hbox to \dimen1{\hskip\columnshift\vbox{\unvbox\partial}}} \fi
      \ifvoid\topins\else \vbox{\hbox to \columnshift{}\box\topins} \vskip\skip\topins \fi
      \dimen0=\dp\colA
      \hbox to \dimen1{\hbox to \columnshift{}%
        \box\colA\hbox to \ExtraRMargin{}\hfil}
      \ifvoid\bottomins\else \vfil\kern-\dimen0 \dimen0=0pt \vskip\skip\bottomins \hbox{\hbox to \columnshift{}\box\bottomins} \fi % output bottom spanning pictures
      \f@rstnotetrue%
      \m@kenotebox
      \trace{b}{BALANCE pageouttxt: notes=\the\ht2 , \the\dp2 \space Leaving \the\ht255, \the\dp255}
      \ifdim\ht2<0pt\trace{b}{Strange notes height}\fi
      \unvbox2
    }
```

Having created the pagecontent macro, we reset the vertical page size back to
full size:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="523"}
\def\resetvsize{\trace{o}{resetvsize}\global\vsize=\textheight} 
```
Then, ❹ if there is actually some text to output we run the `\plainoutput` to ship
out the pagecontents. We also reset the page marks and if there are figure pages
to output, ship those out too. Otherwise there is no contents on this page so
dump anything that is left from splitting off this page (which should be
nothing). Now we prepare to return to main text processing. We start capturing
inserts again. But we may have been executed from a previous output routine that
found it had more than a page full while trying to collect for a partial page.
In which case ❺ we need to go back to where we came from and clear the flag.
Otherwise just set the output routine back to normal single column processing.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="417"}
    \resetvsize
    \ifdim\ht\colA>\baselineskip\plainoutput\trace{p}{plainoutput from onecoltrial}%    ④
      \xdef\p@gefirstmark{}\xdef\p@gebotmark{}%
      \nextshipout
    \else\setbox0=\box255\deadcycles=0\fi % dump empty pages (typically at end)
    \global\holdinginserts=1
    \ifrerunsavepartialpaged\trace{o}{onecoltrial: rerunsavepartialpage}%
      \global\output={\savepartialpage}\global\rerunsavepartialpagedfalse               ⑤
    \else\global\output={\onecol}\fi
```

But what if the contents overfilled the page. We need to reduce the textheight
that the page breaker works with (`vsize`) and go around again. We do this line
by line in case there are figures or notes that would therefore be removed from
the page by such a reduction. The mechanics are pretty straightforward. We
reduce the `vsize` by a line; clear out the various insertion boxes; clear the
note boxes; clear the processing box and turn off insertion expansion. Then we
set the variable that tells the `backingup` macro which macro to rerun. Then we
set the output routine to the backingup macro and rerun with the same galley we
started with.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="428"}
  \else % the contents of the "galley" didn't fit into the actual page,
        % so reduce \vsize and try again with an earlier break
    \trace{i}{1c REDUCING VSIZE hIns=\the\holdinginserts}
    \global\advance\vsize by -\baselineskip
    \global\setbox\topins=\box\voidb@x
    \global\setbox\bottomins=\box\voidb@x
    \let\\=\cle@rn@tecl@ss \the\n@tecl@sses
    \global\setbox255=\box\voidb@x
    \global\holdinginserts=1
    \global\let\whichtrial=\onecoltrial
    \global\output={\backingup}
    \unvbox\galley \penalty\ifnum\galleypenalty=10000 0 \else \galleypenalty \fi
  \fi
}
```

### Backing up

The backing up macro is a shared macro for all page layouts. This is the main
iteration routine for when the trial routine needs to reduce the page size and
try again. It resets `deadcycles` so that TeX won't complain if we have tried
more than say 25 times. Since this macro is an output routine, box255 is what
was output, which was the previous value of `galley` anyway. So we capture it
back into the galley box, and also capture the outputpenalty used. We set the
output routine to whatever we were told to make it. Since we are
running a trial, we want to expand out the inserts and again we reprocess all
the text, but with the new `vsize` so the cut will be in a different place.
Again we set the penalty.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="1069"}
\def\backingup{% this output routine is used when we reduce \vsize;
               % it will cause a new page break to be found, and then the \trial routine is called again
  \trace{o}{backingup hIns=\the\holdinginserts(==1)}
  \global\deadcycles=0
  \global\setbox\galley=\copy255
  \global\galleypenalty=\outputpenalty
  \global\output={\whichtrial}
  \global\holdinginserts=0
  \unvbox255% eject
  \penalty\ifnum\outputpenalty=10000 0 \else \outputpenalty \fi
}
```

### Partial Pages

The third component to a layout is the partial page macro that collects the end
of some text in that layout into the `partial` box ready to switch layout. The
macro starts by collecting the page bottom mark. We calculate a trial height and
then update it by inserts and notes.

c@lcavailht is the routine for calculating and setting up the various parameters
for a page measurement. It sets the marks and sets available height to the trial
height. Then it reduces  that available height by the heights of the notes, then
we round the result up to the nearest line grid. Then we subtract any top and
bottom inserts (figures). Advancing by `-\dp255` and `\dp255` just shifts the
grid somewhat (the amount of actual descent of the last line in the text).

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="882"}
\xdef\p@gebotmark{}% No guarantee this will be universally set
\def\c@lcavailht{
  \edef\t@st{\p@gefirstmark}%
  \ifx\t@st\empty\xdef\p@gefirstmark{\firstmark}\fi% remember first, if not already set
  \edef\t@st{\p@gebotmark}%
  \ifx\t@st\empty\xdef\p@gebotmark{\botmark}\fi
  %NOT HERE! \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \availht=\trialheight % amount of space we think is available
  \trace{i}{C@lcavailht partial:\the\ht\partial \space available:\the\availht}%
  \f@rstnotetrue
  \let\\=\reduceavailht\the\n@tecl@sses % reduce it by the space needed for each note class
  \trace{i}{after inserts: \the\availht}%
  \trace{o}{availht = \the\availht, depth = \the\dp255}%
  \advance\availht -\dp255
  % Round to lines accurate to 1/8pt in lineskip. 1/10pt causes overflow on longer pages. Support two column legal.
  \dimen0=8\baselineskip
  \multiply\availht by 8 \divide\availht by\dimen0 \multiply\availht by\dimen0 \divide\availht by 8
  \decr{\availht}{\topins}% and by the space needed for spanning pictures
  \decr{\availht}{\bottomins}%
  \advance\availht by \dp255 % split includes depth so give it space for that
  \trace{o}{new availht=\the\availht, topins=\the\ht\topins, bottomins=\the\ht\bottomins, baselineskip=\the\baselineskip}%
  \splittopskip=\topskip
}
```

Having calculated the available height we split the page to that height. If
there is nothing left then we are dealing with a simple partial capture.
Otherwise we will need to output a full page and then capture the rest.

The partial box is much like a page contents box. It starts with any previous
partial box followed by any top insert. Then comes the text contents and bottom
inserts. Then come any notes.

Since we have got to the end of a notional page, we reset the `vsize`. We ship
out any remaining ship outs. If there is text there is the added question of
whether this partial page takes up too much of a page to put anything under it.
In that case we ship it out as page content.

If, on the other hand there is more content than can fit on a page, then we need
to back up and reprocess as a single column full page, but we tell the single
page page output to call us back once it has finished. We do this by clearing
the insert and note boxes, telling backingup what to call and then calling
`backingup`.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="529"}
\def\savepartialpage{% save a partially-full page when switching to 2-column format,
  \xdef\p@gebotmark{\botmark}
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \c@lcavailht
  \setbox\s@vedpage=\copy255
  % split the galley to the actual size available
  \setbox\colA=\vsplit255 to \availht
  \setbox\colA=\vbox{\unvbox\colA}
  % and check if it all fit; if not, we'll have to back up and try again
  \ifvoid255 \fitonpagetrue \else \fitonpagefalse \fi
  \trace{o}{savepartialpage \the\ht\colA rem=\the\ht255}
  \iffitonpage
    \global\setbox\partial=\vbox{
      \ifvoid\partial\else \unvbox\partial \fi
      \ifvoid\topins\else \unvbox\topins \vskip\skip\topins \fi
      \dimen0=\dp\colA
      \dimen1=\textwidth \advance\dimen1 -\ExtraRMargin \advance\dimen1 -\columnshift
      \hbox to \dimen1{%\hbox to \columnshift{}%
        \box\colA\hbox to \ExtraRMargin{}\hfil}
      \ifvoid\bottomins\else\kern-\dimen0 \dimen0=0pt \vskip\skip\bottomins \unvbox\bottomins \fi
      \f@rstnotetrue
      \m@kenotebox
      \trace{b}{BALANCE pageouttxt: notes=\the\ht2 , \the\dp2}
      \unvbox2
    }
    \resetvsize%
    \ifdim\ht\colA>\baselineskip\plainoutput
      \xdef\p@gefirstmark{}\xdef\p@gebotmark{} \nextshipout
    \else\trace{o}{Page empty cols=\the\ht\colA, \the\ht\colB, partial=\the\ht\partial}\setbox0=\box255\deadcycles=0\fi % dump empty pages (typically at end)
      \tempfalse%
      \ifdim\ht\partial>\PageFullFactor\textheight \temptrue\fi%
      \ifnum\outputpenalty<-10000 \temptrue\fi%
      \iftemp\def\pagecontents{\box\partial}\plainoutput 
      \xdef\p@gefirstmark{}\xdef\p@gebotmark{}\nextshipout
    \fi
    \global\holdinginserts=1
  \else % the contents of the "galley" didn't fit into the actual page,
        % so reduce \vsize and try again with an earlier break
    \trace{i}{2c REDUCING VSIZE hIns=\the\holdinginserts}
    \@mptyinserts
    \global\advance\vsize by -\baselineskip
    \let\\=\cle@rn@tecl@ss \the\n@tecl@sses
    \global\let\whichtrial=\onecoltrial
    \global\output={\backingup}
    \global\rerunsavepartialpagedtrue
    \ifm@rksonpage\else\gdef\p@gefirstmark{}\trace{H}{No marks found. Setting empty mark}\fi%No marks on the page, and it didn't fit, so add a blank mark
    \unvbox\s@vedpage \penalty\ifnum\galleypenalty=10000 0 \else \galleypenalty \fi
  \fi}
  % save 1 column material since we are switching to 2 columns
\newbox\partial
```

## Two Column Page Output

Two column output follows the same overall structure as single column output,
but it is more complicated. The `\twocols` macro is the output routine that is
called when a page fills in two column mode. This macro is identical to the
single column version `\onecol`, with the only difference being the output
routine that is called afterwards.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="582"}
\def\twocols{% primary output routine in 2-col mode
  \trace{i}{TWOCOLS @ \ch@pter:\v@rse, txtht=\the\textheight, partial=\the\ht\partial, hIns=\the\holdinginserts}
  % save copy of current page so we can retry with different heights
  \trace{b}{BALANCE pagebuild: cols=2: textheight=\the\textheight}
  \global\setbox\galley=\copy255
  \bgroup\setbox0=\copy255 \setbox1=\vsplit0 to \maxdimen\egroup
  \edef\t@mp{\splitbotmark}
  \ifx\t@mp\empty\else\global\m@rksonpagetrue\trace{H}{Found mark \splitbotmark}\fi
  \global\galleypenalty=\outputpenalty % save current penalty so we can restore it at (A)
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \global\output={\twocoltrial}
  \global\holdinginserts=0 % when doing trial place insertions into boxes
  \unvbox255 % force invoking \twocoltrial
  \penalty\ifnum\outputpenalty=10000 0 \else \outputpenalty \fi % (A) restore output penalty
  }
\newbox\galley
\newcount\galleypenalty
\newdimen\trialheight
```

The trial routine is called for each trial page size. It starts by calculating
the available height for the text and copying the unsplit page. The next step is
to create two vboxes, containing the text for the two columns: `colA` and
`colB`. The aim here is to have both boxes be balanced, even if, due to column
specific images, they are not the same size. To do this we use the `\balanced`
macro.

### Balanced

The task of `\balanced` is to answer whether we need to go around again with a
smaller page size. It starts by setting up the intended column heights based on
the available height. It then splits the text into two columns according to
their heights. We use routines to do these functions.

`s@tcols` calculates the specific column heights from the given initial overall
height. It does this by subtracting the heights of the column specific inserts
from each column:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="731"}
\def\s@tcolhts#1{
    \colhtA=#1 \decr{\colhtA}{\topleftins} \decr{\colhtA}{\bottomleftins}
    \colhtB=#1 \decr{\colhtB}{\toprightins} \decr{\colhtB}{\bottomrightins}
    \trace{o}{s@tcolhts: colhtA=\the\colhtA, colhtB=\the\colhtB, toprightins=(\the\skip\toprightins, \the\ht\toprightins), bottomrightins=(\the\skip\bottomrightins, \the\ht\bottomrightins)}%
}
```

Splitting a vbox into the column boxes involves copying the text box and
splitting it into each column box in turn. If the break involved in splitting a
box is impossibly bad then the split is undone and that column box is empty. If
after splitting the column boxes the left column is empty but the right isn't
and the right could fit into the space then swap the boxes. On the other hand if
the left column is overfull and the right column is empty and has space, then
swap the boxes. Left and right in this discussion is swapped for RTL text. We
also collect the bottom mark based on what was split.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="747"}
\def\spl@tcols#1{
    % even if \vsplit to 0pt, TeX will always pull one line from the input box over
    %\trace{o}{split params maxdepth=\the\splitmaxdepth, topskip=\the\splittopskip, colhtA=\the\colhtA, colhtB=\the\colhtB}
    \splittopskip=\topskip
    \setbox9=\copy#1
    \setbox\colA=\vsplit#1 to \colhtA \ifnum\badness>999999\setbox#1=\box9\setbox\colA\box\voidb@x\else\setbox\colA=\vbox{\unvbox\colA}\fi
    \setbox9=\copy#1
    \setbox\colB=\vsplit#1 to \colhtB \ifnum\badness>999999\setbox#1=\box9\setbox\colB\box\voidb@x\else\setbox\colB=\vbox{\unvbox\colB}\fi
    % swap boxes if either, colA is empty and colB full, or colB is empty and colA is over full.
    \ifvoid\colA\ifvoid\colB\else\ifdim\colhtA<\ht\colB\else\setbox\colA=\box\colB\fi\fi\fi
    \ifdim\ht\colA>\colhtA\ifdim\ht\colB<1pt\ifdim\ht\colA<\colhtB\setbox\colB=\box\colA\fi\fi\fi
    \xdef\p@gebotmark{\splitbotmark}
}
```

Returning to balanced, we have done an initial split into two columns ❶. It's
possible to specify a threshold as a number of baselines, that specifies if a
column is less than the threshold then shorten the page and go again. If there
is no more text left from the columns split then the text `fitonpage`. The
rebalance flag says whether to keep trying (with shorter pages). The basic loop
we will enter ❺ is measuring what if we were to shorten the page, with just the
text we have for this page, would we get a better balance between columns? For
example if the page is too long, then more text will end up in colA, whereas if
we were to shorten it, more would end up in colB until either we can't get all
the text in, or the columns balance.

Before that loop, ❷ we see if we haven't actually got any text onto the page. If
so then complain and put everything into colA and bail out. If the odd case
occurs that nothing was put on the page, but we consider the page full, then we
are totally confused and we bail the whole job! But enough of edge cases. If the
text all fits on the page, then we want to try to get a good balance. Otherwise
we are done and the calling routine can go around again.

We set up for the loop ❸ by calculating a `shortavail` variable which gets used to
decide how out of balance we are. It is the sum of the amount of space left in
each column after the split. If the difference is really bad then to save time,
we take the average of the two column spaces and reduce both columns by that
amount. Then we do a quick loop splitting the columns to see if they still fit
into the page. If not, increase the allocation for each column by a baseline and
try again. We try keep trying until we find a pair of column allocations that
will consume all the text (given even our starting values achieved that).

❹ Since we are after a new overall available height, we need to think in terms of
the original `availht` that would result in the colhts we have. To do this we call
`\g@tcolhts`. This does the opposite from `\s@tcolhts` in that it adds back the
heights of the inserts:

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="739"}
\def\g@tcolhts{
    \colhtA=\ht\colA \incr{\colhtA}{\topleftins} \incr{\colhtA}{\bottomleftins}
    \colhtB=\ht\colB \incr{\colhtB}{\toprightins} \incr{\colhtB}{\bottomrightins}
    \trace{o}{g@tcolhts: colhtA=\the\colhtA, colhtB=\the\colhtB}%
}
```

We set our test height to the taller of the two columns. We then reduce colhtA
by a line and see if it would be less than colhtB, if so then we still need to
rebalance and we use colhtB for our test height. Then we advance the test height
by a line to make sure that the first time we go round the loop we process the
currently calculated heights.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="763"}
\newdimen\availA \newdimen\availB
\def\BalanceThreshold{0}

\def\balanced{
  \setbox0=\copy\s@vedpage
  \s@tcolhts{\availht}\spl@tcols0                                               ①
  \ifnum\BalanceThreshold>0
    \availA=\colhtA \availB=\colhtB
    \advance\availA by -\BalanceThreshold\baselineskip
    \advance\availB by -\BalanceThreshold\baselineskip
  \else
    \availA=0pt \availB=0pt
  \fi
  % and check if it all fit; if not, we'll have to back up and try again
  \ifvoid0 \fitonpagetrue \else \fitonpagefalse \fi
  \rebalancefalse
  \trace{o}{first \the\availht . col=\the\ht\colA, \the\colhtA . second col=\the\ht\colB, \the\colhtB . rem=\the\ht0}
  \ifdim\ht\colA<.5\baselineskip\ifdim\ht\colB<.5\baselineskip\MSG{I can't break this page!}    ②
    \iffitonpage\s@ve@nd \trace{o}{Abandoning ship}% the split failed and there is nothing left!
    \else\setbox\colA=\box0\setbox\s@vedpage=\box\voidb@x \trace{o}{Everything to colA}% dump it all in colA and bail
  \fi\fi\fi
  \iffitonpage
    \shortavail=\colhtB \advance\shortavail by -\ht\colB                        ③
    \advance\shortavail by -\colhtA \advance\shortavail by \ht\colA
    \ifdim\shortavail>5\baselineskip
      \trace{o}{Rebalance trying from average \the\shortavail of \the\colhtA =\the\ht\colA, \the\colhtB =\the\ht\colB}
      \divide\shortavail 2% \advance\shortavail by -0.5\ht\colA \advance\shortavail by -0.5\ht\colB
      \advance\colhtA by -\shortavail \advance\colhtB by -\shortavail
      \loopcount=0
      \loop\setbox0=\copy\s@vedpage
        \advance\colhtA by \baselineskip
        \advance\colhtB by \baselineskip
        \spl@tcols0
        \ifvoid0\loopcount=10\fi  
        \ifnum\loopcount=10\repeat % so ugly you can't \else\repeat
      \trace{o}{Rebalance starting with \the\colhtA, \the\colhtB}
    \fi
    \g@tcolhts                                                                  ④
    \ifunbalanced\shortavail=\availht\else\ifdim\colhtB<\colhtA \rebalancetrue \shortavail=\colhtA\fi\fi
    \advance\colhtA -\baselineskip\ifdim\colhtA<\colhtB \rebalancetrue \shortavail=\colhtB\fi
    \advance\shortavail \baselineskip
```

Now for the main rebalancing loop. We initialise it by keeping track of how many
times we have been around the loop. We also turn off overfull box warnings,
which have already happened for the boxes we are involved in. We don't need the
same warning 20 times. We enter the loop. ❺

Inside the loop we advance the loop counter and reduce the test height by a
line. We copy the box of text and we adjust the actual height by the depths of
the current columns. Not ideal, but better than nothing. Then we set up for this
new trial height and split to the column boxes again at this new height.
`rem@inder` if false, indicates that if the page is not
consumed at this height then we should backup and break out of the loop by
setting `\rebalancefalse`. We use the `rebalance` flag to tell us if we are
bailing from the loop and so not to do other tests. The next test ❻ is whether
either column is too short according to our threshold (as in really short as in
0 lines long). If it is then back up to the previous test height and stop
looping.

The next test ❼ tests the difference in full column beights (including the column
inserts). If the difference in heights is within a line of each other, we have
won. We calculate the resulting winning height as the greater of the two column
heights and then set the flag to say we are done.

The next two tests ❽ are boundary conditions. If the we are down to less than 2
lines or we've been around 20 times, then either reset the test height to the
starting value or just back up one line and stop looping. Otherwise go round
again and try a new shorter test height.

After finishing the loop, assuming we ran it and even if not, ❾ update the test
height with the greater of the depths of the two columns, set the official
returned requested column heights to the test height and resplit finally on the
actual s@vedpage we were tasked with splitting.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="806"}
    \loopcount=0
    \ifrebalance
      \vfuzz=\maxdimen
      \loop                                                                     ⑤
        \advance\loopcount by 1
        \advance\shortavail by -\baselineskip
        \setbox0=\copy\s@vedpage
        \dimen0=\shortavail\advance\dimen0 by \ifdim\dp\colA>\dp\colB \dp\colA\else\dp\colB\fi
        \s@tcolhts{\dimen0}\spl@tcols0
		% if something left in box0, it didn't fit, quit loop
        \trace{o}{re-balancing cols=\the\ht\colA =\the\colhtA, \the\ht\colB =\the\colhtB, from \the\shortavail, rem \the\ht0}%
        \ifrem@inder\else\ifvoid0\else
          \advance\shortavail by \baselineskip
          \advance\shortavail by \ifdim\dp\colA>\dp\colB \dp\colA\else\dp\colB\fi
          \trace{o}{rebalance found extra back to \the\shortavail}\rebalancefalse
          \setbox0=\copy\s@vedpage
          \s@tcolhts{\shortavail}\spl@tcols0
        \fi\fi
        % if either column height ends up negative, rollback and bail           ⑥
        \ifrebalance\ifnum\ifdim\colhtA<\availA 1\else\ifdim\colhtB<\availB 1\else 0\fi\fi =1
          \advance\shortavail by \baselineskip
          \trace{o}{rebalance found column height < 0, back to \the\shortavail}\rebalancefalse
          \setbox0=\copy\s@vedpage
          \s@tcolhts{\shortavail}\spl@tcols0
        \fi\fi
		% if second column longer than first column by more than .3*line height, quit loop
        \colhtA=\ht\colA \colhtB=\ht\colB
        \dimen0=\colhtB \incr{\dimen0}{\toprightins} \incr{\dimen0}{\bottomrightins}%
        \advance\dimen0 by -\colhtA \decr{\dimen0}{\topleftins} \decr{\dimen0}{\bottomleftins}%
        \ifdim\dimen0<.95\baselineskip\ifdim\dimen0>-.95\baselineskip           ⑦
          \shortavail=\colhtB\incr{\shortavail}{\toprightins}\incr{\shortavail}{\bottomrightins}%
          \ifdim\dimen0>0pt\else\advance\shortavail by -\dimen0\fi
          \advance\shortavail by \ifdim\dp\colA>\dp\colB \dp\colA\else\dp\colB\fi
          \trace{o}{Best height \the\shortavail}\rebalancefalse
        \fi\fi
		% give up if target size less than 2 lines (should not happen)
        \ifdim\shortavail<\baselineskip \MSG{Rebalancing bailed for short block}%   ⑧
          \shortavail=\availht \rebalancefalse\fi
        \ifnum\loopcount>20 
          \advance\shortavail by \baselineskip
          \rebalancefalse\MSG{Rebalancing loop count bail}\fi
        \ifrebalance\repeat
    \fi
    \advance\shortavail by \ifdim\dp\colA>\dp\colB \dp\colA\else\dp\colB\fi     ⑨
    \s@tcolhts{\shortavail}\spl@tcols\s@vedpage
    \trace{o}{A = \the\colhtA , B = \the\colhtB , remaining = \the\ht\s@vedpage}%
  \fi
}
```

### Two Column Trial

Returning to the two column trial routine, we have set up the trial height and
run `balanced` to try to balance the columns. We test to see if everything did fit
on the page. If it did but `balanced` left some over, then we didn't. On the
other hand if the page size has shrunk to 0 then anything will fit, let's just
ship a page and see if we can do better next time.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="986"}
\def\twocoltrial{% trial formatting to see if current contents will fit on the page
  \tracingparagraphs=0
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \c@lcavailht%
  \ifdim\availht<0pt
    \MSG{Page overfull with inserts. Perhaps a little more text and less pictures would help}
  \fi
  \setbox\s@vedpage=\copy255
  \trace{o}{balance from twocoltrial height \the\ht\s@vedpage}
  \rem@indertrue\balanced
  \iffitonpage\ifvoid\s@vedpage\else\fitonpagefalse\fi
  \else\ifnum\vsize<0 \fitonpagetrue\fi % no fit so dump the page we have now and try again with a new one.
  \fi
```

If we fit on the page, we better output it. The first thing we do is calculate
the box heights. To do this we get the full heights of each column, including
inserts. We then include those inserts into the two column boxes, also including
their text depths, which we set to be the same. We also return the height of the
tallest column including its depth as dimen3.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="857"}
\def\c@lcboxheights{
  \g@tcolhts
  \trace{b}{BALANCE pageout: cols=2: texta=\the\ht\colA , \the\dp\colA : textb=\the\ht\colB , \the\dp\colB : partial=\the\ht\partial, \the\dp\partial : topins=\the\ht\topins+\the\skip\topins, \the\ht\topleftins+\the\skip\topleftins, \the\ht\toprightins+\the\skip\toprightins : bottomins=\the\ht\bottomins+\the\skip\bottomins, \the\ht\bottomleftins+\the\skip\bottomleftins, \the\ht\bottomrightins+\the\skip\bottomrightins}
  \dimen0=\dp\colA \setbox\colA=\vbox to \availht{\unvbox\topleftins\box\colA\vfil\unvbox\bottomleftins}\dp\colA=\dimen0
  \ifdim\ht\colB<1pt\setbox\colB\vbox{\noindent\par}\else\ifdim\dimen0<\dp\colB\dimen0=\dp\colB\fi\fi
  \setbox\colB=\vbox to \availht{\unvbox\toprightins\box\colB\vfil\unvbox\bottomrightins}\dp\colB=\dimen0
  \ifdim\colhtA>\colhtB \dimen3=\colhtA\dimen0=\dp\colA\dp\colB=\dimen0\else
    \dimen3=\colhtB\dimen0=\dp\colB\dp\colA=\dimen0\fi
  \advance\dimen3 by \dimen0
}
```

As we output the page, the column boxes contain their column inserts. If the
right column is empty then make it empty, but not void. ❶ Set both boxes heights
to be the height allocated for them. We are ready now to create the pagecontents
macro that fills the core of the page. We start by calculating a width for the
contents. We output the previous partial content. Then we output any top insert
content. Then we output the column boxes. Note for right to left text, left is
right and right is left. I.e. really left is first and right is second. Then we
append any bottom inserts. Finally we output the notes as a single column.

❷ To output the page, we clear the box we were passed and reset vsize. Then we
call the `\plainoutput` routine to ship out the page. We will examine that
later. We clear the page reference marks and shipout any extra pages for full
page figures, etc. We reset holdinginserts back to what needs to happen for
normal page building. If we were called by a partial page builder, then we need
to call it back, otherwise reset ready the output routine for normal two column
page building and put back any unused content.

❸ If not everything fit on the page, then we need to reduce the page size a bit
and try again with a shorter page until it does all fit. To do that we have to
clear the various inserts and notes boxes, ❹ setup `backingup` to call us back and
set the output routine to `\backingup` and put everything back for reprocessing
at this new shorter height.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="1001"}
  \iffitonpage
    \c@lcboxheights
    \ifdim\ht\colB<1pt\setbox\colB\vbox{\noindent\par}\fi
    \ht\colA=\the\availht \ht\colB=\the\availht                             ①
    \def\pagecontents{%
      \trace{o}{Topins=\the\ht\topins, Bottomins=\the\ht\bottomins, tlins=\the\ht\topleftins, blins=\the\ht\bottomleftins, trins=\the\ht\toprightins, brins=\the\ht\bottomrightins}%
      \dimen1=\textwidth\advance\dimen1 by -\ExtraRMargin
      \ifvoid\partial\else %\msg{2colout partial: \the\ht\partial}\hskip\columnshift
        \vbox{\hbox to \dimen1{\hskip\columnshift\vbox{\unvbox\partial}}}\fi % output partial page
      \ifvoid\topins\else \hbox{\hbox to \columnshift{}\box\topins} \vskip\skip\topins \fi % output top spanning pictures
      \trace{p}{Text depth = \the\dimen3}%\showthe\dimen0
      \hbox to \dimen1{\hbox to \columnshift{}%
        \ifRTL \hbox to \ExtraRMargin{}\box\colB\makecolumngutter{\the\dimen3}{\the\availht}{\the\dimen0}\box\colA
        \else \box\colA\makecolumngutter{\the\dimen3}{\the\availht}{\the\dimen0}\box\colB\hbox to \ExtraRMargin{}\fi}
      \ifvoid\bottomins\else \kern-\dimen0 \dimen0=0pt \vskip\skip\bottomins \hbox{\hbox to \columnshift{}\vbox{\unvbox\bottomins}}\fi % output bottom spanning pictures
      \f@rstnotetrue
      \m@kenotebox
      \trace{b}{BALANCE pageouttxt: notes=\the\ht2 , \the\dp2}%
      \unvbox2
      \global\noteseenfalse%
    }
    \global\setbox255=\box\voidb@x                                          ②
    \resetvsize % reset size of next page since it will not have any 1 column material
    \plainoutput 
    \xdef\p@gefirstmark{}%
    \xdef\p@gebotmark{}%
    \nextshipout
    \global\holdinginserts=1
    \ifrerunsavepartialpaged
      \global\output={\savepartialpaged}\unvbox\s@vedpage\global\rerunsavepartialpagedfalse
    \else\global\output={\twocols}\unvbox\s@vedpage\fi
  \else % the contents of the "galley" didn't fit into the columns,         ③
        % so reduce \vsize and try again with an earlier break
    \trace{o}{Reducing vsize \the\vsize, by \the\baselineskip}%
    \global\advance\vsize by -\baselineskip
	% clear insertions
    \trace{i}{2coltrial: emptyinserts hIns=\the\holdinginserts}%
    \@mptyinserts
    \let\\=\cle@rn@tecl@ss \the\n@tecl@sses
    \global\let\whichtrial=\twocoltrial                                     ④
    \global\output={\backingup}
    \ifm@rksonpage\else\gdef\p@gefirstmark{}\trace{H}{No marks found. Setting empty mark}\fi%No marks on the page, and it didn't fit, so add a blank mark
    \unvbox\galley \penalty\ifnum\galleypenalty=10000 0 \else \galleypenalty \fi
  \fi}
\newif\iffitonpage
\newif\ifrebalance
```

### Partial Two Column Pages

When the macros transition from two columns to one column, then the two column
material needs to be collected into a `partial` box for later output when the
page ends. 

The entry routine for saving the partial page when in two columns is
`\savepartialpagedbounce` which prepares the way for calling `\savepartialpage`
by setting the stage in such a way as if a previous page had just been output by
`\twocoltrial`. It sets up the trial height and calculates an `availht`. It sets
the page length to double that size (for two columns) but reduces that by one
line. _why?_ It then sets the output routine to `\savepartialpaged` to do the
actual page processing. It collects the output text into a galley box and
reboxes it at its natural height, in case it has been forced to a height. It then splits
the box to infinity to get the bottom mark. It turns of holdinginserts so that
the inserts get pulled out into boxes and reprocesses the main text passed in
and forces a page break. No need for subtleties here since we are wanting to
force output.

_The reason for the bounce is to do with holdinginserts=0 when we need 1_

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="1083"}
\xdef\p@gefirstmark{}
\def\savepartialpagedbounce{
  % This output routine gets the partial galley (input text) before a 2->1 column transition
  % so that it can be re-run with holdinginserts=0, so footnotes etc can be seen.
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \c@lcavailht
  \vsize=2\availht
  \advance\vsize by \baselineskip
  \global\output={\savepartialpaged}
  \global\setbox\galley=\copy255 \global\setbox\galley=\vbox{\unvbox\galley}
  \bgroup\setbox0=\copy255 \setbox1=\vsplit0 to \maxdimen\egroup
   \edef\t@mp{\splitbotmark}
   \ifx\t@mp\empty\else\global\m@rksonpagetrue\trace{H}{Found mark \splitbotmark}\fi
  \trace{o}{sppb hIns=\the\holdinginserts, pt:\the\ht\partial, g:\the\ht255, \the\ht\galley}
  \global\holdinginserts=0
  \unvbox255\eject
}
```

Now we come to the actual saving of the partial page. This is much like the two
column trial. We start by calculating the trial and available heights. We
collect the saved page at a natural height (no stretch of shrink). The natural
height is probably only useful for debug.

If there is no room on the page, we still balance because it sets things up for
us, even when there is no space. But normally we balance the columns. If
everything fits on the page then we have all we need to collect the partial box.
We calculate the two column boxes and their heights and we collect the
depth of the previous partial box. In creating a new partial box we include the
previous partial box and then undo the vertical space added for the depth of the
box. This is doubled because it was added when the partial box was created and
it was added in the unvboxing (_this is probably nonsense_) The we add the top
insert. Then we calculate the width of the two columns and the gutter and create
a box that horizontally has the first column, the guttern, the second column and
any `ExtraRMargin`. The order is reversed for right to left layout.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="908"}
\newif\ifrerunsavepartialpaged
\def\savepartialpaged{%
  \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
  \c@lcavailht
  \setbox\s@vedpage=\vbox{\unvbox255}
  \trace{o}{balancing from savepartialpaged, height=\the\ht\s@vedpage, hIns:\the\holdinginserts, vsz=\the\vsize}
  \ifdim\availht<\baselineskip 
    \rem@indertrue % No, I don't know what this does, but once If i  didn't do it then we get lost verses. 
    %\rem@inderfalse
    \balanced\fitonpagetrue % There's certainly no point shrinking past this
  \else
    \rem@inderfalse\balanced
  \fi
  \iffitonpage
    \c@lcboxheights
    \ht\colA=\dimen3 \ht\colB=\dimen3
    \dimen4=\ht\partial \dimen5=\dp\partial
    \global\setbox\partial=\vbox{
      % bodge the partial box which should really have been properly textually merged
      % the problem is that savepartialpaged can get called twice in succession because
      % not all the output text (after a \singlecolumn) was passed the first time
      \ifvoid\partial\else\trace{o}{nested partial}\unvbox\partial\vskip -2\dimen5\fi
      \ifvoid\topins\else \hbox{\hbox to \columnshift{}\box\topins} \vskip\skip\topins \fi % output top spanning pictures
      \dimen5=\textwidth\advance\dimen5 by -\ExtraRMargin\advance\dimen5 by -\columnshift %
      \vbox{\hbox to \dimen5{%\hbox to \columnshift{}
        \ifRTL \hbox to \ExtraRMargin{}\box\colB\makecolumngutter{\the\dimen3}{\the\dimen3}{\the\dimen0}\box\colA %
        \else \box\colA\makecolumngutter{\the\dimen3}{\the\dimen3}{\the\dimen0}\box\colB\hbox to \ExtraRMargin{}\fi}}}
    %\advance\dimen3 by \dimen4 \ht\partial=\dimen3
```

The column gutter is not the simplest thing to create and so we have a macro for
it. This is given the height of the column boxes to calculate the height of the
vertical column gutter rule, the height of the column boxes again to give the
height of the box that is to be returned and the maximum depth of the two
columns, which is a side effect of running `\c@lcboxheights`. From these we
assemble a box that is centred. If there is a ColumnGutterRule then we create a
vertical rule of an appropriate height inside an hbox which is shifted down by
the ColumnGutterRuleSkip. This whole box is given an appropriate depth as passed
in and then centred with a right hand column shift. This is passed back for
inclusion in the horizontal list of boxes. 

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="1050"}
\newdimen\columnshift \columnshift=0pt
\newdimen\ColumnGutterRuleSkip \ColumnGutterRuleSkip=0pt

%makecolumngutter{rule height}{vbox height}{depth}
\def\makecolumngutter#1#2#3{\hfil
  \dimen4=#1\advance\dimen4-\ColumnGutterRuleSkip%\advance\dimen4 by #3
  \ifColumnGutterRule
    \setbox4=\vbox to #2{
      \vskip\ColumnGutterRuleSkip
      \hbox to 1pt{\vrule height \the\dimen4}%\dp5=#3 \box5
      \vfil}
    \dp4=#3 \box4
  \fi
  \hfil
  \hbox to \columnshift{}}
\newif\ifColumnGutterRule
```

The resulting horizontal list, for left to right is: colA, hfil,
vbox(hbox(vrule) vrule) hfil columnshift colB ExtraRMargin.

Having created the partial box, we reset ready to resume text collection. Then,
now that we have a new partial box, we calculate the space left on the page. If
it's less than 2 lines, we ship out a completed page and then put all remaining
text (of which there should be none) back onto the contributions list, with a
reset penalty.

But, if the text does not fit on a page, then we need to output a page to use up
the text and try again. To do that we empty the insert boxes and set up the
backingup to use `\twocoltrial` which we also set up to call us back when it is
done. If the galley is empty then use whatever was passed to us, now in
`s@vedpage`, otherwise use the galley.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="938"}
    \trace{o}{sppd: saved partial, ht:\the\ht\partial\space rem:\the\ht\s@vedpage}
    \global\holdinginserts=1
    \global\setbox255=\box\voidb@x
    \global\trialheight=\textheight \global\advance\trialheight by -\ht\partial
    \c@lcavailht
    \trace{o}{spdd: partial=\the\ht\partial, textheight=\the\textheight, availht=\the\availht}
    \ifdim\availht<2\baselineskip \twocolp@geout \fi
    \unvbox\s@vedpage\penalty\ifnum\outputpenalty=10000 0 \else \outputpenalty \fi
  \else
    \trace{o}{sppd: Not fit on page}
    \trace{i}{sppd: emptyinserts hIns=\the\holdinginserts, \the\ht\partial, vs:\the\vsize}
    \@mptyinserts
    %\global\advance\vsize by -\baselineskip
    %\global\let\whichtrial=\savepartialpaged
    \global\let\whichtrial=\twocoltrial
    %\global\rerunsavepartialpagedtrue
    \global\output={\backingup}%
    \tempfalse%\ifvoid\partial\else\temptrue\fi%
    % remember \holdingInserts=1 from \@emptyinserts
    \ifvoid\galley\temptrue\fi
    \ifm@rksonpage\else\gdef\p@gefirstmark{}\trace{H}{No marks found. Setting empty mark}\fi%No marks on the page, and it didn't fit, so add a blank mark
    \iftemp
     \trace{i}{Using savedpage.pen=\the\outputpenalty}%
     \unvbox\s@vedpage\penalty\ifnum\outputpenalty=10000 0 \else \outputpenalty \fi
    \else%
     \trace{i}{Using galley. pen=\the\galleypenalty}%
     \unvbox\galley\penalty\ifnum\galleypenalty=10000 0 \else \galleypenalty \fi
    \fi%
  \fi%
}
```

The routine that implements the shipping out of a completed page in two columns


## Switching Column Layouts

There are two macros that switch between the two layouts.

### Switching to Double Columns

The first is triggered
when switching from single column to double column, for examples between
introductory material and the main text of a book. We start by undoing the
last depth to bring the baseline back to the baseline and then close of any
headings. Between layouts is a pretty good place to break and if there is no
break here, insert a line's worth of gap. Now collect the current contributions
into a single column partial. We measure the partial to see if it is larger than
the specified PageFullFactor of a page. If it is then set up to output as a full
single column page. Since there may actually be a number of pages worth, which
will all be output, we reduce the measurement to modulo a page size. Then unbox
the partial back into the contributions and if we still are over the
PageFullFactor then fill up the rest of the page and force the page break.
Otherwise switch to collecting into partial and force the page break to collect
it.

Now set up for 2 column mode. Set the `hsize` and `vsize` taking into account
partials and that we double the `vsize` since we need to fill two column's worth
of text before page breaking. We redefine `\resetvsize` so that it does that
appropriately for 2 columns. Then set the appropriate output routine for page
breaking and we are now in 2 column mode. Top and bottom inserts basically cost
double because they take up space in both columns. We reset the count for each
note class, described below.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="466"}
\def\PageFullFactor{0.9}
\def\doublecolumns{
  \ifnum\c@rrentcols=1
    % make switch from single to double column
    \vskip-\lastdepth
    \ifhe@dings\endhe@dings\fi % if headings in process, end headings
    \penalty-100\vskip\baselineskip % ensure blank line between single and double column material
    \global\output={\savepartialpage}\eject % save any partially-full page
	% if single column material already fills 3/4 page, go to next page to start double columns
    \dimen0=\ht\partial
    \ifdim\dimen0>\PageFullFactor\textheight
%%%      \msg{Output full page from 1 to 2 columns}%
      \global\output={\onecol} % but output it immediately if 75% full
      \loop\ifdim\dimen0>\textheight\advance\dimen0-\textheight\repeat
      %\vbox{\hskip-\columnshift\box\partial}
      \unvbox\partial
      \ifdim\dimen0>\PageFullFactor\textheight\vfill\eject
        \else\global\output={\savepartialpage}\eject
      \fi
    \else
      %\hsize=\textwidth
      %\setbox\partial=\vbox{\hskip\columnshift\box\partial}
    \fi
    % reset parameters for 2-column formatting
    \global\hsize=\colwidth\trace{o}{doublecolumn vsize doubles}
    \global\vsize=2\textheight % in 2 col mode you can put twice the height of text
	\global\advance\vsize by -2\ht\partial % subtract height of 1 column material
	\global\advance\vsize by 2\baselineskip % don't get caught short by 1/2 line or so
	% make a macro reset vsize for remaining pages which do not have 1 column material
    \trace{o}{Going to 2 col, textheight \the\textheight - \the\ht\partial}
    \gdef\resetvsize{\trace{o}{resetvsize2}\global\vsize=2\textheight \global\advance\vsize by \baselineskip} 
    \global\output={\twocols}
    \global\c@rrentcols=2
    % top and bottom inserts effectively use twice their height
	% (\count of an insertion class is a scaling factor)
    \count255=2000
    \global\count\topins=\count255
    \global\count\bottomins=\count255
    \let\\=\s@tn@tec@unt \the\n@tecl@sses % reset \count for each note class
    \global\holdinginserts=1 % don't pull out inserts yet, we are still adjusting page
    %\msg{Starting 2col partial: \the\ht\partial, pagetotal: \the\pagetotal, vsize: \the\vsize}
  \fi}
```

Each note class, since it is associated with an insert, has a count associated
with it. This count is a multiplier of the size of the insert against the
overall height of the page. The routine to clear the count for a particular note
class finds the particular note class for a note type. It is then checked for
whether it is paragraphed notes (those that run on into one paragraph total for
all notes). Then the count for the insert is set based on paragraphed notes
costing 0, diglot notes costing half and full width notes costing whatever a
span insert costs, which for double column is 2. In addition every note has an
`AboveNoteSpace` fixed cost as well.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="511"}
% iterate over note classes, set \count for each class  
\def\s@tn@tec@unt#1{%
  \x@\let\x@\th@cl@ss\csname note-#1\endcsname
  \checkp@ranotes{#1}%
  % notes made into paragraphs (e.g. \x) are counted as 0 height for now,
  % later we will backup making page size smaller until things fit
  % Diglot prefers to get things closer 1st time round...
  \global\count\th@cl@ss=\ifp@ranotes \ifdiglot 500\else 0\fi \else \count255 \fi
  \global\skip\th@cl@ss=\AboveNoteSpace }
```

### Switching to Single Columns

Switching to single column mode is somewhat simpler than switching to double
column mode since there is no worry about the grid. We close any headings and
set up to capture the current content into a 2 column partial. Then we simply
eject twice to really ensure everything is output. Then we set up for single
column working with `hsize` and `vsize. If the partial page is enough to trigger
a complete page, we output that. Then we reset to single columns and change the
output routine to single column layout. As per the other we set the cost of a
span to 1 and set the costs of notes accordingly.

If the partial is not empty, we reset it to its natural height and then consider
what to do because we are basically between books. If we are not to eject
between books then we need to set the first mark for the new book otherwise we
insert a line gap and then insert a rule across the page with a 2 line gap under
it.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="1158"}
% to switch back to single column, we reset the page size parameters
\def\singlecolumn{%
  \trace{o}{singlecolumn hIns=\the\holdinginserts}%\tracingmacros=1
  \ifnum\c@rrentcols>1
    \ifhe@dings\endhe@dings\fi
    %\temptrue
    \global\output={\savepartialpagedbounce}\eject\eject % save any partially-full page into a box.
    %LOTS happens before this line is reached!
    \global\hsize=\textwidth \advance\hsize by -\columnshift
    \global\vsize=\textheight
    %\tempfalse
    \ifdim\ht\partial>\PageFullFactor\textheight
      \twocolp@geout \fi%Set up pagecontents and call \plainoutput
    \global\c@rrentcols=1
    \trace{o}{resetting resetvsize for singlecolumn}\def\resetvsize{\trace{o}{resetvsize}\global\vsize=\textheight} 
    \global\output={\onecol}
    \global\holdinginserts=1
    \count255=1000
    \global\count\topins=\count255
    \global\count\bottomins=\count255
    \let\\=\s@tn@tec@unt \the\n@tecl@sses % reset \count for each note class
    \ifdim\ht\partial>\baselineskip \vbox{\unvbox\partial}
      \ifendbooknoeject\ifx\p@gefirstmark\t@tle \else\vskip\baselineskip\hskip-\columnshift\hrule\vskip2\baselineskip\fi\fi
    \fi
  \fi}%
```

## Shipping Out The Page

The driving routine for shipping out a page is `\plainoutput`. The routine
conserves the pdf page dimensions, which the `shipwithcr@pmarks` may modify.
Then it passes a box for the page to the routine that adds any cropmarks. The
contents of that page are the head line the page body and the foot line. After
that we restore the pdf page dimensions and advance the page number. There is
check that the document is not stupidly long. The value of `@MM` is 20000 and is
only emitted in a supereject. Thus we are merely passing the supereject along.
Otherwise clear various flags.

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="235"}
\m@rksonpagefalse
% redefine plain TeX's output routine to add the cropmarks
\def\plainoutput{%
  \ifm@rksonpage\else\trace{m}{No marks on page \the\pageno}\fi
  \dimen9=\pdfpagewidth \dimen8=\pdfpageheight
  \shipwithcr@pmarks{\vbox{\makeheadline\pagebody\makefootline}}%
  \pdfpagewidth=\dimen9 \pdfpageheight=\dimen8
  \advancepageno
  \ifnum\pageno>10000\MSG{Error: Runaway page output}\s@ve@nd\fi
  \ifnum\outputpenalty>-\@MM \else\dosupereject\fi\global\m@rksonpagefalse\global\noteseenfalse
  }
```

The routines for creating the components of a page are not too complex. The
`\pagebody` routine just makes a box of the pagecontents. `\makeheadline` does a
bit more work in creating a box that is of the right height and shifted
appropriately for the head line. First it sets up to use the `\h` styling
information. Then it creates a vbox that looks to be 0 size, but is in fact
shifted up by the `topm@rgin` so that it touches the top of the paper. Then it
contains a vbox which is shifted down by the `\HeaderPosition` multiplier of
`\MarginUnit`. Then we create a box of the headline. The box is set to be 0.7
times the ascender of the `\h` font, and the headline box is added to the top
box we are creating. If there needs to be a heading rule, then this is
positioned and added. The inner box has infinite stretch and shrink added so
that it's size can be 0.

The footline is much simpler. It is merely a 0 height box containing a shift to
the bottom of the paper and then back up to the `FooterPosition`, where an hbox
of the correct width is added containing the footline macro expansion. Again
infinite vertical shrink and stretch is added to keep the box 0 height.

Details of the `\headline` and `\footline` may be found in the References
section.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="445"}
\def\pagebody{\vbox to\textheight{\boxmaxdepth\maxdepth \pagecontents}}
\def\makeheadline{%
  \g@tfontname{h}%
  %\def\f@ntstyle{h\ifdiglot\ifdiglotL L\else R\fi\fi}
  \vbox to 0pt{\kern-\topm@rgin
   \vbox{\kern\HeaderPosition\MarginUnit
    \setbox0=\vbox{\hbox to \textwidth{\the\headline}}
    \ht0=0.7\fontdimen6\csname font<\f@ntstyle>\endcsname \dp0=0pt \box0
    \ifrhr@le\ifdim\RHruleposition=\maxdimen\else
      \kern\RHruleposition \hrule
    \fi\fi}\vss}\nointerlineskip}
\newif\ifrhr@le
\def\makefootline{%
  \vbox to 0pt{\dimen0=\textwidth\advance\dimen0 by -\columnshift
    \kern\bottomm@rgin
    \kern-\FooterPosition\MarginUnit
     \hbox to \textwidth{\the\footline}\vss}}
\newdimen\RHruleposition \RHruleposition=\maxdimen
```

We are slowly following the path to the actual `\shipout` command that is found in
this routine. First we grow the pdf page if there crop marks are being added,
otherwise not. We undo TeX's default of shifting the page by 1in and then we
shipout the vbox for the page. Inside the vbox we insert special PDF structures
to store details about the page size. This is primarily towards providing
PDF/X1-A support. Next we decide which side any gutter margin goes on. Then we
do some magic for a certain class of document. Such documents achieve vertical
text through:

- Rotating the page so that left to right text is rendered vertically from top to
  bottom.
- Instructing TeX to assemble lines from the bottom of the page to the top.

`\ifrotate` is set in the first case. To ensure consistent results, we turn of
the uer's assembly issues. Also turn of rendering paragraphs from bottom to top.
We achieve the rotation by inserting a special to tell the xdvi converter to
rotate the page for us. After this we merge in any page specific underlays. The
`\m@rgepdf` is for watermarks. `\pl@ceborder` is for bringing in special page
borders. `\offinterlineskip` tells TeX not to output any inter line
space which might follow the `\special` or images. At last we come to the actual box that
is set to the PDF page height, but can stretch or shrink either way to keep its
contents in the centre vertically. Likewise it contains an hbox corresponding to
the page width containing the contents of whatever is being shipped out. Again
this is centred horizontally, even if it is wider than the box. Finally we do
any cropmarks.

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="85"}
\newif\ifrotate\rotatefalse
\newdimen\pdfcropwidth
\newdimen\pdfcropheight

\def\shipwithcr@pmarks#1{% \shipout box #1, adding cropmarks if required
  \dimen0=0\ifCropMarks .5\fi in
  \advance\pdfpagewidth by 2\dimen0 % increase PDF media size
  \advance\pdfpageheight by 2\dimen0
  \hoffset=-1in \voffset=-1in % shift the origin to (0,0)
  \let\pr@tect=\noexpand
  \shipout\vbox to 0pt{% ship the actual page content, with \BindingGutter added if wanted
    %%%%% The following was added to help produce proper x1a PDF output (djd - 20150504)
    %%%%% Note the \special line here seems to work but there may be a better location for it
    %%%%% Also, the numbers used are hard coded now but need to be calculated
    \ifCropMarks
      \pdfcropwidth=\pdfpagewidth\advance\pdfcropwidth by -\dimen0
      \pdfcropheight=\pdfpageheight\advance\pdfcropheight by -\dimen0
      \def\tmp{\dimen0}
      \special {pdf:put @thispage <</MediaBox [0 0 \strip@pt\pdfpagewidth \space
        \strip@pt\pdfpageheight ] /TrimBox [\strip@pt\tmp \space
        \strip@pt\tmp \space \strip@pt\pdfcropwidth \space
        \strip@pt\pdfcropheight ] /ArtBox [\strip@pt\tmp \space
        \strip@pt\tmp \space \strip@pt\pdfcropwidth \space \strip@pt\pdfcropheight ]>>}
    \else\trace{s}{pdfpagewidth=\the\pdfpagewidth}\special {pdf:put @thispage <</MediaBox [0 0 \strip@pt{\pdfpagewidth} \space
        \strip@pt{\pdfpageheight} ] /TrimBox [0 0 \strip@pt{\pdfpagewidth} \space
        \strip@pt{\pdfpageheight} ] /ArtBox [0 0 \strip@pt{\pdfpagewidth} \space
        \strip@pt{\pdfpageheight} ]>>}\fi
    % End inserted \special line
    \let\g@tterside=0 % figure out if we're adding a binding gutter, and which side
    \ifBindingGutter
      \ifDoubleSided
        \ifodd\pageno\ifRTL\let\g@tterside=R \else\let\g@tterside=L\fi
        \else\ifRTL\let\g@tterside=L \else\let\g@tterside=R\fi
        \fi
      \else\ifRTL\let\g@tterside=R\else\let\g@tterside=L\fi
      \fi
    \fi
    \edef\oldup{\the\XeTeXupwardsmode}
    \XeTeXupwardsmode=0 %
    \ifrotate
      \vbox to 0pt{\kern.5\pdfpagewidth  %\PaperWidth % swapped because rotated
        \hbox to 0pt{\kern.5\pdfpagewidth \special{x:gsave}\special{x:rotate -90}\hss}
        \vss}
    \fi
    \m@rgepdf
    \pl@ceborder % add PageBorder (or watermark) graphic, if defined
    \offinterlineskip
    \vbox to \ifrotate\pdfpagewidth\else\pdfpageheight\fi{\vss
      \kern\topm@rgin
      %\trace{g}{\the\topm@rgin - \the\bottomm@rgin}%
      \vbox{\hbox to \ifrotate\pdfpageheight\else\pdfpagewidth\fi{\hss\hbox{%
        \if\g@tterside L\kern\BindingGutter\fi
        \XeTeXupwardsmode=\oldup
        #1%
        \if\g@tterside R\kern\BindingGutter\fi
      }\hss}}
      \kern\bottomm@rgin
      \vss}
    \vss
    \docr@pmarks
    \ifrotate\special{x:grestore}\fi
  }%
  \let\pr@tect=\relax
}
```

### Cropmarks

Actually outputting any cropmarks is done by `\docr@pmarks`. If no crop marks
are to be output, this routine does nothing. If the two boxes for the top and
bottom crop marks don't yet exist, then make them. Then we create a 0 size vbox
containing the top and bottom crop marks carefully positioned. Also in the
bottom crop marks we output whatever is in `\c@rrID`, again into a 0 height box
with whatever shrink or stretch glue is needed after it.

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="191"}
\def\docr@pmarks{%
    \ifCropMarks % if crop marks are enabled
      \ifvoid\topcr@p \makecr@ps \fi % create them (first time)
      \vbox to 0pt{
        \kern\dimen0
        \moveright\dimen0\copy\topcr@p
        \kern\PaperHeight
        \moveright\dimen0\copy\bottomcr@p
        \moveright\dimen0\vbox to 0pt{\kern15pt\hsize\PaperWidth \everypar={}
          \lineskiplimit=0pt \baselineskip=10pt \linepenalty=200
          \leftskip=0pt plus 1fil \rightskip=\leftskip \parfillskip=0pt
          \noindent \beginL\idf@nt
            \csname c@rrID\endcsname\endL\endgraf % add the current \id line
          \vss}
        \vss
      }
    \fi}
```

Making the crop marks boxes is all about rules and kerns in the right place. The
top cropmarks box contains a horizontal line 25pt long starting 30pt to the left
of the page. Then a vertical line that is 25pt but is 5pt away from the other
line. So the lines would join, if extended, at the corner of the main page box.
But they are given a 5pt margin. Another line that is slightly shorter at 15pt
is output in line with the top margin down within the page. As text, across the
top between the crop marks, is output the jobname and timestamp. Then the
corresponding lines are drawn on the right hand side.

The same happens for the bottom box except the text along the bottom is
generated per page instead of per job and the margin lines correspond to the
bottom margin.

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="34"}
\newif\ifCropMarks
\font\idf@nt=cmtt10 scaled 700 % font for the marginal job information
\newbox\topcr@p \newbox\bottomcr@p
\def\makecr@ps{% construct the cropmark boxes for top and bottom of page
  \global\setbox\topcr@p=\vbox to 0pt{\vss
    \hbox to \PaperWidth{%
      \kern -30pt
      \vrule height .2pt depth .2pt width 25pt
      \kern 4.8pt
      \vrule height 30pt depth -5pt width .4pt
      \kern -30.4pt
      \dimen0=\topm@rgin \advance\dimen0 by -.4pt
      \vrule height -\dimen0 depth \topm@rgin width 15pt
      \kern 15pt
      \hss
      \raise20pt\vtop{\hsize\PaperWidth \everypar={}
        \lineskiplimit=0pt \baselineskip=10pt
        \leftskip=0pt plus 1fil \rightskip=\leftskip \parfillskip=0pt
        \noindent \beginL\idf@nt \jobname\ :: \timestamp\endL}%
      \hss
      \vrule height 30pt depth -5pt width .4pt
      \kern 4.8pt
      \vrule height .2pt depth .2pt width 25pt
      \kern -15pt
      \vrule height -\dimen0 depth \topm@rgin width 15pt
      \kern -30pt
    }%
  }\dp\topcr@p=0pt % end \vbox for \topcr@p
  \global\setbox\bottomcr@p=\vbox to 0pt{%
    \setbox0=\hbox to \PaperWidth{%
      \dimen0=\bottomm@rgin \advance\dimen0 by 0.4pt
      \kern -30pt
      \vrule height .2pt depth .2pt width 25pt
      \kern -15pt
      \vrule height \dimen0 depth -\bottomm@rgin width 15pt
      \kern 4.8pt
      \vrule height -5pt depth 30pt width .4pt
      \hss
      \vrule height -5pt depth 30pt width .4pt
      \kern 4.8pt
      \vrule height \dimen0 depth -\bottomm@rgin width 15pt
      \kern -15pt
      \vrule height .2pt depth .2pt width 25pt
      \kern -30pt
    }%
    \dp0=0pt\ht0=0pt\box0
  }\ht\bottomcr@p=0pt\dp\bottomcr@p=0pt% end \vbox for \bottomcr@p
}
```

### Borders and Watermarks

There are two kinds of overlays: borders and watermarks. They are in fact
underlays in that they are output before the page's main content. A page border
differs from a watermark in that it is positioned and scaled to fit the page and
then are shifted according to the binding gutter. The box containing the border
is created once and then copied into each page. This means that only one
instance of the border image is actually loaded into the PDF.

The watermark PDF file is simply underlaid on the output page and is scaled to
fit the page edge (the `media` box).

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="211"}
\def\PageBorder{}
\newbox\b@rder
\def\pl@ceborder{\ifx\PageBorder\empty\else % if \PageBorder is empty, this does nothing
  \ifvoid\b@rder % set up the \b@rder box the first time it's needed
    \global\setbox\b@rder=\hbox{\XeTeXpdffile \PageBorder \relax}%
    \global\setbox\b@rder=\vbox to \pdfpageheight{\vss
      \hbox to \pdfpagewidth{\hss\box\b@rder\hss}\vss}%
  \fi
  \vbox to 0pt{% respect binding gutter, just like main page content
    \hbox to \pdfpagewidth{\hss\hbox{%
      \if\g@tterside L\kern\BindingGutter\fi
      \copy\b@rder
      \if\g@tterside R\kern\BindingGutter\fi
    }\hss}
  \vss}% output a copy of \box\b@rder
\fi}

\def\MergePDF{}
\def\m@rgepdf{\ifx\MergePDF\empty\else
  \vbox to 0pt{\XeTeXpdffile \MergePDF \relax media\relax}
\fi}
```

## Processing Notes

There are a number of routines that run against all the notes. Usually they then
differentiate between paragraphed and separate notes.

For paragraphed notes, the core action is to turn the collection of notes into a
single paragraph. We start by setting the width of the paragraph we are making.
This depends on diglot side, etc.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="275"}
\newdimen\n@tewidth
\def\setn@tewidth{%
  \ifdiglot
    \ifdiglotSepNotes
      \ifdiglotL\n@tewidth=\columnLwidth\else\n@tewidth=\columnRwidth\fi
    \else\n@tewidth=\textwidth\fi
  \else\n@tewidth=\textwidth\fi
}
```

Making the paragraphed notes, we are passed the box containing the notes and the
marker for the class. We set the width to the width we just calculated.
We simplify the `\par` to just closing the paragraph and clear any chapter
dropped numbers, and clear any paragraph initial tokens. We are in an output
routine, if pretty deep, so there is no harm clearing these things. Then we
unpack the box of boxes, putting them back on the contributions list. And then
we call the routine that will walk back through the boxes, recollecting them.

A short excursus into converting a list of hboxes into one long hbox. We start
with an empty box and then loop back through the contributions list, which only
contains the hboxes we just unpacked. Each box is prepended to the list of
boxes, in effect reversing the list.

In addition we then need to assemble the paragraph by going through a list of
hboxes unpacking them and inserting `\internotespace` between each one. The
recursion means we start from the front of the list.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="329"}
\def\makehboxofhboxes{%
  \setbox0=\hbox{}%
  \loop\setbox2=\lastbox \ifhbox2 \setbox0=\hbox{\box2\unhbox0}\repeat} 
%
% remove inside level of boxing and adding inter note space after each
%     [[a][b][c]] --> [a \internotespace b \internotespace c \internotespace]
\def\removehboxes{%
  \setbox0=\lastbox 
  \ifhbox0{\removehboxes}\unhbox0\internotespace\fi}
%
% skip between notes in paragraph. skip is good place to break.
\def\internotepenalty{-10}
%\def\internotespace{\hfil\hskip\intern@teskip\penalty\internotepenalty\hfilneg}
\def\internotespace{\hskip\intern@teskip\kern 0pt\penalty\internotepenalty}
%\def\internotespace{\hfil\hskip\intern@teskip\penalty-10\hfilneg}
```

Returning to `\maken@tepara` ❶ We create a single line of all the notes
together. Then we set the baselineskip to use for the paragraph and also any
other paragraph settings. We also set the side skips for the paragraph based on
the `justification` parameter for the marker. We also adjust the width if there
is a columnshift for marginal verses. Then we start a new paragraph and set the
appropriate bidirectional direction. Then we unbox the hbox and stream the text
in. We remove any final penalty and skips, e.g. the final internoteskip. We
discourage line breaks, but not too much and break the paragraph into lines. And
the after clearing any leftskip, we are done.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="290"}
\newif\ifNoteTracing \NoteTracingfalse
\newskip\intern@teskip \intern@teskip=15pt plus 3pt minus 5pt
\newskip\noteRag\noteRag=0pt plus 18pt
\def\maken@tepara#1#2{%
  \setn@tewidth
  \hsize=\n@tewidth%\advance\hsize by -\columnshift % width is full page size
  \let\par=\endgraf\ch@pterfalse
  \everypar={}% don't do body text formatting
  \unvbox#1 % open up the vbox of notes to get at the list of individual note boxes
  \makehboxofhboxes % make a single hbox for all notes of this class
  \setbox0=\hbox{\unhbox0 \removehboxes}% add internote space                   ①
  \getp@ram{baseline}{#2}\ifx\p@ram\relax\else\baselineskip=\p@ram\fi
% Enable justification according to marker.
  \lineskiplimit=-10pt\leftskip=0pt\rightskip=0pt\parskip=0pt\parfillskip=0pt plus 1fil%\lineskip=10pt
  \getp@ram{justification}{#2}%
  \ifx\p@ram\c@nter
     \leftskip=\noteRag\rightskip=\noteRag
  \else\ifx\p@ram\l@ft
     \rightskip=\noteRag
  \else\ifx\p@ram\r@ght
     \leftskip=\noteRag
  \fi\fi\fi
  \ifdiglot\else
    \advance\leftskip by \columnshift%
  \fi
  %\showbox0
  \noindent % starting making new paragraph
  \ifRTL\beginR\fi % respect directionality
  \ifNoteTracing\tracingparagraphs=1\fi
  \unhbox0 % unbox the text so it can be line-wrapped
  \unskip\unpenalty\unskip\unskip % remove internote skip info after last note
  % set penalty which allows breaking between notes unless this would cause
  % an extra line to be created.
  \linepenalty50
  \trace{f}{Note #2 baselineskip=\the\baselineskip}
  \par\leftskip=0pt\ifNoteTracing\tracingparagraphs=0\fi}
```

### Measuring used space

The routine is called for each note class. WIthin that it analyses the note
class to call the appropriate routine for the note type. We also set a flag to
say whether any notes have been seen.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="605"}
\def\reduceavailht#1{%
  \checkp@ranotes{#1}%
  %\TRACE{av: \the\availht =>}
  \ifp@ranotes\let\n@xt=\reduceavailht@para
    \ifdiglot\ifdiglotSepNotes\ifdiglotBalNotes\let\n@xt=\reduceavailht@para@bal\fi\fi\fi
  \else\let\n@xt=\reduceavailht@sep
    \ifdiglot\ifdiglotSepNotes\ifdiglotBalNotes\let\n@xt=\reduceavailht@sep@bal\fi\fi\fi
  \fi
  \iff@rstnote\else\global\noteseentrue\fi\n@xt{#1}}
```

For paragraphed notes, we store the appropriate class (including diglot side)
and then we collect the insert (vbox) number. We test to see if there is
anything in the box. If there is, then we copy the box and turn it into a single
paragraph. With that paragraphed box, we simply reduce the available height by
the height and depth of the box. If we are the first note, then we reduce by
the `AboveNoteSpace` and clear the flag, otherwise we reduce by the `InterNoteSpace`
(which is different casing from the `internotespace` horizontal space between notes being
paragraphed).

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="617"}
\def\reduceavailht@para#1{
  \def\cl@sss{#1}%
  \ifdiglot\ifdiglotSepNotes\ifdiglotL\def\cl@sss{#1}\else\def\cl@sss{#1R}\fi\fi\fi%
  \TRACE{class \cl@sss}%
  \x@\let\x@\th@cl@ss\csname note-\cl@sss\endcsname
  \ifvoid\th@cl@ss\else
    \setbox0=\copy\th@cl@ss
    \setbox0=\vbox{\maken@tepara{0}{#1}}
    \advance\availht by -\ht0
    \advance\availht by -\dp0
    \iff@rstnote\advance\availht by -\AboveNoteSpace \f@rstnotefalse
    \else \advance\availht by -\InterNoteSpace\fi
    %\getp@ram{baseline}{#1}\ifx\p@ram\relax\else\advance\availht-\p@ram\fi
  \fi}
```

For separate notes, measuring their height is just a matter of adding the height
and depth of the class vbox and adding an AboveNoteSpace.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="665"}
\def\reduceavailht@sep#1{
  \def\cl@sss{#1}%
  \ifdiglot\ifdiglotSepNotes\ifdiglotL\def\cl@sss{#1}\else\def\cl@sss{#1R}\fi\fi\fi
  \TRACE{class \cl@sss}%
  \x@\let\x@\th@cl@ss\csname note-\cl@sss\endcsname
  \ifvoid\th@cl@ss\else
    \f@rstnotefalse
    \advance\availht by -\ht\th@cl@ss
    \advance\availht by -\dp\th@cl@ss
    \advance\availht by -\AboveNoteSpace
%FIXME?: Shouldn't the above be using InterNoteSpace? 
  \fi}
```

### Clearing Notes

At its core, clearing a note class is simply setting its box to empty. There is
the added layer of perhaps needing to clear two classes for diglots.

\fileheader{paratext2.tex}
```{.latex .numberLines startFrom="698"}
\def\cle@rn@tecl@ss#1{%
  \ifdiglot
    \ifdiglotSepNotes
       \cle@rn@t@cl@ss{#1}%
       \cle@rn@t@cl@ss{#1R}%
    \else\cle@rn@t@cl@ss{#1}\fi
  \else\cle@rn@t@cl@ss{#1}\fi
}

\def\cle@rn@t@cl@ss#1{%
  \x@\let\x@\th@cl@ss\csname note-#1\endcsname
  \global\setbox\th@cl@ss=\box\voidb@x}
```

<!-- # References -->

# Pictures

Pictures in the PTX macros are based around the `\fig` marker. The macros are in
transition from being USFM2 based, with an ordered set of parameters separated
by `|` to USFM3 which is key = "value" based. The macros support both at the
moment.

The parsing of the `\fig` options is done based around the `|`. The main fig
routine repeatedly calls `\getonep@ram` which splits the input on the first `|`
and retains everything after the `|` for future processing by the same function,
until there are no more `|` in the data. Each time it calls `\getonepairp@ram`
to do the real work and also to split off the key="val" pairs. Notice that if
this is a USFM2 style `\fig` there will be no key="val", instead we will only
have `val`. So to get the pattern matching macro to trigger, we append an extra
`=""` which will in effect pass val="". This gets noticed in the macro.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="146"}
\def\getonep@ram#1|#2\end{\gdef\p@rams{#2}%
  \trace{g}{getoneparam: #1 | #2}%
  \getonepairp@ram#1 ="" \relax%
  \global\advance\p@ramnumber by 1 }
```

The `\stripspace` macro is a nifty piece of TeX footwork to strip off any
initial or final space from its parameter. The string is passed in both as `#1`
and as `#3`. Consider, for example, the string ` a ` with a space on either end.
The call to `\stripspace a \end/ \end/\relax{ a }` will match with `#1` having a
value of 'a' having its initial space removed and any single following space
matched away, `#2` will be ` \end/` and `#3` is the full string. Inside
the macro `#2` is not empty and so we recall `\stripspace a\end/ \end/relax{a}`.
Now this time around `#1` is 'a\end/' since the first space for the pattern
match is after the `\end/` and `#2` will be empty, with `#3` containing the `a`.
This time inside the macro, the test is true and we store `#3` or `a` as the
result and we are done.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="51"}
\def\stripspace#1 \end/#2\relax#3{\if\relax#2\relax\gdef\p@ram{#3}\else\stripspace#1\end/ \end/\relax{#1}\fi}
```

Processing a single parameter involves comparing against a list of strings. The
easiest way to handle this in TeX is to define macros for them all. On entry
into `\getonepairp@ram` we strip any spaces from around the key and value. Next
we test the key against each of the known keys in turn and come up with a
positional number for the key. If this is USFM2 the positional number is the
previous one plus 1. Then we test the value. If it is empty we ask ourselves
whether we know we are in a USFM3 fig (because there was a previous key=value
pair). If not then store the parameter id as the value for the positional
parameter and there is nothing more to do in this `|` slot.
We then set a flag to fail the next test.

If we have not yet stored anything, use the parameter number as the index and
the parameter value as the value. We also prepare to go around again by skipping
the final whitespace and trying again. Since we have now hit a standard USFM3
type attribute, we set a flag to say to process everything else as USFM3. After
all is said and done, we either go around again or return.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="54"}
\def\FigP@ramAlt{alt} \def\FigP@ramSrc{src} \def\FigP@ramSize{size} \def\FigP@ramLoc{loc}
\def\FigP@ramCopy{copy} \def\FigP@ramRef{ref} \def\FigP@ramXtra{x-xetex} \def\FigP@ramPgpos{pgpos}
\def\FigP@ramMirror{mirror} \def\FigP@ramScale{scale} 

\newif\ifusfmthree \usfmthreefalse
\def\getonepairp@ram#1="#2" {\stripspace#1\end/ \end/\relax{#1}\edef\p@ramid{\p@ram}%
  \stripspace#2\end/ \end/\relax{#2}\edef\p@ramval{\p@ram}%
  \trace{g}{getonepairparam: [\p@ramid] = [\p@ramval]}%
  \ifx\p@ramid\empty\let\next=\relax\else
    \ifx\p@ramid\FigP@ramSrc\global\p@ramnumber=2\else
    \ifx\p@ramid\FigP@ramSize\global\p@ramnumber=3 \trace{g}{Got Size}\else
    \ifx\p@ramid\FigP@ramLoc\global\p@ramnumber=\x@\ifx\csname param-4\endcsname\empty 4\else 5\fi\else
    \ifx\p@ramid\FigP@ramPgpos\global\p@ramnumber=4\else
    \ifx\p@ramid\FigP@ramCopy\global\p@ramnumber=5\else
    \ifx\p@ramid\FigP@ramAlt\global\p@ramnumber=6\else
    \ifx\p@ramid\FigP@ramRef\global\p@ramnumber=7\else
    \ifx\p@ramid\FigP@ramXtra\global\p@ramnumber=8\else %experimental extra parameter, post filename e.g. "rotated 90"
    \ifx\p@ramid\FigP@ramMirror\global\p@ramnumber=9\else %experimental mirror parameter.
    \ifx\p@ramid\FigP@ramScale\global\p@ramnumber=10\else
    \trace{g}{Unrecognised usfm3 parameter \p@ramid}%
    \fi\fi\fi\fi\fi\fi\fi\fi\fi\fi
    \tempfalse
    \ifx\p@ramval\empty\ifusfmthree\else
      \trace{g}{param-\the\p@ramnumber = "\p@ramid" but not "\p@ramval"}%
      \x@\global\x@\edef\csname param-\the\p@ramnumber\endcsname{\p@ramid}%
      \let\next=\relax
      \temptrue
    \fi\fi
    \iftemp\else
      \trace{g}{param-\the\p@ramnumber [\p@ramid]  = "#2" from "\p@ramval"}%
      \x@\gdef\csname param-\the\p@ramnumber\endcsname{#2}%
      \let\next=\getonepairp@ram \usfmthreetrue
    \fi
  \fi\next}
```

The `\fig` marker is redirected to `\d@figure` which we will describe here. But
it is over 300 lines long, so we will take our time over it. The basic idea of
this macro is to parse the options; create a box for the figure and then either
put it in the right insert or in the right place on the page. The whole thing is
dependent on figures being included, otherwise we ignore the marker. We start by
assuming we are in USFM2 and that the image is not to be rotated. We also
collect the current column size for later. Then we get hold of the data in the
`\fig` and append a final `|` whether it is needed or not. This ensures that the
pattern matching routines on `|` will finish.

The next step is to clear all the parameters. Since there is a fixed number of
these positional parameters, we can simply test the count against a constant.
Each time we undefine the positional parameter. Next we process the parameters
by passing them to `\getonep@ram` which strips off one string up to a `|` and
processes it as either a positional parameter or a list of key=value pairs. If
the rest is empty, then we are done, otherwise go around again.

Next we pull out some of the fixed position parameters and store them for later
use.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="245"}
\def\d@figure#1{%
 \ifIncludeFigures
  \trace{g}{In d@figure #1}\usfmthreefalse
  \rotimagefalse
  \edef\curc@lsz{\the\hsize}% Current col size
  \gdef\p@rams{#1|}% ensure there is a trailing | separator
  % place parts of text into \param-1, \param-2, ...
  \global\p@ramnumber=1
  \loop
    \x@\gdef\csname param-\the\p@ramnumber\endcsname{}%
    \global\advance\p@ramnumber by 1
    \ifnum\p@ramnumber<11\repeat
  \global\p@ramnumber=1
  \loop
    \x@\getonep@ram\p@rams\end
    \ifx\p@rams\empty \morep@ramsfalse \else \morep@ramstrue \fi
    \ifmorep@rams\repeat
  % get size
  \lowercase{\edef\size@ption{\csname param-3\endcsname}}%
  \lowercase{\edef\sizem@ltiple{\csname param-10\endcsname}}%
  \expandafter\p@rsesize\size@ption**\end % extract possible multiplier
  % get location
  \lowercase{\edef\loc@ption{\csname param-4\endcsname}}%
```

The `size` option needs specific parsing. `#1` is the size option. `#2` is a
scale factor and `#3` may be empty or `*` depending whether the is a scale
factor. Then we store the sizeoption and the sizemultiple for later use.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="91"}
\def\p@rsesize#1*#2*#3\end{%
  \def\size@ption{#1}%
  \edef\tmp{#2}
  \if\tmp\relax\else\def\sizem@ltiple{#2}\trace{g}{Setting scale to #2}\fi% empty if not provided
}
```

In the next section of `\d@figure` we process more parameters. If the page
location (`pgpos`) then we come up with a default based on the size option.
Basically we default pictures to the top or top left. We setup default picture
width and height and set some default flags ❶. We then define more defaults:
pictures align centred in their box and on the page (for page type pictures).

The `\p@cinswid` is the width of the box into which the picture will be placed.
We set the width and height of the picture based on its size option. For full
page type size options we clear the flag to use inserts for the picture and set
an appropriate location and picture width and height. Finally, for this section
we clear the insert identifier ready to set it.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="271"}
  \ifx\loc@ption\empty % if location empty
    \ifx\size@ption\size@SPAN%
	   \def\loc@ption{t}% if size is SPAN default to top
	\else\def\loc@ption{tl}\fi % else default to top left FIXME? Standard says inline. Could swap to h if that proves stable.
  \fi
  % set width to column width or span width and other default parameters
  \p@cwidth=\textwidth \advance\p@cwidth by -\columnshift 
  \p@cheight=\textheight
  \advance\p@cheight by -4\baselineskip % there should be text on the page too - allow for caption+space+2 lines of text!
  \picUsesInstrue \picNarrowfalse                                               ①
  \gdef\pic@lign{c}% How does the picture align within the box?
  \gdef\picV@lign{c}% How does the picture align vertically on the page (Page/Full only)
  \gdef\picl@c{}% location code for in-line (non-insert) pictures 
  % By default, set the insert width to full span
  \p@cinswid=\textwidth\advance\p@cinswid by -\columnshift
  \ifx\size@ption\size@COL \p@cwidth=\hsize
  \else\ifx\size@ption\size@SPAN
    \else\ifx\size@ption\size@PAGE 
        \global\let\picl@c=\loc@Page
        \picUsesInsfalse
        \p@cheight=\textheight % no text
        \advance\p@cheight by -2\baselineskip
      \else\ifx\size@ption\size@FULL
          \global\let\picl@c=\loc@Full
          \picUsesInsfalse
          \p@cwidth=\PaperWidth\p@cheight=\PaperHeight
        \else 
           \errmessage{Unknown picture size "\size@ption", expected "col", "span", "page" or "full"}\fi\fi\fi\fi
  \let\p@cins=\relax
```

In anticipation of the next code in `\d@figure` we describe the process of
parsing the location option. The location option (as described for the `pgpos`
attribute) consists of one or more characters. The primary location is described
by the first letter and the sub location within that, with the rest. There may
not be a second, in which case it will be empty, since the pattern match is
bounded by `\end`. If there is a second parameter then we subparse that. The
second parameter may itself be 1 or more characters with the secondary position
as the first character and the tertiary position as the rest.

Initially, we check to see if the second (alignment) parameter is page-number
dependent (`i` or `o` for inner or outer). We then convert that to the relevant 
absolute alignment (`l` or `r`). If the location is `t` or `b`,  an
image that will be in an insert, then we regenerate the relevant code.

If the location is `h`, meaning an inline graphic, then capture the main
location and the second parameter is the absolute alignment (`l`, `r` or `c`
for left, right or central).
Since we are
inline, clear the flag to store the picture box in an insert. If the alignment
is not central, then narrow the picture (and caption).

If the location is `c` for a cutout, then again we capture the main location and
clear the inserts flag. Pictures need to be narrowed and the space available is
the column width. We also collect any cut skip which says how many lines down
the cutout starts.

If the location is `p` for pictures that are placed in line after the current
paragraph.  The width is the column width and the alignment 
the second character: `l`, `r`, `c`, `i` or `o` as before. There is no
insertion. If the alignment is not central, then set the narrow picture flag.

If the location is `P` for page then set the picture width to the page width.
Likewise if the location is `F` for full (page to edge), then don't set a width.
In either case warn the user we are entering experimental waters and set the
alignment to be the second character (the familiar `l`, `r`, `c`, `i`, or `o`) 
and the vertical alignment the third.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="159"}
\def\p@rsePicXtra#1#2\end{% Parse optional new picture options, and remember them
  \xdef\t@mpb{#1}\xdef\t@mpc{#2}%
}
\def\p@rsePicUse#1#2\end{% Parse the new picture options, and remember them
  \edef\t@mp{#1}\edef\t@mpb{#2}%
  \ifx\t@mpb\empty\let\t@mpc=\t@mpb\else\x@\p@rsePicXtra\t@mpb\end\fi
  \trace{g}{p@rsePicUse: #1 \t@mpb \t@mpc}%
  % inner/outer support for everything
  \tempfalse
  %Switch relative (inner/outer) to absolute (left/right) depending on page number for this image.
  \ifx\t@mpb\@lignOuter\temptrue\ifodd\whichp@ge\let\t@mpb=\@lignRight\else\let\t@mpb=\@lignLeft\fi\fi
  \ifx\t@mpb\@lignInner\temptrue\ifodd\whichp@ge\let\t@mpb=\@lignLeft\else\let\t@mpb=\@lignRight\fi\fi
  \iftemp
    % inner/outer support for inserts
    \trace{g}{Page \the\whichp@ge, defined #2 to \t@mpb}%
    \tempfalse
    \ifx\t@mp\loc@T\temptrue\fi
    \ifx\t@mp\loc@B\temptrue\fi
    \iftemp
      %redefine loc@option
      \xdef\loc@ption{\t@mp\t@mpb}%
  \fi\fi
  % new options 
  \ifx\t@mp\loc@Inl
    \trace{g}{Experimental inline graphic}%
    \global\let\picl@c\loc@Inl\xdef\pic@lign{\t@mpb}\global\picUsesInsfalse\p@cinswid=\hsize
    \ifx\t@mpb\@lignLeft\picNarrowtrue\fi
    \ifx\t@mpb\@lignRight\picNarrowtrue\fi
  \fi
  \ifx\t@mp\loc@Cut
    \global\let\picl@c\loc@Cut\global\picUsesInsfalse\global\picNarrowtrue\p@cinswid=\hsize
    \xdef\l@cspec{\t@mpb}%
    \ifx\t@mpc\empty\gdef\c@tskip{0}\else\xdef\c@tskip{\t@mpc}\fi%
    \trace{g}{Experimental graphic in cutout, after \c@tskip lines}%
  \fi
  \ifx\t@mp\loc@Par
    \global\let\picl@c=\loc@Par\p@cinswid=\hsize\trace{g}{Experimental after-paragraph graphic}%
    \xdef\pic@lign{\t@mpb}\global\picUsesInsfalse
    \ifx\t@mpb\@lignLeft\picNarrowtrue\fi
    \ifx\t@mpb\@lignRight\picNarrowtrue\fi
    \ifx\t@mpc\empty\gdef\c@tskip{0}\else\xdef\c@tskip{\t@mpc}\fi%Borrow cutskip for parskip 
  \fi
  % full-page options
  \tempfalse
  \ifx\t@mp\loc@Page\global\let\picl@c=\loc@Pag\global\picUsesInsfalse\p@cinswid=\PaperWidth\temptrue\fi
  \ifx\t@mp\loc@Full\global\let\picl@c=\loc@Full\global\picUsesInsfalse\temptrue\fi
  \iftemp
    \trace{g}{Experimental page / full-page graphic}%
    \xdef\pic@lign{\t@mpb}\xdef\picV@lign{\t@mpc}%
  \fi
}
```

Returning to `\d@figure` we are still processing parameters and setting
defaults. 
But first ❶ we collect which page this picture occurred in a previous run. We
need this to decide how to interpret the mirroring attribute, rotation options
and page-number dependent positions or alignments.

❷ We parse the location. For `t` and `b` type locations, set appropriate
defaults depending on the number of columns and also set the insert to use. We
also collect the current height of that insert to subtract from the insert
height later.

If we are using inserts for this picture, then if we still haven't decided on an
insert to use then work out some defaults. If we are not in a diglot then we
don't need to worry about the current height of the insert. If there is
insufficient horizontal space for our intended picture width then complain to
the user. Count the number of pictures in our document. This allows the next 
line to retrieve the information we need. 


\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="303"}
  \global\advance\im@gecount by 1
  \x@\let\x@\pgn@\csname fig\the\im@gecount p@ge\endcsname                    ①
  \ifx\pgn@\relax
    \whichp@ge=\pageno
    \trace{g}{Picture \the\im@gecount may not be mirrored/rotated/aligned properly}%
  \else
    \whichp@ge=\pgn@
    \trace{g}{Picture \the\im@gecount was on page \pgn@ last time. [\the\pageno]}%
  \fi
  \x@\p@rsePicUse\loc@ption\end                                               ②
  % make \p@cins point to insertion class for this location
  \otherinsht=0pt % subtract this from the insert height.
  \ifx\loc@ption\loc@T \let\p@cins=\topins
  \else\ifx\loc@ption\loc@B \let\p@cins=\bottomins
  \else
      \ifnum\c@rrentcols>1
        \ifx\loc@ption\loc@TL \let\p@cins=\topleftins \otherinsht=\ht\toprightins \p@cinswid=\hsize
        \else\ifx\loc@ption\loc@TR \let\p@cins=\toprightins \otherinsht=\ht\topleftins \p@cinswid=\hsize
        \else\ifx\loc@ption\loc@BL \let\p@cins=\bottomleftins \otherinsht=\ht\bottomrightins \p@cinswid=\hsize
        \else\ifx\loc@ption\loc@BR \let\p@cins=\bottomrightins \otherinsht=\ht\bottomleftins \p@cinswid=\hsize
        \fi\fi\fi\fi
      \else
        \ifdiglot\MSG{HOW DID THAT HAPPEN? currentcols=\the\c@rrentcols}\fi
        \ifx\loc@ption\loc@TL \picw@rning{tl}{t}\let\p@cins=\topins
        \else\ifx\loc@ption\loc@TR \picw@rning{tr}{t}\let\p@cins=\topins
        \else\ifx\loc@ption\loc@BL \picw@rning{bl}{b}\let\p@cins=\bottomins
        \else\ifx\loc@ption\loc@BR \picw@rning{br}{b}\let\p@cins=\bottomins
        \fi\fi\fi\fi
      \fi
  \fi\fi
  \ifpicUsesIns
    \ifx\p@cins\relax
      %\errmessage{Unknown picture location "\loc@ption",
      %  expected one of t,b,tl,tr,bl,br}%
      \ifnum\c@rrentcols>1
        \p@cinswid=\hsize
        \iffiglocleft\let\p@cins=\topleftins\figlocleftfalse \otherinsht=\ht\toprightins
        \else\let\p@cins=\toprightins\figloclefttrue \otherinsht=\ht\topleftins\fi
      \else \let\p@cins=\topins\fi
    \fi
  \fi
  \ifdiglot\else\otherinsht=0pt \fi %Nothing to subtract if not diglot
  \ifdim\p@cinswid<\p@cwidth
    \message{*** Picture \the\p@cwidth\space wide in  \the\p@cinswid\space space. \ifx\size@ption\size@SPAN Did you mean to use col, instead of span?\fi}%
  \fi
```

In this section we create the vbox for the picture. If the picture is
narrowable, we set the width of this box to be the scaled width of the picture,
otherwise we set the box width to the specified available width for it. The user
may have called for the caption to come above the picture, if so, insert it
here.

Now we start building up the command to insert the picture. We start by choosing
the command to use, the filename and any mirror attribute value.

We also parse any `x-xetex` attribute value. We will return to this later. Next
we test to see if the filename is a .pdf file. If it is, then change the
command used to open the file.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="575"}
\def\ch@ckpdf#1.#2.#3\endf@lename{\lowercase{\edef\@xt{#2}}%
  \ifx\@xt\@pdf \let\picfilecomm@nd\XeTeXpdffile \fi}
```

If the image is to be rotated, then fit the image based
on its (pre-rotation) height rather than width.

We insert the picture, scaling it according to its width. But if it turns out
that results in something too high, then we try again but scale it according to
the available height.

Now we create the figure box which is what appears in the document and consists
of either the picture or a placeholder. At this point we write details of this
picture to the `.picpages` file. If the user has asked for placeholders instead
of pictures, then replace the box with  a box containing the filename.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="351"}
  \trace{g}{Figure \the\im@gecount\space size=\size@ption, scale=\sizem@ltiple, loc=\loc@ption \ifpicUsesIns, picins=\the\p@cins\fi, hsz=\the\hsize}%
  \setbox0=\vbox{
    \ifpicNarrow
      \hsize=\sizem@ltiple\p@cwidth
      \p@cinswid=\hsize
    \else
      \hsize=\p@cinswid
    \fi
    \ifx\picl@c\loc@Inl
       %\vskip0.5\baselineskip
    \fi
    \ifCaptionFirst\d@caption\fi
	% insert picture based on PicPath and file name, scaled to \p@cwidth
    \let\picfilecomm@nd=\XeTeXpicfile
    \edef\f@lename{\csname param-2\endcsname}%
    \edef\mirr@r{\csname param-9\endcsname}%
    \def\xtra{}\def\xtraremains{}%
    \x@\p@rsextra{\csname param-8\endcsname}%See if there are any key=val parameters in the x-xetex parameter
    \expandafter\ch@ckpdf\f@lename..\endf@lename
    %what are we scaling on the image? Width or height?
    \ifrotimage
      %If there's rotation, fit the image height to width instead of the normal way:
      \def\picdim@n{height}\def\picaltdim@n{width}%
    \else
      \def\picdim@n{width}\def\picaltdim@n{height}%Normal
    \fi
    % First, try to set it at the requested dimension:
    \setbox1=\hbox{
      \picfilecomm@nd "\the\PicPath\csname param-2\endcsname"
                     \picdim@n \sizem@ltiple\p@cwidth \xtra \xtraremains}%
    \ifdim\ht1>\p@cheight
      %It doesn't fit. Scale to other dimension:
      \trace{g}{Picture too big set with \picdim@n=\sizem@ltiple\the\p@cwidth}%
      \setbox1=\hbox{
        \picfilecomm@nd "\the\PicPath\csname param-2\endcsname"
                     \picaltdim@n \p@cheight \xtra \xtraremains}%
    \fi
    \setbox0=\hbox to \sizem@ltiple\p@cwidth{\hss
      \edef\l@gstring{{\the\im@gecount}{\f@lename}{\csname param-4\endcsname}{\csname param-5\endcsname}{\sizem@ltiple x\the\p@cwidth}}% Fully expand figure parameters, but leave page no. to be expanded later.
      \x@\writefigp@gelog\x@{\l@gstring}%
      \box1\hss}%
    \ifFigurePlaceholders % replace graphic with a frame and the file name
      \setbox0=\vbox to \ht0{\offinterlineskip
        \hrule height .2pt \kern-.2pt
        \hbox to \wd0{\vrule height \ht0 width .2pt \hfil \vrule width .2pt}%
        \vbox to 0pt{\kern-\ht0 \vss \hbox to \wd0{\hss\idf@nt
          \csname param-2\endcsname\hss}\vss}%
        \kern-.2pt \hrule height .2pt}%
    \fi
```

We pause our description of the figure box to revisit the parsing of `x-xetex`.
Parsing starts with the
last routine here ❶. First we clear out the remainder and test to see if we
can short circuit with nothing to process. Otherwise we process the attribute
'word' by 'word' ❷. We test to see if the word or what follows is empty (i.e.
there must be at least 2 'word's. If so then we are done otherwise we parse the
first word as `key=value=angle`. Alternatively the angle may be missing as in
`key=value` or simple `value`.

We grab the value. If there is no key, simply pass the value to XeTeX as part of
the remainder. Otherwise we need to analyse the key and value. The only
recognised key so-far is `rotate`. `\whichp@ge` is the target page and we use that to
decide which way to rotate an image for the key values of `binding` (top of the image 
close to the binding) and `edge` (top of the image close to the edge of the paper). 
`binding` and `edge` are great if 90° rotation is desired, additional control (e.g. 
for an image of a spear that would make better use of space if shown at an angle) is 
available using values of `odd` or `even` then also collect the angle which
will be used if the page constraint is met.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="99"}
\def\getnum#1=#2\end{#1}%
 
% These three macros split up x-xetex="foo" parameter, stripping out any key=val formatted parameters and leaving the rest.
% 
\def\p@rs@xtr@#1=#2=#3\end{\edef\t{#2}%
  \ifx\t\empty \edef\t{#1}
    \ifx\t\empty\else
      \edef\xtraremains{\xtraremains#1\space}\trace{g}{Passing #1 directly to xetex}%
    \fi
  \else 
    \trace{g}{Found k=#1,v=#2 (x=#3)}%
    \def\key{#1}\def\val{#2}%
    \ifx\key\keyR@TATE \rotimagetrue
      \ifx\val\val@BIND \ifodd\whichp@ge\def\xtra{rotated 90}\else\def\xtra{rotated -90}\fi
      \else 
        \ifx\val\val@EDGE \ifodd\whichp@ge\def\xtra{rotated -90}\else\def\xtra{rotated 90}\fi
        \else \tempfalse \t@mpfalse
          \ifx\val\val@dd \t@mptrue \ifodd\whichp@ge\temptrue\fi\fi
          \ifx\val\val@ven \t@mptrue \ifodd\whichp@ge\else\temptrue\fi\fi
          \iftemp \edef\angle{\getnum#3==\end}%
            \ifx\empty\angle \message{Expected rotate=\val=42 or similar in definition of picture \f@lename}%
            \else \xdef\xtra{rotated \angle}\fi
          \fi
          \ift@mp\else
            \message{Unexpected value rotate=#2. Expected values "edge", "binding", "odd", or "even"}%
          \fi
        \fi
      \fi
    \else \message{Unexpected key #1=#2. Expected key "rotate"}\fi
  \fi
}
\def\p@rsextr@#1 #2\relax{%                                                     ②
  \trace{g}{processing #1}%
  \edef\t{#2}\ifx\t\empty\let\n@xt=\relax\fi
  \edef\t{#1}\ifx\t\empty\let\n@xt=\relax
  \else \x@\p@rs@xtr@\t==\end \fi
  \x@\n@xt#2 \relax
}
\def\p@rsextra#1{%                                                              ①
  \trace{g}{Parsing #1}%
  \def\xtraremains{}\let\n@xt=\p@rsextr@
  \edef\t{#1}\ifx\t\empty\let\n@xt=\relax\fi
  \x@\n@xt#1 \relax
}
```

Returning to creating the figure vbox we set up a few variables for later use.
If the image is to be mirrored then define a prepic macro. In this we decide
whether the image actually needs to be mirrored because, for example, the
mirror calls for mirroring on odd pages and the image is going on an odd page.
If the image really needs mirroring then insert the necessary pdf special to
mirror the following image. We also define the postpic command which, if the
image is being mirrored, needs to finish off the pdf special and stop the
transform. We then turn the picture box into a possible transformed (mirrored)
picture box.

If the picture is being narrowed then decide where to place it within the
column. For example if the image is right aligned then insert any stretch or
shrink (for overly wide pictures) on the left, before the image. And so on.

Finally, if the caption came first, then insert a little space, otherwise insert
the caption.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="403"}
    \tempfalse
    \def\pr@pic{}\def\p@stpic{}%
    \ifx\mirr@r\empty\else
      \trace{g}{Mirror: \mirr@r, \the\pageno}%
      \global\def\pr@pic{
         \trace{g}{prepic: Mirror: \mirr@r, \the\pageno}%
         \ifx\mirr@r\val@dd\ifodd\whichp@ge\temptrue\fi\fi %Page number is frequently low by one or 2 when image is read. Needs external toc-style file.
         \ifx\mirr@r\val@ven\ifodd\whichp@ge\else\temptrue\fi\fi
         \ifx\mirr@r\valb@th\temptrue\fi
         \iftemp\trace{g}{Mirrored image requested}%
           \dimen0=\wd0\kern\dimen0\special{pdf:  begintransform}\special{x:scale -1 1}\fi
      }%
      \global\def\p@stpic{\iftemp\special{pdf: endtransform}\kern-\dimen0\fi
      }%
      \setbox0\hbox{\pr@pic\box0\p@stpic}%
    \fi
    \trace{g}{Picture height=\the\ht0, vs:\the\vsize, \the\partialLpenalty,  pg:\the\pagegoal, pt:\the\pagetotal, av:\the\availht, aligned:\pic@lign}%
    %Align image left/right or centre
    \ifx\pic@lign\@lignRight\hbox to \p@cinswid{\hss\box0}%
    \else
      \ifx\pic@lign\@lignLeft \hbox to \p@cinswid{\box0\hss}%
      \else\hbox to \p@cinswid{\hss\box0\hss}\fi
    \fi
    \ifCaptionFirst\vskip 0.5\baselineskip\else\d@caption\fi
  }% END of box0
```

We are ready to describe caption processing. We collect the reference attribute
from the figure and strip its space. We also collect the caption text. The
location is different for USFM3 from USFM2. If there is no caption then we don't
use the reference either and we simply insert a small post caption gap.

We set up for creating a paragraph based on the `fig` style. While `fig` is officially 
a character style, we select the appropriate justification for
it as if it were a paragraph. We also do not allow page breaks in this text (because it is
being processed into a separate box). We then set the baseline for this
paragraph. Then we prepare the reference, if there is one. The user can change
the `\DecorateRef` macro to change how references will be add to the caption (to
the point of deleting it). Finally we start the paragraph and perhaps insert the
reference with a non-breaking space followed by the caption itself and then if
the reference comes at the end a non-breaking space and the reference. The
paragraph is completed and we add a half space at the end.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="213"}
\def\DecorateRef#1{(#1)}

\def\d@caption{
  \xdef\r@f{\csname param-7\endcsname}% get reference
  \stripspace\r@f\end/ \end/\relax\r@f \edef\r@f{\p@ram}% strip space
  \edef\c@ption{\ifusfmthree\csname param-1\endcsname\else\csname param-6\endcsname\fi}% get caption
  \trace{g}{Fig caption: [\c@ption] \ifx\r@f\relax\else(\r@f)\fi}%
  \ifx\c@ption\empty\else
    \everypar={}\let\par\endgraf
    \leftskip=0pt plus \hsize \rightskip=\leftskip \parfillskip=0pt
    \getp@ram{justification}{fig}%
    \ifx\p@ram\r@ght\rightskip=0pt\fi
    \ifx\p@ram\l@ft\leftskip=0pt\fi
    \getp@ram{leftmargin}{fig}%
    \ifx\p@ram\relax \else \advance \ifRTL\rightskip\else\leftskip\fi\p@ram \IndentUnit \fi
    \getp@ram{rightmargin}{fig}%
    \ifx\p@ram\relax \else \advance \ifRTL\leftskip\else\rightskip\fi\p@ram \IndentUnit \fi
    \linepenalty=1000
    \s@tbaseline{fig}%
    % insert caption box
    \edef\@r@f{\ifx\r@f\empty\else\DecorateRef{\r@f\unskip}\fi}
    \noindent\leavevmode
      \ifCaptionRefFirst\@r@f\nobreak\ \fi
      \s@tfont{fig}\c@ption\unskip
      \ifCaptionRefFirst\else\nobreak\ \@r@f\fi
    \par
  \fi
  \vskip.5\baselineskip
}
```

Now that we have a box containing the whole figure, we need to put it somewhere.
In the case that the box is to be `insert`ed, we test to see if we are in a
diglot. If so then we compare our height with that of the corresponding insert
heights on the other side. If we are less than theirs, then we come for free and
so set the height to 0pt. Else set our height to the difference between our
height and theirs. Then we insert the picture as an `insert`. We do not want the
picture to go on a different page, so disallow any breaks here. Setting the
`\splittopskip` to 0pt says that if there is a column break just before this
picture, then pull the picture right to the top. And also allow any depth for
the box when splitting. But do not let this picture float.

Then we call the gridbox routine to insert space before the picture to ensure
that the next line of text after the picture will be on the text grid.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="430"}
  \trace{b}{BALANCE fig: height=\the\ht0: baselineskip=\the\baselineskip}%
  % insert into proper insertion class for this position
  \ifpicUsesIns
    \trace{g}{Picture (\the\ht0,\the\dp0) goes to insert}%
    \ifdiglot
      \trace{g}{Other side: \the\otherinsht.}%
      \ifdim\ht0<\otherinsht
        \ht0=0pt
      \else
        \advance\otherinsht by -\ht0 %can't do maths on \ht0, need to calculate backwards
        \ht0=-\otherinsht
      \fi
    \fi
    \trace{g}{Picture now \the\ht0}%
    \insert\p@cins{\penalty10000 % make sure this picture does not float away to another page
      \splittopskip\z@skip
      \splitmaxdepth\maxdimen \floatingpenalty20000 % was zero
      \gridp@ctrue\gridb@x0\gridp@cfalse% make sure we align to the page grid
    }%
```

The rest of the routine is concerned with inline figures that do not go into an
`insert`. First we work out how many lines big this figure is. Then if the
picture is inline then allow a page break before it and if the picture is
assumed to be narrower than the column width, rebox it to be a column's width,
inserting appropriate shrink or stretch. The rest of the routine is handling
each of the figure location types.

Inline figures are inserted into the
vadjust using a XeTeX extension (`\vadjust pre`) that says the insertion should
happen before the current line rather than after it.

Post paragraph figures are stored into a diglot side appropriately named box. If
the picture can be narrowed, then rebox to column width with appropriate shrink
or stretch. We now create a macro to run at the end of the paragraph (again
diglot side appropriate). This will execute after the paragraph is output. This
macro gets hold of the diglot side appropriate picture box we just allocated and
grids it at that point as if it were a headings block and outputs it into the
main text flow. It also allows a page break after the image.

Next we count the number of paragraphs we want to skip before inserting this
image and make a string of `D`s (delay) of that many and store that for the
post paragraph figure handler to make use of.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="451"}
  \else
    % Calculate lines used for the picture
    \dimen0=\ht0 \advance\dimen0 by \dp0 \advance\dimen0 by 0.5\baselineskip % Rounding correction
    \divide\dimen0 by \baselineskip \count255=\dimen0
    \trace{g}{Inline picture takes \the\count255 lines}%
    %
    \ifx\picl@c\loc@Inl
      \trace{g}{Picture is inline \ifhmode in HMODE\fi}%
      \penalty10 % Allow the page to break
      \ifpicNarrow
        \ifx\pic@lign\@lignLeft
          \setbox0\hbox to \colwidth{\box0\hss}\else\setbox0\hbox to \colwidth{\hss\box0}%
        \fi
      \fi
      %\splittopskip\baselineskip
      \vadjust pre {
        \gridp@cfalse% Not true! It's not floating. 
        \gridb@x0 \dimen9=\lastdepth \kern\dimen9
        \trace{g}{gridbox dp=\the\dimen9}%There's a skip at the bottom of the box, but somehow the depth is kept. Need to kill it.
      \penalty10}%
    \fi
    %
    \ifx\picl@c\loc@Par
      \trace{g}{Picture is post-paragraph}%
      \let\picb@@x=\picb@x
      \ifdiglot\ifdiglotL\else\let\picb@@x=\picb@xR\fi\fi
      \global\setbox\picb@@x\box0
      \ifpicNarrow
        \ifx\pic@lign\@lignLeft \global\setbox\picb@@x\hbox to \colwidth{\box\picb@@x\hss}\trace{g}{Pic aligned left}%
        \else \global\setbox\picb@@x\hbox to \colwidth{\hss\box\picb@@x}\trace{g}{Pic aligned right}%
        \fi
      \fi
      \edef\eotpn@me{at@ndofthispar\ifdiglot\ifdiglotL L\else R\fi\fi}% Which endofthispar macro?\emspace
      \trace{g}{\eotpn@me\space defined}%
      \x@\gdef\csname \eotpn@me\endcsname{
        \relax \let\picb@@x=\picb@x \ifdiglot\ifdiglotL\else\let\picb@@x=\picb@xR\fi\fi
        \penalty10 % Allow the page to break
        %\gridp@cfalse% Not true. Not a floating image.
           \gridb@x\picb@@x
           %\vskip-\prevdepth
        \penalty10
       }%
       \def\temp{}%
       \ifnum\c@tskip>1 \count255=\c@tskip
         \loop\ifnum\count255>1
           \edef\temp{D|\temp}\advance\count255 by -1
         \repeat
       \fi
       \trace{g}{Delay for \eotpn@me set to \temp}%
       \x@\xdef\csname \eotpn@me Delay\endcsname{\temp}%
       \relax\relax
    \fi
```

Page and full pictures are treated the same except that they are given a
different magic penalty number after each one. Again this is stored ready for
shipping out at the right time with the appropriate shipout routine.

Placing of full pictures all the way to the paper edges is complicated by the
page-shipping  routine's use of `\vss` (vertical stretch or shrink) above and
below the image, and the `\topm@rgin` and `\bottomm@rgin` that are added above
and below the image before this 'centering' occurs. 

Cutout pictures really do not like occurring mid paragraph. Ideally they occur at
the start of a paragraph before the first text. But if they do occur mid
paragraph then either start a new paragraph of the same type or else the marker
before a `\v` occurred.

We calculate the vertical size of the image rounded up to the grid plus however
many lines down we need to go; the width of
the image with a small 10pt margin and the amount of space left in the column
once the cutout is removed. If this is too small (<5em) then complain to the
user.

Inserting the cutout is basically the same for both sides. Only the position of
the shrink and stretch and which side the cutout is, differs. We create a new
box that pushes the image down to fit into the cutout. We make the box look 0
sized, insert it and then add the cutout to the cutout system.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="506"}
    \ifx\picl@c\loc@Page
      \trace{g}{Picture is page, \the\ht0, \the\wd0}%
      \ifx\picV@lign\@lignTop \setbox0\vtop to \textheight{\box0\vskip 0pt plus 1fill}\fi%CHECKME
      \ifx\picV@lign\@lignBot \setbox0\vbox to \textheight{\vskip 0pt plus 1fill \box0}\fi%CHECKME
      \global\setbox\wholepagepic\vbox{\unvbox\wholepagepic\box0\penalty11}% magic number
    \fi
    \ifx\picl@c\loc@Full
      \trace{g}{Picture is full-page, \the\ht0, \the\wd0,}%
      %Page is not positioned absolutely. Calculate offset
      \dimen0=\bottomm@rgin\advance\dimen0 by -\topm@rgin
      \divide\dimen0 by 2
      \advance\dimen0 by \FullPageFudgeFactor % apply user-tweakable Fudge factor (-2pt)
      \ifx\picV@lign\@lignTop \setbox0\vtop to \PaperHeight{\kern\dimen0\box0\vss}\fi%CHECKME
      \ifx\picV@lign\@lignBot \setbox0\vbox to \PaperHeight{\vss\box0}\fi%CHECKME
      \global\setbox\wholepagepic\vbox{\unvbox\wholepagepic\box0\penalty9}% magic number
    \fi
    \ifx\picl@c\loc@Cut
        \ifhmode
           \ifx\prev@rsemode\empty
             \trace{g}{Cutout in horizontal mode. forcing \m@rker}%
             \csname\m@rker\endcsname
           \else
             \trace{g}{Cutout now in horizontal mode, but before this verse was started
                       it was in vertical mode. Using \prev@rsemode and negative lineskip}%
             \csname\prev@rsemode\endcsname
             \vskip -\baselineskip
           \fi
        \fi 
      \trace{g}{Picture is cutout}%
      \dimen1=\baselineskip \advance\count255 by 1 \multiply\dimen1 by \count255
      \advance\dimen1 by \c@tskip\baselineskip
      \dimen2=\wd0 \advance\dimen2 by 10pt
      \dimen3=\curc@lsz \advance\dimen3 by -\dimen2
      \ifdim\dimen3<5em\message{*** Picture specification of \size@ption \sizem@ltiple (at \ch@pter:\v@rse)
                                leaves \the\dimen3 \space for text. That's probably not enough.}\fi
      %Switch relative (inner/outer) to absolute (left/right) depending on page number for this image.
      \ifx\l@cspec\@lignLeft
        \setbox0\hbox to 0pt {\lower\dimen1\box0\hss}%
        \ht0=0pt \dp0=0pt \vskip-\baselineskip  %Yuck
        \box0 %FIXME? Box here Adds vertical space
        \trace{g}{leftcutout \the\dimen2, \c@tskip, \the\count255}%
        \leftcutout{\the\dimen2}{\c@tskip}{\the\count255}%
      \else\ifx\l@cspec\@lignRight
          \setbox0\hbox to \hsize{\hss\lower\dimen1\box0}%
          \ht0=0pt \dp0=0pt \vskip-\baselineskip %Yuck
          \box0% FIXME? Box here adds vertical space
          \trace{g}{rightcutout \the\dimen2, \c@tskip, \the\count255}%\
          %\edef\t@mpd{\the\dimen2}%
          \rightcutout{\the\dimen2}{\c@tskip}{\the\count255}%\emspace
        \else
          \message{*** Unknown cutout position \l@cspec, picture misplaced}%
          \box0
        \fi
        \unskip
      \fi
    \fi
   \fi
 \fi% end \ifIncludeFigures
}
```

## Inserting Pictures

Part of processing a paragraph is the insertion of figures after a paragraph.
This gets called at the end of a paragraph break. We start by collecting the
diglot side appropriate end of paragraph tokens that may have been added in the
paragraph when a paragraph picture was inserted. These get stored in `\pn@xt`.
There are lots of reasons not to execute these tokens: if there are none; if
inside a note; if at the start of a page. If we have tokens to run and we want
to run them, then get the `Delay` tokens. If they are not empty, then we don't
want to run the tokens since this image is to be delayed by the number of
paragraphs. So trim off a `D` from the Delay tokens to correspond to this
paragraph and store that back in the same `Delay` token list. Then clear the
endofpar identifier. Otherwise if we do have tokens but we don't want to execute
them, then clear them and forget the endofpar identifier.

If, after all this, we still have tokens to execute then clear the origin of
those tokens and execute them. This outputs the image at this point.

\fileheader{ptx-para-style.tex}
```{.latex .numberLines startFrom="183"}
\def\do@ndofthispar{
 %run code to insert picb@x / picb@xR at the right time.
 \edef\eotpn@me{at@ndofthispar\ifdiglot\ifdiglotL L\else R\fi\fi}% Which endofthispar macro?
 \x@\let\x@\pn@xt\csname \eotpn@me\endcsname
 \trace{g}{doendofthispar \ch@pter:\v@rse\ifdiglot\ifdiglotL L \else R \fi\fi\space \the\pagetotal,
           \the\holdinginserts, page/chunk-\ifp@gestart start\else -middle\fi}%
 \temptrue %If iftemp stays true, then it's a valid insertion point.
 \ifx\pn@xt\empty\tempfalse\fi
 \ifinn@te\tempfalse\fi %No pictures in notes!
 \ifdiglot
   \ifp@gestart\tempfalse\fi
 \else 
   \ifdim\pagetotal=0pt \tempfalse\fi
 \fi
 \ifx\pn@xt\empty\else
   \iftemp
     %Potential inclusion location. Check delay.
     \edef\temp{\csname\eotpn@me Delay\endcsname}%
     \ifx\temp\empty\else
       \let\pn@xt=\empty
       \trace{g}{\ch@pter:\v@rse. Delayed by specification (\temp)}%
       \x@\shrinkdel@y \temp\EDLY\relax
       \trace{g}{Delay for \eotpn@me set to \temp}%
       \x@\xdef\csname \eotpn@me Delay\endcsname{\temp}%
       \edef\eotpn@me{empty}%
     \fi
   \else
     \edef\eotpn@me{empty}%
     \let\pn@xt=\empty
     \trace{g}{\ch@pter:\v@rse. Not here}%
   \fi
 \fi
 \ifx\pn@xt\empty\else
   % Time to actually include the picture
   \trace{g}{\eotpn@me\space used (\the\holdinginserts)\the\ht\picb@x / \the\ht\picb@xR}%
   %\nonstopmode
   %\show\pn@xt
   %\edef\pn@xt{\hbox{x}}% test code
   \x@\global\x@\let\csname\eotpn@me\endcsname=\empty 
   \pn@xt\relax 
 \fi
}

\def\shrinkdel@y#1|#2\EDLY{\trace{g}{shrint {#1}{#2}}\xdef\temp{#2}}
```

If there is a page picture to output, then we want to ship it out after the
current page. Each page output routine calls `\nextshipout` after shipping out a
page which hooks us in.

If there is one or more pictures waiting to be output we split the vbox to the page size
and we rebox the result, leaving the remainder back in the `wholepagepic`. We
also capture the final penalty, which uses a protocol of special numbers to
communicate whether this image is a full page within margins or full page to the
edge image. If this image goes to the limits of the physical page then save the
page width and height and ship the image as a page and restore the physical page
dimensions and advance the page number. Otherwise this is a normal page filling
image to the margins and we create a `pagecontents` that consists of the image
which we shipout via the normal route.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="684"}
\def\dofigp@ge{
  \ifvoid\wholepagepic\else
    \trace{g}{wholepagepic is \the\ht\wholepagepic high}%
    \setbox0=\vsplit\wholepagepic to \PaperHeight
    \setbox0=\vbox{\unvbox 0\global\count254=\lastpenalty}%
    \trace{g}{lp:\t box0 is \the\ht0\space high, th:\the\textheight}%
    \ifnum\count254=11
      \def\pagecontents{
        \trace{g}{Topins=\the\ht\topins, Bottomins=\the\ht\bottomins, tlins=\the\ht\topleftins, blins=\the\ht\bottomleftins, trins=\the\ht\toprightins, brins=\the\ht\bottomrightins}%
        \box0%
        }%
      \plainoutput
    \else% expected values: 9 (full page) or 10000 (too big)
      \dimen9=\pdfpagewidth \dimen8=\pdfpageheight
      \shipwithcr@pmarks{\box0}%
      \pdfpagewidth=\dimen9 \pdfpageheight=\dimen8
      \advancepageno
    \fi
  \fi
}
\let\nextshipout=\dofigp@ge
```

The special routine for shipping out a full page image is nearly identical to
the routine for shipping a page with cropmarks. It starts out identically by
adjusting the physical page dimensions to account for any additional cropmarks.
The page is shifted from the default 1 inch from top left that TeX uses. Then we
shipout a 0 size vbox with appropriate page information in the PDF. At this
point ❶ the special routine becomes much simpler. It simply inserts a box of
the page size with shrink and stretch all round it, consisting of the box passed
in. Finally it adds any actual cropmarks.

\fileheader{ptx-cropmarks.tex}
```{.latex .numberLines startFrom="152"}
\def\shipcompletep@gewithcr@pmarks#1{% \shipout box #1, adding cropmarks if required
                                     % but without adding margins, borders, etc
                                     % (used for \includepdf)
  \dimen0=0\ifCropMarks .5\fi in
  \advance\pdfpagewidth by 2\dimen0 % increase PDF media size
  \advance\pdfpageheight by 2\dimen0
  \hoffset=-1in \voffset=-1in % shift the origin to (0,0)
  \shipout\vbox to 0pt{% ship the actual page
    %%%%% The following was added to help produce proper x1a PDF output (djd - 20150504)
    %%%%% Note the \special line here seems to work but there may be a better location for it
    %%%%% Also, the numbers used are hard coded now but need to be calculated
    \ifCropMarks
      \pdfcropwidth=\pdfpagewidth\advance\pdfcropwidth by -\dimen0
      \pdfcropheight=\pdfpageheight\advance\pdfcropheight by -\dimen0
      \def\tmp{\dimen0}
      \special {pdf: put @thispage <</MediaBox [0 0 \strip@pt\pdfpagewidth \space
        \strip@pt\pdfpageheight ] /TrimBox [\strip@pt\tmp \space
        \strip@pt\tmp \space \strip@pt\pdfcropwidth \space
        \strip@pt\pdfcropheight ] /ArtBox [\strip@pt\tmp \space
        \strip@pt\tmp \space \strip@pt\pdfcropwidth \space \strip@pt\pdfcropheight ]>>}
    \else
      \special {pdf: put @thispage <</MediaBox [0 0 \strip@pt\pdfpagewidth \space
        \strip@pt\pdfpageheight ] /TrimBox [0 0 \strip@pt\pdfpagewidth \space
        \strip@pt\pdfpageheight ] /ArtBox [0 0 \strip@pt\pdfpagewidth \space
        \strip@pt\pdfpageheight ]>>}
    \fi
    \trace{p}{Pagesize \the\pdfpagewidth, \the\pdfpageheight}
    % End inserted \special line
    \offinterlineskip                                                           ①
    \vbox to \pdfpageheight{\vss
      \hbox to \pdfpagewidth{\hss#1\hss}
      \vss}
    \vss
    \docr@pmarks
  }%
}
```

## .picpages

The `.picpages` file has a number of roles. It contains information about each
figure in the document including it's page number, the filename of the figure,
its `pgpos`, the copyright information and anything else that may affect its
position and size. The `.picpages` file gets used by ptxprint to autogenerate
the copyright statement for the verso pages, for example. Within the ptx macros
the information is used to test whether figures have moved around or not. This
allows us to know whether a rerun is needed to help stabalise image positions.

The entry point to the `.picpages` handling is `\openpicpages` which reads in
the existing `.picpages` file if present and adds a hook to the end of the
document to see if any figures moved. In reading the `.picpages` file
`\figonpage` is called for each figure that was previously output. This then
saves an appropriate variable with information about the position of the figure.

As we go through we write new `\figonpage` calls into a new `.picpages` file of
the same name. Then at the end of the job, we reread that new file, but instead
of just storing the information, we switch to using `\checkfigpage` which
compares what has been read with what was stored for the previous read of the
`.picpages` file. If there are any difference, then a message is given to the
user implying they should rerun.

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="626"}
\def\inputpicp@ges "#1"{%read picpages file.
    \openin\picl@ctest="#1" % test to see if the file exists before reading it.
    \ifeof\picl@ctest \let\n@xt=\relax
    \else \def\n@xt{\input "#1"}%
    \fi
    \closein\picl@ctest
    \n@xt
}

\def\openpicpages "#1"{%set up a .picpages file, and check for changes at the end of the run.
  \ifpicp@gefile\else
    \inputpicp@ges "#1"
    \picp@gefiletrue
    \addtoendhooks{\finishpicp@ges "#1"}
    \openout\picp@ges="#1" % test to see if the file exists
  \fi
}
\def\l@stfignum{0}
\def\finishpicp@ges "#1"{\immediate\closeout\picp@ges % close the picpages file, then re-read it and check for changes
   \tempfalse
   \trace{g}{lastfignum was \l@stfignum, \the\im@gecount}%
   \ifnum\im@gecount=\l@stfignum\else
     \temptrue
     \trace{g}{Number of images has changed}%
   \fi
   \let\figonpage=\checkfigpage
   \inputpicp@ges "#1"
   \iftemp\message{}\message{*** Figures have changed. It may be necessary to re-run the job}\fi% 
}

\def\writefigp@gelog#1{
  \write\picp@ges{\string\figonpage{\the\pageno}#1}%
}
```

#1 ~ Page number
#2 ~ Figure number
#3 ~ File name
#4 ~ pgpos parameter
#5 ~ Copyright info from \\fig line
#6 ~ Anything else that might affect page breaking or alignment (e.g. size, rotation)

\fileheader{ptx-figure.tex}
```{.latex .numberLines startFrom="667"}
\def\figonpage#1#2#3#4#5#6{\x@\gdef\csname fig#2p@ge\endcsname{#1}%Page number
\x@\gdef\csname fig#2p@ram\endcsname{#3#4#6}% Any other parameters that might affect page-breaking.
  \xdef\l@stfignum{#2}%
%\trace{P}{Picture "#3" turned up on page #1}%
}%
\def\checkfigpage#1#2#3#4#5#6{
  \edef\ch@ck{#3#4#6}%
  \trace{g}{Comparing "\ch@ck" with "\csname fig#2p@ram\endcsname"}%
  \x@\ifx\csname fig#2p@ram\endcsname\ch@ck\else\trace{g}{Figure #2 parameters changed}
   %\temptrue %Probably don't matter on their own, but could change pagination. Significant pagination changes should be caught by other tests.
  \fi
  \edef\ch@ck{#1}
  \x@\ifx\csname fig#2p@ge\endcsname\ch@ck\else\trace{g}{Figure #2 page changed from \ch@ck \space to \csname fig#2p@ge\endcsname}\temptrue\fi
}
```

## .piclist

At the end of picture handling is the use of `.piclist` files which are at their
core a list of `\fig` statements, but without the `\fig` and with an anchor so
that the macros know where to place the figure.

`.piclist` files are read by testing that they can be open and then opening the
file and reading the first entry. At the end `\closepiclist` is called to close
the file.

\fileheader{ptx-pic-list.tex}
```{.latex .numberLines startFrom="72"}
\newread\p@clist
\def\openpiclist "#1" {%
  \closein\p@clist
%  \immediate\write-1{(opening piclist "#1")}%
  \openin\p@clist="#1"
  \ifeof\p@clist \immediate\write-1{(no picture list "#1" found)}%
  \else \immediate\write16{(\ifIncludeFigures using\else skipping\fi
    \space pictures from list "#1")}\fi
  \readnextp@c
}
\def\closepiclist{%
  \ifeof\p@clist\else \errmessage{Did not use all pictures in list. Waiting for \p@cref}\fi
  \closein\p@clist
}
```

`.piclist` files are read sequentially an interpreted sequentially. Only the
next picture is read and its location is stored. If that location never matches,
no new picture lines will be read, of if there is a syntax error, the rest of
the file will be ignored.

In reading a line from the file the catcodes of various characters are put back
to normal while the line is read. The next line from the file is read. If the
line is blank or empty then we keep recursing until we either get to the end or find
something worth parsing. Parsing a line involves expanding the line after the
`\parsep@cline` which uses pattern matching to break up the components. Thus the
syntax of a `.piclist` file is pretty strict. `#1` is the book id, `#2` the
chapter and `#3` is the verse. The verse needs to directly correspond to what is
found as the parameter to `\v` so may include briding elements or suffixes. `#4`
is everything that would be in a `\fig` range, thus may be USFM2 or USFM3.

\fileheader{ptx-pic-list.tex}
```{.latex .numberLines startFrom="44"}
\def\parsep@cline #1 #2.#3 #4\end{%
  \uppercase{\def\piclstb@@kref{#1}}%
  \xdef\p@cref{\piclstb@@kref#2.#3}\gdef\p@cspec{#4}%
}

\def\readnextp@c{%
  \ifeof\p@clist
    \global\let\p@cref\empty
  \else
    \begingroup
      \catcode`0=12 \catcode`1=12 \catcode`2=12 \catcode`3=12 \catcode`4=12
      \catcode`5=12 \catcode`6=12 \catcode`7=12 \catcode`8=12 \catcode`9=12
      \catcode`.=12 \catcode`\%=5 \catcode`\/=12
      \endlinechar=-1
      \read\p@clist to \p@cline
      \ifx\p@cline\P@R\readnextp@c\else
        \ifx\p@cline\empty\readnextp@c\else
          \trace{P}{Read piclist line: \p@cline}%
          \expandafter\parsep@cline\p@cline\end
        \fi
      \fi
    \endgroup
  \fi
}
\def\P@R{\par}
```

Before each verse ❶, `\ch@ckpiclist` is run to see if a figure is to be
inserted at this point. The check creates a reference from the current book,
chapter and verse and this is tested with the current picture reference which
was created when the last `.piclist` line was parsed. If it matches then `dop@c`
is called which does the work of calling `\d@figure` to insert the picture and
then to read the next line from the `.piclist` file. And, in case there is more
than one entry for a verse, we check again.

If the check failed and we are in a diglot, then try again but add an `L` or `R`
suffix to the book id.

\fileheader{ptx-pic-list.tex}
```{.latex .numberLines startFrom="89"}
\def\dop@c{%
  \x@\d@figure\x@{\p@cspec}%
  \readnextp@c
  \ch@ckpiclist%Repeat?
}

\def\ch@ckpiclist{%
  \edef\c@rref{\id@@@\ch@pter.\v@rse}%
  \trace{P}{\p@cref =\c@rref?}%
  \ifx\c@rref\p@cref \dop@c
  \else
    \ifdiglot
      \edef\dc@rref{\id@@@\ifdiglotL L\else R\fi\ch@pter.\v@rse}%
      \trace{P}{\p@cref =\dc@rref?}%
      \ifx\dc@rref\p@cref \dop@c\fi
    \fi
  \fi
  \trace{P}{End of checkpic}%
}

\addtopreversehooks{\ch@ckpiclist}                                              ①
```

<!-- # Diglot -->
